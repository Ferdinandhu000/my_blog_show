[{"content":"问题背景 解决分类问题是机器学习的其中重要一个分支。要实现分类首先需要获得相应数据进行学习，而现实生活中我们得到的数据通常是不平衡的（例如银行需要对异常交易和正常交易数据进行分类，而学习的数据中大部分是正常的交易数据，异常交易数据毕竟占少数），这就会使分类的结果产生影响。为此，本论文所提出的MTGP-SMOTE方法在数据层面运用合成少数过采样技术（SMOTE）方法对原始数据进行过采样（oversampling），而后借助遗传编程中的多树遗传编程（Multitree Genetic Programming）策略，将单个树的运行结果作为一个独立的填补数据，从而实现多树对总体数据的填补。\n概念理解 Majority class（$Maj$） 原始数据集中样本数量较多的类别（例如银行交易数据中的正常交易数据）\nMinority class（$Min$） 原始数据集中样本数量较少的类别（如异常银行交易）\nSMOTE算法 SMOTE（Synthetic Minority Over-sampling Technique）合成少数过采样技术。\n算法流程 确定临近数量 选择近邻样本 合成新样本 遗传编程（GP） 遗传编程是一种模拟自然界进化过程的算法，包含以下组件：\n1. 初始化（Initialization） 常用的初始化方法包括：\nGrow Full Ramped half-and-half 本文使用\u0026quot;Ramped half-and-half\u0026quot;方法进行初始化\n2. 选择（Selection） 从当前代中选择某些个体作为下一代的父代的过程。本文使用的选择方法是\u0026quot;精英策略\u0026quot;（elite strategy）。\n3. 适应度（Fitness） 衡量遗传过程质量的指标，对后续的交叉和变异操作起决定性作用。\n4. 交叉（Crossover） 从两个随机选取的父代个体中产生两个子代个体进行互换。\n5. 变异（Mutation） 类似于生成新基因的过程，有助于形成种群多样性，使算法有可能跳出局部最优。\n6. 复制（Replication） 父代个体在未经任何变化的条件下从当前代复制到新一代。（本文使用的算子没有包括复制操作）\n以上操作是否发生完全取决于该个体的适应度，即个体的适应度越大，被选中的概率越大。\nMTGP-SMOTE的具体流程 确定需要填补的少数类的个体数量（即为树的数量） 确定Terminal set和Function set，定义树中运算的基本结构 **获得目标评估对（Mait, Mint）**用于指导个体的生成。不同的树要分配不同的（Mait, Mint）作为后续评估目标生成的标准 适应度评估：利用距离测量和角度测量两种方法进行评估，评价个体的生成情况，决定后续是否进行交叉或变异操作 与STGP的区别 STGP生成的一棵树只能作为一个样本，而MTGP同时生成多棵树作为一组样本，相比之下效率更高 在进行适应度评估中，STGP只是对每个样本进行独立评估，无法保证全局最优，而MTGP是将每个样本的适应度汇总成整体的适应度进行评估，分布上来看，生成样本的多样性更佳 在遗传操作上，MTGP相比STGP对优质样本个体进行保护，使生成的样本质量更佳 一些问题 论文使用到了变异算子和交叉算子，为什么不考虑使用复制算子，复制算子的使用对整个系统会有什么影响？\n该方法可以实现多元分类还是只能处理二元分类？\n在处理实际问题时，树中存储的数据是什么？\n","date":"2025-09-13T19:15:55+08:00","permalink":"https://ferdinandhu.netlify.app/p/mtgp-smote%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB%E7%AC%94%E8%AE%B0/","title":"MTGP-SMOTE论文研读笔记"},{"content":"Java多线程基础 1. 基本概念 1.1 进程与线程 进程 系统运行的基本单位 一个进程就是一个正在运行的应用程序 进程拥有独立的内存空间和系统资源 线程 是比进程更小的执行单位 一个进程可以包含多个线程 同一进程中的线程共享进程的内存空间和资源 线程是CPU调度的基本单位 1.2 并发与并行 并发(Concurrency) 指通过交替执行的方式，使多个任务在同一时间段内发生 单核CPU通过时间片轮转实现并发 适用于I/O密集型任务 并行(Parallelism) 指通过同时处理的方式，在同一时刻执行多个任务 需要多核CPU支持 适用于计算密集型任务 注：对于单核计算机，虽然只有一个CPU，但是可以通过时间片轮转同时处理多个任务，这种情况下实现的是并发而非并行。\n2. Java中实现多线程的三种方式 2.1 继承Thread类 这是最直接的方式，通过继承Thread类并重写run()方法来实现：\n1 2 3 4 5 6 7 8 9 public class MyThread extends Thread { @Override public void run() { // 添加一个任务打印一百次: for (int i = 1; i \u0026lt; 101; i++) { System.out.println(\u0026#34;MyThread线程任务 ---- \u0026#34; + i); } } } 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class UseMyThread { public static void main(String[] args) { // 创建线程对象 MyThread mt = new MyThread(); // 启动线程 mt.start(); // 注意：不要直接调用run()方法，这样不会启动新线程 // 主线程的任务 for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;主线程任务---\u0026#34; + i); } } } 2.2 实现Runnable接口 这种方式更加灵活，因为Java支持多实现：\n1 2 3 4 5 6 7 8 public class MyRunnable implements Runnable { @Override public void run() { for (int i = 1; i \u0026lt; 101; i++) { System.out.println(\u0026#34;Runnable任务----\u0026#34; + i); } } } 使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class UseMyRunnable { public static void main(String[] args) { // 创建任务对象 MyRunnable task = new MyRunnable(); // 创建线程对象，并传入任务 Thread thread = new Thread(task); // 启动线程 thread.start(); // 主线程任务 for (int i = 0; i \u0026lt; 100; i++) { System.out.println(\u0026#34;主线程------\u0026#34; + i); } } } 2.3 实现Callable接口 这种方式可以有返回值，并且可以抛出异常：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class CallableExample { public static void main(String[] args) { // 创建Callable任务 Callable\u0026lt;Integer\u0026gt; task = new Callable\u0026lt;Integer\u0026gt;() { @Override public Integer call() throws Exception { int sum = 0; for (int i = 1; i \u0026lt;= 1000; i++) { sum += i; } return sum; // 可以返回计算结果 } }; // 将Callable包装成FutureTask FutureTask\u0026lt;Integer\u0026gt; futureTask = new FutureTask\u0026lt;\u0026gt;(task); // 创建线程并启动 Thread thread = new Thread(futureTask); thread.start(); try { // 获取线程执行结果 Integer result = futureTask.get(); System.out.println(\u0026#34;计算结果: \u0026#34; + result); } catch (InterruptedException | ExecutionException e) { e.printStackTrace(); } } } 3. 线程的生命周期 线程在其生命周期中可能处于以下六种状态：\nNEW（新建）\n线程被创建但尚未启动的状态 调用new Thread()后的状态 RUNNABLE（可运行）\n线程正在Java虚拟机中运行的状态 包括就绪（等待CPU）和运行中两个细分状态 BLOCKED（阻塞）\n线程被阻塞等待监视器锁的状态 试图进入同步方法/代码块时发生 WAITING（等待）\n线程无限期等待另一个线程执行特定操作 调用Object.wait()等方法后的状态 TIMED_WAITING（计时等待）\n线程等待另一个线程执行操作，但有时间限制 调用Thread.sleep(long)等方法后的状态 TERMINATED（终止）\n线程完成执行或因异常而终止 run()方法执行完毕后的状态 4. 多线程实战案例 4.1 交互式弹球游戏 本案例实现了一个多线程的弹球游戏，具有以下特点：\n鼠标点击产生新的彩色小球 小球之间可以碰撞并改变运动方向 使用空格键可以暂停/继续游戏 采用双缓冲技术避免画面闪烁 单线程控制所有小球的运动 效果展示： Ball类 小球类，定义小球的基本属性和行为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import java.awt.*; import java.util.Random; public class Ball { // 位置坐标 int x, y; // 小球大小 int size = 50; // 运动速度 int speedX = 1; int speedY = 1; // 小球颜色 Color color = Color.BLACK; Graphics g; Random random = new Random(); public Ball(int x, int y, Graphics g, Color color) { this.x = x; this.y = y; this.g = g; this.color = color; } // getter和setter方法 public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } public void setSize(int size) { this.size = size; } public void setSpeedX(int speedX) { this.speedX = speedX; } public void setSpeedY(int speedY) { this.speedY = speedY; } public int getX() { return x; } public int getY() { return y; } public int getSize() { return size; } public int getSpeedX() { return speedX; } public int getSpeedY() { return speedY; } public Graphics getGraphics() { return g; } // 计算与其他小球的距离 public double distanceTo(Ball other) { return Math.sqrt(Math.pow((other.getX() - this.x), 2) + Math.pow((other.getY() - this.y), 2)); } // 绘制小球 public void draw(Graphics g, int x, int y, int speedX, int speedY) { g.setColor(color); g.fillOval(x + speedX, y + speedY, size, size); } } ThreadGameUI类 游戏主界面类，负责初始化窗口和组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import javax.swing.*; import java.awt.*; public class ThreadGameUI { static JPanel jp = new JPanel(); public void showUI() { // 创建主窗口 JFrame jf = new JFrame(\u0026#34;ThreadGame\u0026#34;); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setSize(800, 800); jf.setLocationRelativeTo(null); // 设置面板 jp.setBackground(Color.WHITE); jf.add(jp, BorderLayout.CENTER); jf.setVisible(true); // 获取绘图上下文 Graphics g = jp.getGraphics(); // 添加事件监听器 ThreadListener listener = new ThreadListener(g); jf.addMouseListener(listener); GameControlListener gcl = new GameControlListener(); jf.addKeyListener(gcl); // 启动游戏线程 WorkThread wt = new WorkThread(gcl); wt.g = g; Thread t = new Thread(wt); t.start(); } public static void main(String[] args) { new ThreadGameUI().showUI(); } } ThreadListener类 鼠标事件监听器，处理创建新小球：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import java.awt.*; import java.awt.event.*; import java.util.*; import java.util.List; public class ThreadListener implements MouseListener { Graphics g; Random random = new Random(); static List\u0026lt;Ball\u0026gt; balls = new ArrayList\u0026lt;\u0026gt;(); public ThreadListener(Graphics g) { this.g = g; } @Override public void mouseClicked(MouseEvent e) { // 创建随机颜色的小球 balls.add(new Ball(e.getX(), e.getY(), g, new Color(random.nextInt(256), random.nextInt(256), random.nextInt(256)))); } // 其他鼠标事件方法（未使用） @Override public void mousePressed(MouseEvent e) {} @Override public void mouseReleased(MouseEvent e) {} @Override public void mouseEntered(MouseEvent e) {} @Override public void mouseExited(MouseEvent e) {} } WorkThread类 游戏主线程，负责更新和绘制小球：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import java.awt.*; import java.awt.image.BufferedImage; import static java.awt.image.BufferedImage.TYPE_INT_RGB; public class WorkThread implements Runnable { GameControlListener gcl; public Graphics g; public WorkThread(GameControlListener gcl) { this.gcl = gcl; } @Override public void run() { // 创建双缓冲 BufferedImage bufferedImage = new BufferedImage( ThreadGameUI.jp.getWidth(), ThreadGameUI.jp.getHeight(), TYPE_INT_RGB ); Graphics bufferedG = bufferedImage.getGraphics(); while(true) { try { Thread.sleep(5); } catch (InterruptedException e) { throw new RuntimeException(e); } // 清空画布 bufferedG.setColor(Color.WHITE); bufferedG.fillRect(0, 0, ThreadGameUI.jp.getWidth(), ThreadGameUI.jp.getHeight()); if(!gcl.isPause) { // 更新所有小球 for (int i = 0; i \u0026lt; ThreadListener.balls.size(); i++) { Ball ball = ThreadListener.balls.get(i); // 检查小球碰撞 for (int j = 0; j \u0026lt; ThreadListener.balls.size(); j++) { Ball ball2 = ThreadListener.balls.get(j); if (ball != ball2) { double distance = ball.distanceTo(ball2); if (distance \u0026lt;= ball.getSize()) { ball.setSpeedX(-ball.getSpeedX()); ball.setSpeedY(-ball.getSpeedY()); } } } // 更新位置 int newX = ball.getX() + ball.getSpeedX(); int newY = ball.getY() + ball.getSpeedY(); // 边界检查 if (newX \u0026lt;= 0 || newX \u0026gt;= ThreadGameUI.jp.getWidth() - ball.getSize()) { ball.setSpeedX(-ball.getSpeedX()); } if (newY \u0026lt;= 0 || newY \u0026gt;= ThreadGameUI.jp.getWidth() - ball.getSize()) { ball.setSpeedY(-ball.getSpeedY()); } // 更新位置并绘制 ball.setX(newX); ball.setY(newY); ball.draw(bufferedG, ball.getX(), ball.getY(), ball.getSpeedX(), ball.getSpeedY()); } } // 将缓冲区内容绘制到屏幕 g.drawImage(bufferedImage, 0, 0, null); } } } GameControlListener类 键盘事件监听器，处理游戏暂停/继续：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import java.awt.event.KeyEvent; import java.awt.event.KeyListener; public class GameControlListener implements KeyListener { public boolean isPause = false; @Override public void keyPressed(KeyEvent e) { // 空格键切换暂停状态 if (e.getKeyChar() == \u0026#39; \u0026#39;) { isPause = !isPause; } } // 其他键盘事件方法（未使用） @Override public void keyTyped(KeyEvent e) {} @Override public void keyReleased(KeyEvent e) {} } ","date":"2025-07-20T18:44:52+08:00","permalink":"https://ferdinandhu.netlify.app/p/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Java多线程学习笔记"},{"content":"文件资源管理器界面 v2.0 项目介绍 本项目是基于Java Swing开发的文件资源管理器,在v1.0版本的基础上进行了多项功能增强和优化。新版本增加了文件属性显示、文件搜索、右键菜单等功能,并优化了界面布局和用户交互体验。\n功能特性 文件浏览与管理： 支持文件和文件夹的层级显示 文件大小和数量统计显示 支持地址栏直接跳转 文件操作： 双击打开：支持文件和文件夹的打开 右键菜单：提供常用操作选项 文件删除：支持文件和非空文件夹的删除 文件重命名：支持文件和文件夹的重命名 新建文件夹：支持在当前目录创建新文件夹 搜索功能： 支持文件名模糊搜索 实时显示搜索结果数量 独立搜索结果窗口展示 界面优化： 自适应布局：文件图标自动换行排列 状态栏显示：展示当前目录文件统计信息 滚动条支持：处理大量文件的显示 类的设计 类名 继承/实现 主要功能 FileBrowserUI JFrame 主界面管理,实现文件浏览和操作功能 FindFileUI JFrame 独立展示查找结果的界面 ClickListener MouseListener 处理文件夹的双击打开和右键菜单事件 FileLists / 实现文件搜索功能,管理搜索结果 OpenMenuListener MouseListener 处理空白区域的右键菜单事件 WrapLayout FlowLayout 实现文件图标的自动换行布局 具体实现 1. 主界面优化 (FileBrowserUI.java) 主界面在v1.0的基础上进行了多项改进：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class FileBrowserUI extends JFrame { private JPanel filePanel; // 文件显示面板 private String currentPath; // 当前路径 public FileBrowserUI(String path){ this.currentPath = path; // ... 基础设置代码 ... // 创建文件显示面板,使用自定义的WrapLayout布局 filePanel = new JPanel(); filePanel.setLayout(new WrapLayout(FlowLayout.LEFT,15,20)); // 创建滚动面板 JScrollPane scrollPane = new JScrollPane(filePanel); scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED); scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); // 创建底部信息面板 JPanel bottomPanel = createBottomPanel(); // 添加到主窗口 this.add(scrollPane, BorderLayout.CENTER); this.add(bottomPanel, BorderLayout.SOUTH); } 主要改进包括：\n使用WrapLayout实现文件图标自动换行 添加滚动面板支持大量文件显示 底部添加文件信息统计面板 实现文件列表的刷新功能 2. 文件搜索功能 (FileLists.java) 新增的文件搜索类实现了文件的递归搜索和模糊匹配：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 public class FileLists { static List\u0026lt;File\u0026gt; fileList = new ArrayList\u0026lt;\u0026gt;(); static int fileSize; // 递归遍历所有文件 public static void listAllFiles(String path) { File file = new File(path); File[] files = file.listFiles(); for (File f : files) { fileSize += f.length(); if(f.isDirectory()) { listAllFiles(f.getAbsolutePath()); } fileList.add(f); } } // 模糊搜索文件数量 public static int fuzzySearchCount(String name) { int count = 0; for (File f : fileList) { if(f.getName().contains(name)) { count++; } } return count; } // 获取模糊搜索结果 public static String[] fuzzySearchFiles(String name) { int n = fuzzySearchCount(name); String[] fileNames = new String[n]; int index = 0; for(File f : fileList) { if(f.getName().contains(name)) { fileNames[index++] = f.getAbsolutePath(); } } return fileNames; } } 3. 右键菜单增强 (OpenMenuListener.java) 新增了空白区域的右键菜单功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class OpenMenuListener implements MouseListener { @Override public void mouseClicked(MouseEvent e) { if(e.getButton() == 3) { // 右键点击 JPanel panel = (JPanel) e.getSource(); String currentPath = ((FileBrowserUI)SwingUtilities.getWindowAncestor(panel)).getCurrentPath(); // 创建右键菜单 JPopupMenu menu = new JPopupMenu(); String[] menuItems = {\u0026#34;刷新\u0026#34;, \u0026#34;创建新目录\u0026#34;}; for(String item : menuItems) { JMenuItem menuItem = new JMenuItem(item); menu.add(menuItem); menuItem.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { if (e.getActionCommand().equals(\u0026#34;创建新目录\u0026#34;)) { // 创建新目录的实现 String fileName = JOptionPane.showInputDialog(panel, \u0026#34;请输入新目录名：\u0026#34;); if (fileName != null \u0026amp;\u0026amp; !fileName.trim().isEmpty()) { File newFile = new File(currentPath, fileName); if (newFile.exists()) { JOptionPane.showMessageDialog(panel, \u0026#34;该目录已存在！\u0026#34;); } else { if (newFile.mkdir()) { JOptionPane.showMessageDialog(panel, \u0026#34;目录创建成功！\u0026#34;); ((FileBrowserUI)SwingUtilities.getWindowAncestor(panel)).refreshFileList(); } else { JOptionPane.showMessageDialog(panel, \u0026#34;目录创建失败！\u0026#34;); } } } } else if(e.getActionCommand().equals(\u0026#34;刷新\u0026#34;)) { ((FileBrowserUI)SwingUtilities.getWindowAncessor(panel)).refreshFileList(); } } }); } menu.show(e.getComponent(),e.getX(),e.getY()); } } } 4. 自适应布局实现 (WrapLayout.java) 为了优化文件图标的显示效果,实现了自定义的WrapLayout布局管理器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class WrapLayout extends FlowLayout { private Dimension preferredLayoutSize; // 计算首选布局大小 private Dimension layoutSize(Container target, boolean preferred) { synchronized (target.getTreeLock()) { // 获取容器的目标宽度 Container container = target; while (container.getSize().width == 0 \u0026amp;\u0026amp; container.getParent() != null) { container = container.getParent(); } int targetWidth; if (container instanceof JScrollPane) { targetWidth = ((JScrollPane) container).getViewport().getWidth(); } else { targetWidth = container.getSize().width; } // ... 布局计算逻辑 ... return dim; } } } 功能展示 1. 文件浏览和操作 双击文件夹：打开新窗口显示文件夹内容 双击文件：使用系统默认程序打开 右键菜单：提供打开、删除、重命名等操作 2. 文件搜索 在搜索框输入关键字进行模糊搜索 搜索结果在新窗口中显示 显示搜索结果数量 3. 文件信息显示 底部状态栏显示当前目录的文件数量 显示当前目录的总文件大小 文件大小自动转换单位(B/KB/MB/GB) 最终效果 最终代码 FileBrowserUI.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 import javax.swing.*; import java.awt.*; import java.io.File; import java.util.Objects; public class FileBrowserUI extends JFrame { static String root = \u0026#34;D:\\\\test\u0026#34;; static ClickListener clickListener = new ClickListener(); static OpenFileListener openFileListener = new OpenFileListener(); static OpenMenuListener openMenuListener = new OpenMenuListener(); private JPanel filePanel; // 将filePanel设为成员变量 private String currentPath; // 添加当前路径成员变量 public FileBrowserUI(String path){ this.currentPath = path; // 保存当前路径 this.setTitle(\u0026#34;文件浏览器 路径：\u0026#34; + root); this.setLocationRelativeTo(null); this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); this.setLayout(new BorderLayout()); this.setSize(800,600); JPanel pathPanel = new JPanel(); JLabel pathJla = new JLabel(\u0026#34;地址：\u0026#34;); JTextField pathJtf = new JTextField(path,35); JButton pathBtn = new JButton(\u0026#34;跳转\u0026#34;); JTextField searchJtf = new JTextField(\u0026#34;搜索\u0026#34;,20); JButton searchBtn = new JButton(\u0026#34;搜索\u0026#34;); pathPanel.add(pathJla); pathPanel.add(pathJtf); pathPanel.add(pathBtn); pathPanel.add(searchJtf); pathPanel.add(searchBtn); pathPanel.setPreferredSize(new Dimension(0,40)); filePanel = new JPanel(); // 初始化成员变量 filePanel.setLayout(new WrapLayout(FlowLayout.LEFT,15,20)); refreshFileList(); // 使用新方法来刷新文件列表 // 创建底部信息面板 JPanel bottomPanel = createBottomPanel(); filePanel.setBackground(Color.WHITE); this.add(pathPanel, BorderLayout.NORTH); // 创建滚动面板并添加文件面板 JScrollPane scrollPane = new JScrollPane(filePanel); scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED); scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); scrollPane.getVerticalScrollBar().setUnitIncrement(16); // 设置滚动速度 this.add(scrollPane, BorderLayout.CENTER); this.add(bottomPanel, BorderLayout.SOUTH); FileLists.listAllFiles(path); searchBtn.addActionListener(e -\u0026gt; { String name = searchJtf.getText(); if(name.equals(\u0026#34;搜索\u0026#34;) || name.isEmpty()){ return; } FileLists.fuzzySearchCount(name); new FIndFileUI(name); }); pathBtn.addActionListener(e -\u0026gt; { String pathInput = pathJtf.getText(); if(pathInput.equals(path) || pathInput.isEmpty()){ return; } new FileBrowserUI(pathInput); }); filePanel.addMouseListener(openMenuListener); setVisible(true); } // 获取当前路径的方法 public String getCurrentPath() { return currentPath; } // 刷新文件列表的方法 public void refreshFileList() { filePanel.removeAll(); // 清除所有组件 JComponent[] jComponents = listFiles(currentPath); for (JComponent jComponent : jComponents) { filePanel.add(jComponent); } filePanel.revalidate(); // 重新验证布局 filePanel.repaint(); // 重新绘制 updateBottomPanel(); // 更新底部信息 } // 创建新目录的方法 private void createNewDirectory() { String dirName = JOptionPane.showInputDialog(this, \u0026#34;请输入目录名：\u0026#34;, \u0026#34;创建新目录\u0026#34;, JOptionPane.PLAIN_MESSAGE); if (dirName != null \u0026amp;\u0026amp; !dirName.trim().isEmpty()) { File newDir = new File(currentPath, dirName); if (!newDir.exists()) { if (newDir.mkdir()) { refreshFileList(); // 创建成功后刷新列表 JOptionPane.showMessageDialog(this, \u0026#34;目录创建成功！\u0026#34;, \u0026#34;成功\u0026#34;, JOptionPane.INFORMATION_MESSAGE); } else { JOptionPane.showMessageDialog(this, \u0026#34;目录创建失败！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } else { JOptionPane.showMessageDialog(this, \u0026#34;目录已存在！\u0026#34;, \u0026#34;错误\u0026#34;, JOptionPane.ERROR_MESSAGE); } } } // 创建底部信息面板的方法 private JPanel createBottomPanel() { JPanel bottomPanel = new JPanel(new FlowLayout(FlowLayout.LEFT, 20, 5)); bottomPanel.setPreferredSize(new Dimension(0, 30)); updateBottomPanel(bottomPanel); return bottomPanel; } // 更新底部信息的方法 private void updateBottomPanel() { Component[] components = getContentPane().getComponents(); for (Component component : components) { if (component instanceof JPanel \u0026amp;\u0026amp; component.getY() \u0026gt; getHeight() - 50) { JPanel bottomPanel = (JPanel) component; updateBottomPanel(bottomPanel); break; } } } // 更新底部面板信息的辅助方法 private void updateBottomPanel(JPanel bottomPanel) { bottomPanel.removeAll(); int fileCount = Objects.requireNonNull(new File(currentPath).listFiles()).length; JLabel fileCountInfo = new JLabel(\u0026#34;文件数量：\u0026#34; + fileCount); JLabel fileSizeInfo = new JLabel(\u0026#34;文件大小：\u0026#34; + formatFileSize(calculateDirectorySize(new File(currentPath)))); fileCountInfo.setFont(new Font(\u0026#34;宋体\u0026#34;,Font.BOLD,15)); fileSizeInfo.setFont(new Font(\u0026#34;宋体\u0026#34;,Font.BOLD,15)); bottomPanel.add(fileCountInfo); bottomPanel.add(fileSizeInfo); bottomPanel.revalidate(); bottomPanel.repaint(); } public JComponent[] listFiles(String path){ File rootFile = new File(path); File[] files = rootFile.listFiles(); JComponent[] jComponent = null; if (files != null) { jComponent = new JComponent[files.length]; } ImageIcon pic1 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file1.png\u0026#34;))); ImageIcon pic2 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file2.png\u0026#34;))); ImageIcon pic3 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file3.png\u0026#34;))); if (files != null) { for (int i = 0; i \u0026lt; files.length; i++) { File f = files[i]; if(f.isDirectory()) { JButton btn = new JButton(); btn.setIcon(pic1); btn.setText(f.getName()); btn.setPreferredSize(new Dimension(90,100)); btn.setVerticalTextPosition(SwingConstants.BOTTOM); btn.setHorizontalTextPosition(SwingConstants.CENTER); // 水平居中 btn.setActionCommand(f.getAbsolutePath()); btn.setToolTipText(f.getName()); btn.addMouseListener(clickListener); jComponent[i] = btn; } else { JButton btn = new JButton(); btn.setIcon(pic3); btn.setText(f.getName()); btn.setPreferredSize(new Dimension(90,100)); btn.setVerticalTextPosition(SwingConstants.BOTTOM); btn.setHorizontalTextPosition(SwingConstants.CENTER); btn.setActionCommand(f.getAbsolutePath()); btn.setToolTipText(f.getName()); btn.addMouseListener(openFileListener); jComponent[i] = btn; } } } return jComponent; } public static long calculateDirectorySize(File f) { long size = 0; if (f.isDirectory()) { File[] files = f.listFiles(); if (files != null) { for (File file : files) { if (file.isFile()) { size += file.length(); } else { size += calculateDirectorySize(file); } } } } return size; } public static String formatFileSize(long size) { String[] units = {\u0026#34;B\u0026#34;, \u0026#34;KB\u0026#34;, \u0026#34;MB\u0026#34;, \u0026#34;GB\u0026#34;, \u0026#34;TB\u0026#34;}; int unitIndex = 0; double fileSize = size; while (fileSize \u0026gt;= 1024 \u0026amp;\u0026amp; unitIndex \u0026lt; units.length - 1) { fileSize /= 1024; unitIndex++; } return String.format(\u0026#34;%.2f %s\u0026#34;, fileSize, units[unitIndex]); } public static void main(String[] args) { new FileBrowserUI(root); } } FindFileUI.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import javax.swing.*; import java.awt.*; import java.io.File; import java.util.Objects; public class FIndFileUI extends JFrame { static ClickListener clickListener = new ClickListener(); static OpenFileListener openFileListener = new OpenFileListener(); public FIndFileUI(String name) { this.setTitle(\u0026#34;文件浏览器 根据 \\\u0026#34;\u0026#34; + name +\u0026#34;\\\u0026#34; 的查找结果：\u0026#34;); this.setLocationRelativeTo(null); this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); this.setLayout(new BorderLayout()); this.setSize(800,600); JPanel pathPanel = new JPanel(); pathPanel.setPreferredSize(new Dimension(0,40)); JPanel filePanel = new JPanel(); filePanel.setLayout(new WrapLayout(FlowLayout.LEFT,15,20)); // 使用WrapLayout替代FlowLayout filePanel.setBackground(Color.WHITE); this.add(pathPanel,BorderLayout.NORTH); // 创建滚动面板并添加文件面板 JScrollPane scrollPane = new JScrollPane(filePanel); scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED); scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER); scrollPane.getVerticalScrollBar().setUnitIncrement(16); // 设置滚动速度 this.add(scrollPane,BorderLayout.CENTER); JComponent[] jComponents = listFiles(name); for(JComponent jComponent : jComponents) { filePanel.add(jComponent); } JLabel infoLabel = new JLabel(\u0026#34;共找到 \u0026#34; + jComponents.length + \u0026#34; 个文件包含\u0026#34; + \u0026#34; \\\u0026#34;\u0026#34; + name + \u0026#34;\\\u0026#34;\u0026#34;); pathPanel.add(infoLabel, BorderLayout.CENTER); setVisible(true); } public JComponent[] listFiles(String name){ int n = FileLists.fuzzySearchCount(name); File[] files = new File[n]; String[] filePathNames = new String[n]; JComponent[] jComponents = new JComponent[n]; ImageIcon pic1 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file1.png\u0026#34;))); ImageIcon pic2 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file2.png\u0026#34;))); ImageIcon pic3 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file3.png\u0026#34;))); for(int i = 0; i \u0026lt; n; i++) { filePathNames[i] = FileLists.fuzzySearchFiles(name)[i]; File f = new File(filePathNames[i]); files[i] = f; if(f.isDirectory()) { JButton btn = new JButton(); btn.setIcon(pic1); btn.setText(f.getName()); btn.setPreferredSize(new Dimension(90,100)); btn.setVerticalTextPosition(SwingConstants.BOTTOM); btn.setHorizontalTextPosition(SwingConstants.CENTER); // 水平居中 btn.setActionCommand(f.getAbsolutePath()); btn.setToolTipText(f.getName()); btn.addMouseListener(clickListener); jComponents[i] = btn; } else { JButton btn = new JButton(); btn.setIcon(pic3); btn.setText(f.getName()); btn.setPreferredSize(new Dimension(90,100)); btn.setVerticalTextPosition(SwingConstants.BOTTOM); btn.setHorizontalTextPosition(SwingConstants.CENTER); btn.setActionCommand(f.getAbsolutePath()); btn.setToolTipText(f.getName()); btn.addMouseListener(openFileListener); jComponents[i] = btn; } } return jComponents; } } FileLists.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import javax.swing.*; import java.io.File; import java.util.ArrayList; import java.util.List; public class FileLists { static List\u0026lt;File\u0026gt; fileList = new ArrayList\u0026lt;\u0026gt;(); static int fileSize; public static void listAllFiles(String path) { File file = new File(path); File[] files = file.listFiles(); for (File f : files) { fileSize += f.length(); if( f.isDirectory()) { listAllFiles(f.getAbsolutePath()); } fileList.add(f); } } public static int fuzzySearchCount(String name) { int count = 0; for (File f : fileList) { if(f.getName().contains(name)) { count++; } } return count; } public static String[] fuzzySearchFiles(String name) { int n = fuzzySearchCount(name); String[] fileNames = new String[n]; int index = 0; for(File f : fileList) { if(f.getName().contains(name)) { fileNames[index++] = f.getAbsolutePath(); } } return fileNames; } } ClickListener.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; import java.io.File; public class ClickListener implements MouseListener { @Override public void mouseClicked(MouseEvent e) { if(e.getClickCount() == 2){ JButton btn = (JButton) e.getSource(); String path = btn.getActionCommand(); new FileBrowserUI(path); } if(e.getButton() == 3) { JButton btn = (JButton) e.getSource(); String path = btn.getActionCommand(); JPopupMenu menu = new JPopupMenu(); String[] items = {\u0026#34;打开\u0026#34;,\u0026#34;删除\u0026#34;,\u0026#34;重命名\u0026#34;}; for (String item : items) { JMenuItem menuItem = new JMenuItem(item); menu.add(menuItem); menuItem.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { if(e.getActionCommand().equals(\u0026#34;打开\u0026#34;)){ new FileBrowserUI(path); } else if(e.getActionCommand().equals(\u0026#34;删除\u0026#34;)){ File directory = new File(path); deleteDirectory(directory); if(doDelete) { JOptionPane.showMessageDialog(null, \u0026#34;删除成功！\u0026#34;); } } else if(e.getActionCommand().equals(\u0026#34;重命名\u0026#34;)){ String newName = JOptionPane.showInputDialog(null, \u0026#34;请输入新文件名：\u0026#34;); File file = new File(path); File newFile = new File(file.getParent() + \u0026#34;/\u0026#34; + newName); if(file.renameTo(newFile)){ JOptionPane.showMessageDialog(null, \u0026#34;重命名成功！\u0026#34;); } else JOptionPane.showMessageDialog(null, \u0026#34;重命名失败！\u0026#34;); } } }); } menu.show(e.getComponent(),e.getX(),e.getY()); } } @Override public void mousePressed(MouseEvent e) { } @Override public void mouseReleased(MouseEvent e) { } @Override public void mouseEntered(MouseEvent e) { } @Override public void mouseExited(MouseEvent e) { } static boolean doDelete = false; public static boolean deleteDirectory(File directory) { if (directory.exists()) { File[] files = directory.listFiles(); if (files != null) { doDelete = true; for (File file : files) { if (file.isDirectory()) { // 递归删除子目录 deleteDirectory(file); } else { // 删除文件 file.delete(); } } } } else { doDelete = false; JOptionPane.showMessageDialog(null, \u0026#34;文件不存在！\u0026#34;); return false; } // 最后删除空目录 return directory.delete(); } } OpenFileListener.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; import java.io.File; import java.io.IOException; public class OpenFileListener implements MouseListener { @Override public void mouseClicked(MouseEvent e) { if (e.getClickCount() == 2) { JButton btn = (JButton) e.getSource(); String path = btn.getActionCommand(); try { Runtime.getRuntime().exec(\u0026#34;notepad \u0026#34; + path); } catch (IOException ex) { throw new RuntimeException(ex); } } if (e.getButton() == 3) { JButton btn = (JButton) e.getSource(); String path = btn.getActionCommand(); JPopupMenu menu = new JPopupMenu(); String[] items = {\u0026#34;打开\u0026#34;, \u0026#34;删除\u0026#34;, \u0026#34;重命名\u0026#34;}; for (String item : items) { JMenuItem menuItem = new JMenuItem(item); menu.add(menuItem); menuItem.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { if (e.getActionCommand().equals(\u0026#34;打开\u0026#34;)) { try { Runtime.getRuntime().exec(\u0026#34;notepad \u0026#34; + path); } catch (IOException ex) { throw new RuntimeException(ex); } } else if (e.getActionCommand().equals(\u0026#34;删除\u0026#34;)) { File file = new File(path); if (file.exists()) { file.delete(); JOptionPane.showMessageDialog(null, \u0026#34;删除成功！\u0026#34;); } else { JOptionPane.showMessageDialog(null, \u0026#34;文件不存在！\u0026#34;); } } else if (e.getActionCommand().equals(\u0026#34;重命名\u0026#34;)) { String newName = JOptionPane.showInputDialog(null, \u0026#34;请输入新文件名：\u0026#34;); File file = new File(path); File newFile = new File(file.getParent() + \u0026#34;/\u0026#34; + newName); if (file.renameTo(newFile)) { JOptionPane.showMessageDialog(null, \u0026#34;重命名成功！\u0026#34;); } else { JOptionPane.showMessageDialog(null, \u0026#34;重命名失败！\u0026#34;); } } } }); } menu.show(e.getComponent(),e.getX(),e.getY()); } } @Override public void mousePressed(MouseEvent e) { } @Override public void mouseReleased(MouseEvent e) { } @Override public void mouseEntered(MouseEvent e) { } @Override public void mouseExited(MouseEvent e) { } } OpenMenuListener.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; import java.io.File; public class OpenMenuListener implements MouseListener { @Override public void mouseClicked(MouseEvent e) { if(e.getButton() == 3) { JPanel panel = (JPanel) e.getSource(); // 获取当前路径 String currentPath = ((FileBrowserUI)SwingUtilities.getWindowAncestor(panel)).getCurrentPath(); JPopupMenu menu = new JPopupMenu(); String[] menuItems = {\u0026#34;刷新\u0026#34;, \u0026#34;创建新目录\u0026#34;}; for(String item : menuItems) { JMenuItem menuItem = new JMenuItem(item); menu.add(menuItem); menuItem.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { if (e.getActionCommand().equals(\u0026#34;创建新目录\u0026#34;)) { String fileName = JOptionPane.showInputDialog(panel, \u0026#34;请输入新目录名：\u0026#34;); if (fileName != null \u0026amp;\u0026amp; !fileName.trim().isEmpty()) { File newFile = new File(currentPath, fileName); if (newFile.exists()) { JOptionPane.showMessageDialog(panel, \u0026#34;该目录已存在！\u0026#34;); } else { if (newFile.mkdir()) { JOptionPane.showMessageDialog(panel, \u0026#34;目录创建成功！\u0026#34;); // 刷新文件列表 ((FileBrowserUI)SwingUtilities.getWindowAncestor(panel)).refreshFileList(); } else { JOptionPane.showMessageDialog(panel, \u0026#34;目录创建失败！\u0026#34;); } } } } else if(e.getActionCommand().equals(\u0026#34;刷新\u0026#34;)) { // 调用FileBrowserUI的刷新方法 ((FileBrowserUI)SwingUtilities.getWindowAncestor(panel)).refreshFileList(); } } }); } menu.show(e.getComponent(),e.getX(),e.getY()); } } @Override public void mousePressed(MouseEvent e) { } @Override public void mouseReleased(MouseEvent e) { } @Override public void mouseEntered(MouseEvent e) { } @Override public void mouseExited(MouseEvent e) { } } WrapLayout.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 import javax.swing.*; import java.awt.*; public class WrapLayout extends FlowLayout { // 添加标志位来追踪布局状态 private Dimension preferredLayoutSize; public WrapLayout() { super(); } public WrapLayout(int align) { super(align); } public WrapLayout(int align, int hgap, int vgap) { super(align, hgap, vgap); } @Override public Dimension preferredLayoutSize(Container target) { return layoutSize(target, true); } @Override public Dimension minimumLayoutSize(Container target) { return layoutSize(target, false); } private Dimension layoutSize(Container target, boolean preferred) { synchronized (target.getTreeLock()) { // 获取容器的目标宽度 Container container = target; while (container.getSize().width == 0 \u0026amp;\u0026amp; container.getParent() != null) { container = container.getParent(); } int targetWidth; if (container instanceof JScrollPane) { targetWidth = ((JScrollPane) container).getViewport().getWidth(); } else { targetWidth = container.getSize().width; } if (targetWidth == 0) { targetWidth = Integer.MAX_VALUE; } int hgap = getHgap(); int vgap = getVgap(); Insets insets = target.getInsets(); int maxWidth = targetWidth - (insets.left + insets.right + hgap * 2); maxWidth = Math.max(maxWidth, 100); // 确保最小宽度 Dimension dim = new Dimension(0, 0); int rowWidth = 0; int rowHeight = 0; int nmembers = target.getComponentCount(); for (int i = 0; i \u0026lt; nmembers; i++) { Component m = target.getComponent(i); if (m.isVisible()) { Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize(); if (rowWidth + d.width \u0026gt; maxWidth) { dim.width = Math.max(dim.width, rowWidth); dim.height += rowHeight + vgap; rowWidth = d.width; rowHeight = d.height; } else { rowWidth += d.width + hgap; rowHeight = Math.max(rowHeight, d.height); } } } dim.width = Math.max(dim.width, rowWidth); dim.height += rowHeight; dim.width += insets.left + insets.right + hgap * 2; dim.height += insets.top + insets.bottom + vgap * 2; // 存储计算的首选大小 preferredLayoutSize = new Dimension(dim); return dim; } } // 示例：如何使用WrapLayout并添加滚动条 public static JScrollPane createScrollableWrapPanel() { // 创建使用WrapLayout的面板 JPanel panel = new JPanel(new WrapLayout()); // 创建滚动面板 JScrollPane scrollPane = new JScrollPane(panel); scrollPane.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED); scrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED); // 设置视口视图的滚动单位 scrollPane.getVerticalScrollBar().setUnitIncrement(16); scrollPane.getHorizontalScrollBar().setUnitIncrement(16); return scrollPane; } } ","date":"2025-07-16T14:33:35+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%95%8C%E9%9D%A2-v2.0/","title":"文件资源管理器界面 v2.0"},{"content":"文件资源管理器界面 v1.0 项目介绍 用Java实现一个类似Windows文件资源管理器的界面程序，支持文件的浏览和基本操作功能。本项目基于Java Swing实现图形界面，展示了面向对象编程的基本思想和事件驱动编程模型。\n功能特性 文件浏览：支持文件和文件夹的层级显示 文件操作： 打开：双击打开文件或文件夹 删除：支持文件和非空文件夹的删除 重命名：支持文件和文件夹的重命名 界面交互： 双击操作：打开文件或进入文件夹 右键菜单：提供常用操作选项 文件图标：区分文件和文件夹的显示 类的设计 类名 继承/实现 主要功能 FileBrowserUI JFrame 创建主界面，管理界面组件 ClickListener MouseListener 处理目录的鼠标事件 OpenFileListener MouseListener 处理文件的鼠标事件 具体实现 界面布局设计 使用Java Swing实现图形界面，采用BorderLayout布局管理器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public class FileBrowserUI extends JFrame { // 设置文件浏览器的根目录路径 static String root = \u0026#34;D:\\\\testFile\u0026#34;; // 建议不要选择C盘作为测试 public FileBrowserUI(String path){ // 界面的基础设置 this.setTitle(\u0026#34;文件浏览器 路径：\u0026#34; + root); this.setLocationRelativeTo(null); // 将窗口设置在屏幕中央 this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); // 当有多个文件浏览器窗口时，使用DISPOSE_ON_CLOSE可以使程序在关闭其中一窗口后不直接结束 this.setSize(800,600); // 设置窗口大小 // 创建顶部地址栏面板 JPanel pathPanel = new JPanel(); JLabel pathJla = new JLabel(\u0026#34;地址：\u0026#34;); JTextField pathJtf = new JTextField(root,35); // 地址输入框，默认显示根目录 JButton pathBtn = new JButton(\u0026#34;跳转\u0026#34;); JTextField searchJtf = new JTextField(\u0026#34;搜索\u0026#34;,20); // 搜索输入框 JButton searchBtn = new JButton(\u0026#34;搜索\u0026#34;); // 将组件添加到地址栏面板 pathPanel.add(pathJla); pathPanel.add(pathJtf); pathPanel.add(pathBtn); pathPanel.add(searchJtf); pathPanel.add(searchBtn); pathPanel.setPreferredSize(new Dimension(0,40)); // 设置地址栏面板高度 // 创建文件显示面板 JPanel filePanel = new JPanel(); filePanel.setLayout(new FlowLayout(FlowLayout.LEFT,15,20)); // 设置文件图标从左到右排列，水平间距15，垂直间距20 // 设置面板背景色 pathPanel.setBackground(Color.LIGHT_GRAY); filePanel.setBackground(Color.WHITE); // 将面板添加到主窗口 this.add(pathPanel,BorderLayout.NORTH); // 地址栏面板放在顶部 this.add(filePanel,BorderLayout.CENTER); // 文件显示面板放在中央 setVisible(true); // 显示窗口 } } 文件的读取与显示 实现文件系统的遍历和显示功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public JComponent[] listFiles(String path){ File rootFile = new File(path); File[] files = rootFile.listFiles(); // 获取路径下所有文件和文件夹 JComponent[] jComponent = new JComponent[files.length]; // 加载文件和文件夹的图标 ImageIcon pic1 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file1.png\u0026#34;))); // 文件夹图标 ImageIcon pic2 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file2.png\u0026#34;))); ImageIcon pic3 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file3.png\u0026#34;))); // 文件图标 // 遍历所有文件和文件夹，创建对应的按钮 for (int i = 0; i \u0026lt; files.length; i++) { File f = files[i]; if(f.isDirectory()) { // 如果是文件夹 JButton btn = new JButton(); btn.setIcon(pic1); // 设置文件夹图标 btn.setText(f.getName()); // 设置文件夹名称 btn.setPreferredSize(new Dimension(90,100)); // 设置按钮大小 btn.setVerticalTextPosition(SwingConstants.BOTTOM); // 文字显示在图标下方 btn.setHorizontalTextPosition(SwingConstants.CENTER); // 文字水平居中 btn.setActionCommand(f.getAbsolutePath()); // 设置按钮点击时的命令为文件的绝对路径 btn.setToolTipText(f.getName()); // 设置鼠标悬停时的提示文字 jComponent[i] = btn; } else { // 如果是文件 JButton btn = new JButton(); btn.setIcon(pic3); // 设置文件图标 btn.setText(f.getName()); // 设置文件名称 btn.setPreferredSize(new Dimension(90,100)); btn.setVerticalTextPosition(SwingConstants.BOTTOM); btn.setHorizontalTextPosition(SwingConstants.CENTER); btn.setActionCommand(f.getAbsolutePath()); btn.setToolTipText(f.getName()); jComponent[i] = btn; } } return jComponent; // 返回所有文件和文件夹的按钮数组 } 目录的监听与处理 实现目录的双击打开和右键菜单功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 实现鼠标监听器接口，处理目录的点击事件 public class ClickListener implements MouseListener { @Override public void mouseClicked(MouseEvent e) { // 双击事件处理：打开文件夹 if(e.getClickCount() == 2){ JButton btn = (JButton) e.getSource(); // 获取触发事件的按钮 String path = btn.getActionCommand(); // 获取按钮对应的文件路径 new FileBrowserUI(path); // 创建新窗口显示该文件夹内容 } // 鼠标右键点击事件处理：显示操作菜单 if(e.getButton() == 3) { JButton btn = (JButton) e.getSource(); String path = btn.getActionCommand(); // 创建右键菜单 JPopupMenu menu = new JPopupMenu(); String[] items = {\u0026#34;打开\u0026#34;,\u0026#34;删除\u0026#34;,\u0026#34;重命名\u0026#34;}; // 定义菜单项 // 遍历添加菜单项 for (String item : items) { JMenuItem menuItem = new JMenuItem(item); menu.add(menuItem); // 为每个菜单项添加点击事件监听器 menuItem.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { // 打开文件夹 if(e.getActionCommand().equals(\u0026#34;打开\u0026#34;)){ new FileBrowserUI(path); } // 删除文件夹 else if(e.getActionCommand().equals(\u0026#34;删除\u0026#34;)){ File directory = new File(path); deleteDirectory(directory); // 调用删除目录的方法（见下文） } // 重命名文件夹 else if(e.getActionCommand().equals(\u0026#34;重命名\u0026#34;)){ String newName = JOptionPane.showInputDialog(null, \u0026#34;请输入新文件名：\u0026#34;); // 弹出输入框获取新名称 File file = new File(path); File newFile = new File(file.getParent() + \u0026#34;/\u0026#34; + newName); // 创建新文件对象 // 执行重命名操作并显示结果 if(file.renameTo(newFile)){ JOptionPane.showMessageDialog(null, \u0026#34;重命名成功！\u0026#34;); } else JOptionPane.showMessageDialog(null, \u0026#34;重命名失败！\u0026#34;); } } }); } // 在鼠标点击位置显示右键菜单 menu.show(e.getComponent(),e.getX(),e.getY()); } } } 特别说明：对于目录文件的删除操作，由于Java的File.delete()方法不能直接删除非空目录，需要实现递归删除：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public static boolean deleteDirectory(File directory) { if (directory.exists()) { File[] files = directory.listFiles(); if (files != null) { for (File file : files) { if (file.isDirectory()) { // 递归删除子目录 deleteDirectory(file); } else { // 删除文件 file.delete(); } } } // 最后删除空目录 JOptionPane.showMessageDialog(null, \u0026#34;删除成功！\u0026#34;); return directory.delete(); } JOptionPane.showMessageDialog(null, \u0026#34;文件不存在！\u0026#34;); return false; } 文件的监听与处理 文件操作的实现采用了简化处理，使用系统默认程序打开文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 // 实现鼠标监听器接口，处理文件的点击事件 public class OpenFileListener implements MouseListener { @Override public void mouseClicked(MouseEvent e) { // 双击打开文件 if (e.getClickCount() == 2) { JButton btn = (JButton) e.getSource(); // 获取触发事件的按钮 String path = btn.getActionCommand(); // 获取文件路径 try { // 调用系统命令使用记事本打开文件 Runtime.getRuntime().exec(\u0026#34;notepad \u0026#34; + path); } catch (IOException ex) { throw new RuntimeException(ex); } } // 鼠标右键点击事件处理：显示操作菜单 if (e.getButton() == 3) { JButton btn = (JButton) e.getSource(); String path = btn.getActionCommand(); // 创建右键菜单 JPopupMenu menu = new JPopupMenu(); String[] items = {\u0026#34;打开\u0026#34;, \u0026#34;删除\u0026#34;, \u0026#34;重命名\u0026#34;}; // 定义菜单项 // 遍历添加菜单项 for (String item : items) { JMenuItem menuItem = new JMenuItem(item); menu.add(menuItem); // 为每个菜单项添加点击事件监听器 menuItem.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { // 打开文件：使用记事本打开 if (e.getActionCommand().equals(\u0026#34;打开\u0026#34;)) { try { Runtime.getRuntime().exec(\u0026#34;notepad \u0026#34; + path); } catch (IOException ex) { throw new RuntimeException(ex); } } // 删除文件 else if (e.getActionCommand().equals(\u0026#34;删除\u0026#34;)) { File file = new File(path); // 检查文件是否存在并执行删除操作 if (file != null) { file.delete(); JOptionPane.showMessageDialog(null, \u0026#34;删除成功！\u0026#34;); } else { JOptionPane.showMessageDialog(null, \u0026#34;文件不存在！\u0026#34;); } } // 重命名文件 else if (e.getActionCommand().equals(\u0026#34;重命名\u0026#34;)) { String newName = JOptionPane.showInputDialog(null, \u0026#34;请输入新文件名：\u0026#34;); // 弹出输入框获取新名称 File file = new File(path); File newFile = new File(file.getParent() + \u0026#34;/\u0026#34; + newName); // 创建新文件对象 // 执行重命名操作并显示结果 if (file.renameTo(newFile)) { JOptionPane.showMessageDialog(null, \u0026#34;重命名成功！\u0026#34;); } else { JOptionPane.showMessageDialog(null, \u0026#34;重命名失败！\u0026#34;); } } } }); } // 在鼠标点击位置显示右键菜单 menu.show(e.getComponent(),e.getX(),e.getY()); } } } 最终效果 待优化功能 文件打开方式：目前仅支持使用记事本打开，后续可扩展为使用系统默认程序 文件操作：可添加复制、剪切、粘贴等功能，重命名功能仍有一些bug，比如文件重名等现象 搜索功能：实现文件搜索功能 文件预览：添加文件预览功能 界面美化：优化界面布局和样式 完整代码 FileBrowserUI.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 import javax.swing.*; import java.awt.*; import java.io.File; import java.util.Objects; public class FileBrowserUI extends JFrame { static String root = \u0026#34;D:\\\\test\u0026#34;; static ClickListener clickListener = new ClickListener(); static OpenFileListener openFileListener = new OpenFileListener(); public FileBrowserUI(String path){ this.setTitle(\u0026#34;文件浏览器 路径：\u0026#34; + root); this.setLocationRelativeTo(null); this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); this.setSize(800,600); JPanel pathPanel = new JPanel(); JLabel pathJla = new JLabel(\u0026#34;地址：\u0026#34;); JTextField pathJtf = new JTextField(root,35); JButton pathBtn = new JButton(\u0026#34;跳转\u0026#34;); JTextField searchJtf = new JTextField(\u0026#34;搜索\u0026#34;,20); JButton searchBtn = new JButton(\u0026#34;搜索\u0026#34;); pathPanel.add(pathJla); pathPanel.add(pathJtf); pathPanel.add(pathBtn); pathPanel.add(searchJtf); pathPanel.add(searchBtn); pathPanel.setPreferredSize(new Dimension(0,40)); JPanel filePanel = new JPanel(); filePanel.setLayout(new FlowLayout(FlowLayout.LEFT,15,20)); JComponent[] jComponents = listFiles(path); for (JComponent jComponent : jComponents) { filePanel.add(jComponent); } pathPanel.setBackground(Color.LIGHT_GRAY); filePanel.setBackground(Color.WHITE); this.add(pathPanel,BorderLayout.NORTH); this.add(filePanel,BorderLayout.CENTER); setVisible(true); } public JComponent[] listFiles(String path){ File rootFile = new File(path); File[] files = rootFile.listFiles(); JComponent[] jComponent = new JComponent[files.length]; ImageIcon pic1 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file1.png\u0026#34;))); ImageIcon pic2 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file2.png\u0026#34;))); ImageIcon pic3 = new ImageIcon(Objects.requireNonNull(FileBrowserUI.class.getResource(\u0026#34;file3.png\u0026#34;))); for (int i = 0; i \u0026lt; files.length; i++) { File f = files[i]; if(f.isDirectory()) { JButton btn = new JButton(); btn.setIcon(pic1); btn.setText(f.getName()); btn.setPreferredSize(new Dimension(90,100)); btn.setVerticalTextPosition(SwingConstants.BOTTOM); btn.setHorizontalTextPosition(SwingConstants.CENTER); btn.setActionCommand(f.getAbsolutePath()); btn.setToolTipText(f.getName()); btn.addMouseListener(clickListener); jComponent[i] = btn; } else { JButton btn = new JButton(); btn.setIcon(pic3); btn.setText(f.getName()); btn.setPreferredSize(new Dimension(90,100)); btn.setVerticalTextPosition(SwingConstants.BOTTOM); btn.setHorizontalTextPosition(SwingConstants.CENTER); btn.setActionCommand(f.getAbsolutePath()); btn.setToolTipText(f.getName()); btn.addMouseListener(openFileListener); jComponent[i] = btn; } } return jComponent; } public static void main(String[] args) { new FileBrowserUI(root); } } ClickListener.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; import java.io.File; public class ClickListener implements MouseListener { @Override public void mouseClicked(MouseEvent e) { if(e.getClickCount() == 2){ JButton btn = (JButton) e.getSource(); String path = btn.getActionCommand(); new FileBrowserUI(path); } if(e.getButton() == 3) { JButton btn = (JButton) e.getSource(); String path = btn.getActionCommand(); JPopupMenu menu = new JPopupMenu(); String[] items = {\u0026#34;打开\u0026#34;,\u0026#34;删除\u0026#34;,\u0026#34;重命名\u0026#34;}; for (String item : items) { JMenuItem menuItem = new JMenuItem(item); menu.add(menuItem); menuItem.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { if(e.getActionCommand().equals(\u0026#34;打开\u0026#34;)){ new FileBrowserUI(path); } else if(e.getActionCommand().equals(\u0026#34;删除\u0026#34;)){ File directory = new File(path); deleteDirectory(directory); } else if(e.getActionCommand().equals(\u0026#34;重命名\u0026#34;)){ String newName = JOptionPane.showInputDialog(null, \u0026#34;请输入新文件名：\u0026#34;); File file = new File(path); File newFile = new File(file.getParent() + \u0026#34;/\u0026#34; + newName); if(file.renameTo(newFile)){ JOptionPane.showMessageDialog(null, \u0026#34;重命名成功！\u0026#34;); } else JOptionPane.showMessageDialog(null, \u0026#34;重命名失败！\u0026#34;); } } }); } menu.show(e.getComponent(),e.getX(),e.getY()); } } @Override public void mousePressed(MouseEvent e) { } @Override public void mouseReleased(MouseEvent e) { } @Override public void mouseEntered(MouseEvent e) { } @Override public void mouseExited(MouseEvent e) { } public static boolean deleteDirectory(File directory) { if (directory.exists()) { File[] files = directory.listFiles(); if (files != null) { for (File file : files) { if (file.isDirectory()) { // 递归删除子目录 deleteDirectory(file); } else { // 删除文件 file.delete(); } } } // 最后删除空目录 JOptionPane.showMessageDialog(null, \u0026#34;删除成功！\u0026#34;); return directory.delete(); } JOptionPane.showMessageDialog(null, \u0026#34;文件不存在！\u0026#34;); return false; } } OpenFileListener.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; import java.io.File; import java.io.IOException; public class OpenFileListener implements MouseListener { @Override public void mouseClicked(MouseEvent e) { if (e.getClickCount() == 2) { JButton btn = (JButton) e.getSource(); String path = btn.getActionCommand(); try { Runtime.getRuntime().exec(\u0026#34;notepad \u0026#34; + path); } catch (IOException ex) { throw new RuntimeException(ex); } } if (e.getButton() == 3) { JButton btn = (JButton) e.getSource(); String path = btn.getActionCommand(); JPopupMenu menu = new JPopupMenu(); String[] items = {\u0026#34;打开\u0026#34;, \u0026#34;删除\u0026#34;, \u0026#34;重命名\u0026#34;}; for (String item : items) { JMenuItem menuItem = new JMenuItem(item); menu.add(menuItem); menuItem.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { if (e.getActionCommand().equals(\u0026#34;打开\u0026#34;)) { try { Runtime.getRuntime().exec(\u0026#34;notepad \u0026#34; + path); } catch (IOException ex) { throw new RuntimeException(ex); } } else if (e.getActionCommand().equals(\u0026#34;删除\u0026#34;)) { File file = new File(path); if (file != null) { file.delete(); JOptionPane.showMessageDialog(null, \u0026#34;删除成功！\u0026#34;); } else { JOptionPane.showMessageDialog(null, \u0026#34;文件不存在！\u0026#34;); } } else if (e.getActionCommand().equals(\u0026#34;重命名\u0026#34;)) { String newName = JOptionPane.showInputDialog(null, \u0026#34;请输入新文件名：\u0026#34;); File file = new File(path); File newFile = new File(file.getParent() + \u0026#34;/\u0026#34; + newName); if (file.renameTo(newFile)) { JOptionPane.showMessageDialog(null, \u0026#34;重命名成功！\u0026#34;); } else { JOptionPane.showMessageDialog(null, \u0026#34;重命名失败！\u0026#34;); } } } }); } menu.show(e.getComponent(),e.getX(),e.getY()); } } @Override public void mousePressed(MouseEvent e) { } @Override public void mouseReleased(MouseEvent e) { } @Override public void mouseEntered(MouseEvent e) { } @Override public void mouseExited(MouseEvent e) { } } ","date":"2025-07-12T22:22:14+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E6%96%87%E4%BB%B6%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%95%8C%E9%9D%A2-v1.0/","title":"文件资源管理器界面 v1.0"},{"content":"前缀和 什么是前缀和？ 对于原数组a[n]\na[1], a[2], a[3], a[4], \u0026hellip;, a[n] 前缀和数组是s[n]为数组的前n项和 s[1] = a[1]\ns[2] = a[1] + a[2] = s[1] + a[2]\ns[3] = a[1] + a[2] + a[3] = s[2] + a[3]\n\u0026hellip;\ns[n] = a[1] + a[2] + a[3] + a[4] + \u0026hellip; + a[n] = s[n-1] + a[n]\n前缀和的作用 快速求出数组的前n项和或者某段区间内的和 例如：a[n]的前十项和即为s[10], a[n]在[10,20]区间内的和为s[20] - s[9] 一维前缀和数组 AcWing 795. 前缀和\n题目描述 输入一个长度为 $n$ 的整数序列。 接下来再输入 $m$ 个询问，每个询问输入一对 $l, r$。 对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。\n输入格式 第一行包含两个整数 $n$ 和 $m$。 第二行包含 $n$ 个整数，表示整数数列。 接下来 $m$ 行，每行包含两个整数 $l$ 和 $r$，表示一个询问的区间范围。\n输出格式 共 $m$ 行，每行输出一个询问的结果。\n数据范围 $1 \\leq l \\leq r \\leq n$， $1 \\leq n, m \\leq 100000$， $-1000 \\leq$ 数列中元素的值 $\\leq 1000$\n输入样例 1 2 3 4 5 5 3 2 1 3 6 4 1 2 1 3 2 4 输出样例 1 2 3 3 6 10 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.util.Scanner; class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int q = in.nextInt(); int[] arr = new int[n+1]; for(int i = 1; i \u0026lt;= n; i++) { arr[i] = in.nextInt(); } int[] s = new int[n+1]; for(int i = 1; i \u0026lt;= n; i++) { // 生成前缀和数组s[n] // 这里用O(n)的时间复杂度生成前缀和数组，是为了方便之后查询所求前缀和(每次查询都为O(1)) s[i] = s[i-1] + arr[i]; } while(q-- \u0026gt; 0) { int l = in.nextInt(); int r = in.nextInt(); System.out.println(s[r] - s[l-1]); } } } 二维前缀和 AcWing 796. 子矩阵的和\n题目描述 输入一个长度为 $n$ 的整数序列。 接下来再输入 $m$ 个询问，每个询问输入一对 $l, r$。 对于每个询问，输出原序列中从第 $l$ 个数到第 $r$ 个数的和。\n输入格式 第一行包含两个整数 $n$ 和 $m$。 第二行包含 $n$ 个整数，表示整数数列。 接下来 $m$ 行，每行包含两个整数 $l$ 和 $r$，表示一个询问的区间范围。\n输出格式 共 $m$ 行，每行输出一个询问的结果。\n数据范围 $1 \\leq l \\leq r \\leq n$， $1 \\leq n, m \\leq 100000$， $-1000 \\leq$ 数列中元素的值 $\\leq 1000$\n输入样例 1 2 3 4 5 5 3 2 1 3 6 4 1 2 1 3 2 4 输出样例 1 2 3 3 6 10 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import java.util.Scanner; class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int m = in.nextInt(); int q = in.nextInt(); int[][] arr = new int[n+1][m+1]; for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= m; j++) { arr[i][j] = in.nextInt(); } } // 生成前缀和矩阵s int[][] s = new int[n+1][m+1]; for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= m; j++) { // 二维前缀和矩阵公式 s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + arr[i][j]; } } while(q-- \u0026gt; 0) { int x1 = in.nextInt(); int y1 = in.nextInt(); int x2 = in.nextInt(); int y2 = in.nextInt(); // 通过前缀和矩阵求得区间和，时间复杂度为O(1) int sum = s[x2][y2] - s[x2][y1-1] - s[x1-1][y2] + s[x1-1][y1-1]; System.out.println(sum); } } } 差分 什么是差分？ 差分数组是原数组的前缀和数组的逆运算，即原数组的差分数组是原数组的前缀和数组。\n一维差分数组 AcWing 797. 差分\n题目描述 输入一个长度为 $n$ 的整数序列。 接下来输入 $m$ 个操作，每个操作包含三个整数 $l, r, c$，表示将序列中 $[l, r]$ 之间的每个数加上 $c$。 请输出进行完所有操作后的序列。\n输入格式 第一行包含两个整数 $n$ 和 $m$。 第二行包含 $n$ 个整数，表示整数序列。 接下来 $m$ 行，每行包含三个整数 $l, r, c$，表示一个操作。\n输出格式 共一行，包含 $n$ 个整数，表示最终序列。\n数据范围 $1 \\leq n, m \\leq 100000$， $1 \\leq l \\leq r \\leq n$， $-1000 \\leq c \\leq 1000$， $-1000 \\leq$ 整数序列中元素的值 $\\leq 1000$\n输入样例 1 2 3 4 5 6 3 1 2 2 1 2 1 1 3 1 3 5 1 1 6 1 输出样例 1 3 4 5 3 4 2 参考代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // 算法逻辑：对于传入的原数组arr[], 先定义一个数组b[]作为arr的差分数组，因此，只需在差分数组上进行操作（例如需要将区间[l,r]上的元素全部加c，则只需在差分数组中的l位置添加c，r+1位置减c即可）, 再将b本身还原成其自己的前缀和数组即可 import java.util.Scanner; class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int q = in.nextInt(); int[] arr = new int[n+1]; for(int i = 1; i \u0026lt;= n; i++) { arr[i] = in.nextInt(); } int[] b = new int[n+2]; for(int i = 1; i \u0026lt;= n; i++) { b[i] = arr[i] - arr[i-1]; } while(q-- \u0026gt; 0) { int l = in.nextInt(); int r = in.nextInt(); int c = in.nextInt(); b[l] += c; b[r+1] -= c; } for(int i = 1; i \u0026lt;= n; i++) { b[i] = b[i-1] + b[i]; } for(int i = 1; i \u0026lt;= n; i++) { System.out.print(b[i] + \u0026#34; \u0026#34;); } } } 二维差分数组 AcWing 798. 二维矩阵\n题目描述 输入一个 $n$ 行 $m$ 列的整数矩阵，再输入 $q$ 个操作，每个操作包含五个整数 $x_1, y_1, x_2, y_2, c$，其中 $(x_1, y_1)$ 和 $(x_2, y_2)$ 表示一个子矩阵的左上角坐标和右下角坐标，每个操作都要将选中的子矩阵中的每个元素的值加上 $c$ 。请将进行完所有操作后的矩阵输出。\n输入格式 第一行包含整数 $n, m, q$ 。 接下来 $n$ 行，每行包含 $m$ 个整数，表示整数矩阵。 接下来 $q$ 行，每行包含 5 个整数 $x_1, y_1, x_2, y_2, c$，表示一个操作。\n输出格式 共 $n$ 行，每行 $m$ 个整数，表示所有操作进行完毕后的最终矩阵。\n数据范围 $1 \\leq n, m \\leq 1000$， $1 \\leq q \\leq 100000$， $1 \\leq x_1 \\leq x_2 \\leq n$， $1 \\leq y_1 \\leq y_2 \\leq m$， $-1000 \\leq c \\leq 1000$， $-1000 \\leq$ 矩阵内元素的值 $\\leq 1000$\n输入样例 1 2 3 4 5 6 7 3 4 3 1 2 2 1 3 2 2 1 1 1 1 1 1 1 2 2 1 1 3 2 3 2 3 1 3 4 1 输出样例 1 2 3 2 3 4 1 4 3 4 1 2 2 2 2 参考代码、\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.util.Scanner; class Main { public static void main(String[] args) { Scanner in = new Scanner(System.in); int n = in.nextInt(); int m = in.nextInt(); int q = in.nextInt(); int[][] a = new int[n+2][m+2]; for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= m; j++) { a[i][j] = in.nextInt(); } } int[][] b = new int[n+2][m+2]; for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j\u0026lt;= m; j++) { // 生成差分矩阵b // 注意此处差分矩阵的计算方式 b[i][j] += a[i][j]; b[i+1][j] -= a[i][j]; b[i][j+1] -= a[i][j]; b[i+1][j+1] += a[i][j]; } } while(q-- \u0026gt; 0) { int x1 = in.nextInt(); int y1 = in.nextInt(); int x2 = in.nextInt(); int y2 = in.nextInt(); int c = in.nextInt(); // 在差分矩阵中进行加减操作，直接查找，时间复杂度为O(1) // 注意此处的计算方式 b[x1][y1] += c; b[x2+1][y1] -= c; b[x1][y2+1] -= c; b[x2+1][y2+1] += c; } // 最后将b矩阵还原成其本身的前缀和矩阵，即为最终结果 // b[i][j]表示[1,1]到[i,j]围成的矩形内元素的和 for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= m; j++) { b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]; } } for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= m; j++) { System.out.print(b[i][j] + \u0026#34; \u0026#34;); } System.out.println(\u0026#34;\u0026#34;); } } } ","date":"2025-07-01T10:15:02+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BA%8C/","title":"第一章基础算法（二）"},{"content":"快速排序 确定分界点 调整区间 递归处理左右两段 快排模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public void quickSort(int[] arr, int left, int right) { if (left \u0026gt;= right) { return; } // 选择枢轴（这里使用最左边的元素） int pivot = arr[left]; int i = left - 1; int j = right + 1; while (i \u0026lt; j) { // 从左向右找第一个大于等于pivot的元素 do { i++; } while (arr[i] \u0026lt; pivot); // 从右向左找第一个小于等于pivot的元素 do { j--; } while (arr[j] \u0026gt; pivot); // 如果i和j没有交叉，则交换它们指向的元素 if (i \u0026lt; j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } // 递归排序左右两部分 quickSort(arr, left, j); quickSort(arr, j + 1, right); } } 归并排序 确定分界点：mid = (l + r) / 2 递归排序（左和右） 归并（合二为一） 归并模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public void merge_sort(int[] q, int l, int r) { if (l \u0026gt;= r) { return; } int mid = (l + r) / 2; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0; int i = l, j = mid + 1; int[] temp = new int[r - l + 1]; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) { if (q[i] \u0026lt;= q[j]) { temp[k++] = q[i++]; } else { temp[k++] = q[j++]; } } while (i \u0026lt;= mid) { temp[k++] = q[i++]; } while (j \u0026lt;= r) { temp[k++] = q[j++]; } for (i = l, j = 0; i \u0026lt;= r; i++, j++) { q[i] = temp[j]; } } } 整数二分 整数二分模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 模板1：区间[l, r]被划分成[l, mid]和[mid+1, r]时使用 class Solution { public int bSearch_1(int l, int r) { while (l \u0026lt; r) { // 这里利用位运算求中间值，等价于 (l + r) / 2 ，当下面是r = mid时，不需要+1防止溢出 int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) { r = mid; } else { l = mid + 1; } } return l; } } // 模板2：区间[l, r]被划分成[l, mid-1]和[mid, r]时使用 class Solution { public int bSearch_2(int l, int r) { while (l \u0026lt; r) { // 这里利用位运算求中间值，当下面是l = mid时，采用 (l + r + 1) / 2 的计算方式 int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) { l = mid; } else { r = mid - 1; } } return l; } } ","date":"2025-06-29T15:13:16+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%B8%80/","title":"第一章基础算法（一）"},{"content":"GUI押题 Direction: Creat a GUI as shown in following figure. Draw a circle at the center of the window, and add 4 buttons (Up, Down, Left, Right) to move the circle in the corresponding direction, and add 3 buttons to control the color of the circle.\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 import java.awt.BorderLayout; import java.awt.Color; import java.awt.FlowLayout; import java.awt.Graphics; import javax.swing.ButtonGroup; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.JRadioButton; // GUI主窗口类，继承自JFrame public class GUI extends JFrame { // 显示UI界面的方法 void showUI() { setTitle(\u0026#34;Test GUI\u0026#34;); // 设置窗口标题 setSize(800,600); // 设置窗口大小 setLayout(new BorderLayout()); // 设置布局管理器 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 关闭窗口时退出程序 MyCanvas canvas = new MyCanvas(); // 创建自定义画布 add(canvas, BorderLayout.CENTER); // 将画布添加到窗口中央 // 创建方向按钮 JButton up = new JButton(\u0026#34;Up\u0026#34;); JButton down = new JButton(\u0026#34;Down\u0026#34;); JButton left = new JButton(\u0026#34;Left\u0026#34;); JButton right = new JButton(\u0026#34;Right\u0026#34;); // 创建颜色单选按钮 JRadioButton red = new JRadioButton(\u0026#34;Red\u0026#34;); JRadioButton green = new JRadioButton(\u0026#34;Green\u0026#34;); JRadioButton blue = new JRadioButton(\u0026#34;Blue\u0026#34;); ButtonGroup group = new ButtonGroup(); // 单选按钮分组 group.add(red); group.add(green); group.add(blue); // 右移按钮事件 right.addActionListener(e -\u0026gt; { canvas.setX(20); // x坐标加20 repaint(); // 重绘界面 }); // 左移按钮事件 left.addActionListener(e -\u0026gt; { canvas.setX(-20); // x坐标减20 repaint(); }); // 上移按钮事件 up.addActionListener(e -\u0026gt; { canvas.setY(-20); // y坐标减20 repaint(); }); // 下移按钮事件 down.addActionListener(e -\u0026gt; { canvas.setY(20); // y坐标加20 repaint(); }); // 红色按钮事件 red.addActionListener(e -\u0026gt; { canvas.setColor(Color.RED); // 设置颜色为红色 repaint(); }); // 绿色按钮事件 green.addActionListener(e -\u0026gt; { canvas.setColor(Color.GREEN); // 设置颜色为绿色 repaint(); }); // 蓝色按钮事件 blue.addActionListener(e -\u0026gt; { canvas.setColor(Color.BLUE); // 设置颜色为蓝色 repaint(); }); // 方向按钮面板 JPanel MoveButtonPanel = new JPanel(); MoveButtonPanel.setLayout(new FlowLayout()); MoveButtonPanel.add(up); MoveButtonPanel.add(down); MoveButtonPanel.add(left); MoveButtonPanel.add(right); // 颜色按钮面板 JPanel ColorButtonPanel = new JPanel(); ColorButtonPanel.setLayout(new FlowLayout()); ColorButtonPanel.add(red); ColorButtonPanel.add(green); ColorButtonPanel.add(blue); // 总按钮面板 JPanel ButtonPanel = new JPanel(); ButtonPanel.setLayout(new BorderLayout()); ButtonPanel.add(MoveButtonPanel, BorderLayout.NORTH); ButtonPanel.add(ColorButtonPanel, BorderLayout.SOUTH); add(ButtonPanel, BorderLayout.SOUTH); // 添加按钮面板到底部 setVisible(true); // 显示窗口 } // 主方法，程序入口 public static void main(String[] args) { GUI ui = new GUI(); ui.showUI(); } } // 自定义画布类，继承自JPanel class MyCanvas extends JPanel { private int x = 0; // 圆的x坐标 private int y = 0; // 圆的y坐标 private Color color = Color.BLACK; // 圆的颜色，默认黑色 @Override protected void paintComponent(Graphics g) { super.paintComponent(g); g.translate(400,300); // 坐标原点移到画布中心 g.setColor(color); // 设置画笔颜色 g.fillOval(x, y, 20, 20); // 绘制圆形 } // 设置x坐标的增量 void setX(int dx) { this.x += dx; } // 设置y坐标的增量 void setY(int dy) { this.y += dy; } // 设置圆的颜色 void setColor(Color c) { this.color = c; } } ","date":"2025-06-19T20:35:04+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A04/","title":"程序设计与算法语言期末复习4"},{"content":"易错 Python版块 不要在if判断语句中用 / 判断两数是否相等\nPython中的无穷大量和无穷小量：\n1 2 a = float(\u0026#39;Inf\u0026#39;) b = float(\u0026#39;-Inf\u0026#39;) 初始化一个二维数组（矩阵） 1 2 ls = [[0]*3 for i in range(3)] print(ls) 或\n1 2 3 4 5 6 7 ls = [] for i in range(3): row = [] for j in range(3): row.append(0) ls.append(row) print(ls) 或\n1 2 3 n = 3 ls = [[0]*n] * n print(ls) 冒泡排序和选择排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 冒泡排序 def bubble_sort(s): for i in range(len(s) - 1): # 注意要-1 for j in range(len(s) - i - 1): if s[j] \u0026gt; s[j + 1]: s[j], s[j + 1] = s[j + 1], s[j] return s a = [0, 4, 12, 10, 7, 3, 9, 1, 5, 6] print(bubble_sort(a)) # 选择排序 def selection_sort(a): for i in range(len(a) - 1): min_index = i for j in range(i + 1, len(a)): if a[j] \u0026lt; a[min_index]: min_index = j if min_index != i: a[i], a[min_index] = a[min_index], a[i] return a a = [0, 4, 12, 10, 7, 3, 9, 1, 5, 6] print(selection_sort(a)) ord() 和 chr() ord: str -\u0026gt; ASCII 1 ord(\u0026#39;a\u0026#39;) == 97 chr: ASCII -\u0026gt; str 1 chr(ord(\u0026#39;a\u0026#39;) + 1) == \u0026#39;b\u0026#39; 凯撒密码： 1 new_char = chr((ord(char) - ord(\u0026#39;A\u0026#39;) + shift) % 26 + ord(\u0026#39;A\u0026#39;)) # 大写字母 sort()方法 1 s.sort() # 而非sort(s)！！！ 斐波那契数列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 1 1 2 3 5 8 ... # 第一轮输出 a b # 第二轮输出 a b # 对应第一轮中参数 b a+b # 迭代算法 def fibo(n): ls = [] a,b = 0,1 for i in range(n): a,b = b,a+b ls.append(a) return ls print(fibo(10)) # 递归算法 def Fibo(n): if n==0: return 0 elif n==1: return 1 else: return Fibo(n-1)+Fibo(n-2) for i in range(1,11): print(Fibo(i)) 输入 将输入的字符串分隔存入数组中（\u0026lsquo;abcde\u0026rsquo; -\u0026gt; [\u0026lsquo;a\u0026rsquo;,\u0026lsquo;b\u0026rsquo;,\u0026lsquo;c\u0026rsquo;,\u0026rsquo;d\u0026rsquo;,\u0026rsquo;e\u0026rsquo;]） 1 2 3 a = input() ls = list(a) print(ls) 将输入的一段文本按空格分隔存入数组（\u0026ldquo;Hello world, how are you?\u0026rdquo; -\u0026gt; [\u0026lsquo;Hello\u0026rsquo;,\u0026lsquo;world\u0026rsquo;,\u0026ldquo;how\u0026rsquo;,\u0026lsquo;are\u0026rsquo;,\u0026lsquo;you\u0026rsquo;]） 1 2 text = input() print(text.split()) # split()方法默认按空格分隔，传入参数\u0026#39;,\u0026#39;也可指定按逗号分隔 输入一组数字用逗号相隔，存入数组且数组中的数字时int类型而不是str 1 2 3 a = input().split(\u0026#39;,\u0026#39;) a = [int(num) for num in a] print(a) 输出 左对齐右对齐居中 1 2 3 print(\u0026#39;{:\u0026gt;10}\u0026#39;.format(\u0026#39;hello\u0026#39;)) # hello print(\u0026#39;{:\u0026lt;10}\u0026#39;.format(\u0026#39;hello\u0026#39;)) # hello print(\u0026#39;{:^10}\u0026#39;.format(\u0026#39;hello\u0026#39;)) # hello 填充 1 2 print(\u0026#39;{:*\u0026gt;10}\u0026#39;.format(\u0026#39;hello\u0026#39;)) # *****hello print(\u0026#39;{:*^10}\u0026#39;.format(\u0026#39;hello\u0026#39;)) # **hello*** 数字处理 1 2 print(\u0026#34;{:,}\u0026#34;.format(1234567)) # 1,234,567 print(\u0026#34;{:.2f}\u0026#34;.format(3.1415926)) # 3.14 函数递归（汉诺塔） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def Hanoi(n, A, B, C): # 当只有一个盘子时，直接将盘子从A移动到C if n == 1: print(\u0026#39;Move {} from {} to {}\u0026#39;.format(n, A, C)) else: # 步骤1：将上面的n-1个盘子从A借助C移动到B Hanoi(n-1, A, C, B) # 步骤2：将第n个盘子从A移动到C print(\u0026#39;Move {} from {} to {}\u0026#39;.format(n, A, C)) # 步骤3：将n-1个盘子从B借助A移动到C Hanoi(n-1, B, A, C) # 获取用户输入的盘子数量 n = int(input(\u0026#39;Please enter n here: \u0026#39;)) # 调用函数解决汉诺塔问题 Hanoi(n, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;) join()函数 join() 是字符串对象的一个方法，用于将可迭代对象（如列表、元组、集合等）中的元素连接成一个字符串 1 2 3 words = [\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;, \u0026#34;!\u0026#34;] result = \u0026#34; \u0026#34;.join(words) # 使用空格作为分隔符 print(result) # 输出：Hello World ! 大小写转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def swapLowerUpper(s): res = list(s) for i in range(len(s)): if \u0026#39;a\u0026#39; \u0026lt;= s[i] \u0026lt;= \u0026#39;z\u0026#39;: res[i] = chr(ord(s[i])-32) return \u0026#39;\u0026#39;.join(res) def swapUpperLower(s): res = list(s) for i in range(len(s)): if \u0026#39;A\u0026#39; \u0026lt;= s[i] \u0026lt;= \u0026#39;Z\u0026#39;: res[i] = chr(ord(s[i])+32) return \u0026#39;\u0026#39;.join(res) a = input() print(swapLowerUpper(a)) print(swapUpperLower(a)) 注意: python中字符串支持形如s[0]的索引，但是无法进行复制（如s[0] = \u0026lsquo;a\u0026rsquo;），因此要先把字符串转换成列表形式进行操作。另外一种方法是创建一个result = [] 的列表用于存储结果，然后for char in s依次对s中每个字符进行操作并用result.append(char)进行存储，最后也需要return ''.join(result)将列表转换成字符串返回\nJava版块 格式化输出 printf输出 1 2 double num = 1.000; System.out.printf(\u0026#34;A number %.2f\u0026#34;, a); String.format输出 1 2 double num = 1.000; System.out.println(String.format(\u0026#34;A number %.2f\u0026#34;, a)); formatted输出 1 2 double num = 1.000; System.out.println(\u0026#34;A number %.2f\u0026#34;.formatted(a)); 注：时间的格式化输出String.format(\u0026quot;%02d:%02d:%02d\u0026quot;,hour,minute,second)\n输入（应该不考） 1 2 3 System.out.println(\u0026#34;Enter a number here: \u0026#34;); Scanner in = new Scanner(System.in); String s = in.nextLine(); // 读取输入的字符串 字符串切片 与Python不同，Java中字符串的切片不支持像列表一样用[0,5]这样操作 substring() 1 2 3 4 5 6 7 8 9 10 String original = \u0026#34;Hello, World!\u0026#34;; // 从索引6开始截取到字符串末尾 String sub1 = original.substring(6); // \u0026#34;World!\u0026#34; // 截取索引2（包含）到索引5（不包含）之间的字符 String sub2 = original.substring(2, 5); // \u0026#34;llo\u0026#34; System.out.println(sub1); System.out.println(sub2); StringBuilder与charAt() 1 2 3 4 5 6 7 8 String original = \u0026#34;Java Programming\u0026#34;; StringBuilder sb = new StringBuilder(); // 提取前4个字符 for (int i = 0; i \u0026lt; 4; i++) { sb.append(original.charAt(i)); } String sub = sb.toString(); // \u0026#34;Java\u0026#34; System.out.println(sub); 三元表达式 在 Java 中，三元表达式（Ternary Operator）是一种简洁的条件判断语句，也称为条件运算符。 基本语法： 1 条件表达式 ? 值1 : 值2 执行逻辑 计算条件表达式（结果必须为boolean类型） 如果条件为true，返回值1 如果条件为false，返回值2 实例：在求最大公约数（GCD）时的循环语句 1 2 3 4 5 6 for(int i = a\u0026gt;b ? a:b; i\u0026gt;0 ; i--){ if(a%i==0 \u0026amp;\u0026amp; b%i==0){ GCD_val = i; break; } } 等效于 1 2 3 4 5 6 for(int i=Math.min(a,b); i\u0026gt;=0; i--) { if(a%i==0 \u0026amp;\u0026amp; b%i==0){ GCD_val = i; break; } } 大小写转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 创建Scanner对象用于从标准输入读取用户输入 Scanner in = new Scanner(System.in); // 提示用户输入文本 System.out.println(\u0026#34;Input a text here: \u0026#34;); // 读取用户输入的整行文本 String text = in.nextLine(); // 创建StringBuilder对象，用于高效构建结果字符串 StringBuilder swappedText = new StringBuilder(); // 遍历输入文本的每个字符 for(int i = 0; i \u0026lt; text.length(); i++) { // 获取当前位置的字符 char ch = text.charAt(i); // 判断是否为大写字母 if(ch \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;Z\u0026#39;) { // 将大写字母转换为小写字母 // 在ch + (\u0026#39;a\u0026#39; - \u0026#39;A\u0026#39;)后，由于加入运算，会自动转为int类型，因此需要(char)进行强制类型转换 swappedText.append((char)(ch + (\u0026#39;a\u0026#39; - \u0026#39;A\u0026#39;))); } // 判断是否为小写字母 else if(ch \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;z\u0026#39;) { // 将小写字母转换为大写字母 swappedText.append((char)(ch - (\u0026#39;a\u0026#39; - \u0026#39;A\u0026#39;))); } // 非字母字符保持不变 else { swappedText.append(ch); } } // 输出转换后的文本 System.out.println(\u0026#34;The swapped text is: \u0026#34; + swappedText); Java中的无穷大量和无穷小量： 1 2 double a = Double.POSITIVE_INFINITY; double b = Double.NEGATIVE_INFINITY; 本部分内容（除特别声明外）采用 署名 - 非商业性使用 - 保持一致 4.0 国际 (CC BY-NC-SA 4.0) 许可协议进行许可。\n","date":"2025-06-12T11:10:39+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A03/","title":"程序设计与算法语言期末复习3"},{"content":"面向对象（OOP） Python面向对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Employee: # __init__构造函数 def __init__(self, name, salary): self.name = name self.salary = salary # 定义函数时要传入self参数 def getName(self): return self.name def getSalary(self): return self.salary # 定义比较函数，将name作为比较对象 def __lt__(self, other): return self.name \u0026lt; other.name # __repr__对应java中的toString()，用于返回对象表示形式（打印一个对象会默认返回其地址） def __repr__(self): return \u0026#39;An employee {} whose salary is {}.\u0026#39;.format(self.name,self.salary) 在主函数中使用sort函数排序：\n1 2 3 4 5 6 7 8 9 10 hanmei = Employee(\u0026#39;Han Mei\u0026#39;, 10000) lilei = Employee(\u0026#39;Li Lei\u0026#39;, 8000) tom = Employee(\u0026#39;Tom\u0026#39;, 50) staff = [hanmei, lilei, tom] # 默认按照Employee中__lt__方法，按名字排序 staff.sort() # 也可使用Lambda表达式，自定义排序方式 staff.sort(key = lambda c:c.salary) # 默认升序 staff.sort(key = lambda c:c.salary, reverse = True) #reverse = True 降序 print(staff) Java面向对象 OOP基本概念 接入接口进行排序操作 HW13参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 // Q1 import java.util.Arrays; import java.util.BitSet; import java.util.Comparator; public class hujue20243143024_Q1 { public static void main(String[] args) { Athlete[] ath = new Athlete[3]; ath[0] = new Athlete(\u0026#34;Alice\u0026#34;, 170, 50, 10000); ath[1] = new Athlete(\u0026#34;Bob\u0026#34;, 185, 70, 10001); ath[2] = new Athlete(\u0026#34;Ferdinand\u0026#34;, 190, 80, 15000); // Name ascending using default Comparable Arrays.sort(ath); System.out.println(\u0026#34;Name ascending using default Comparable\u0026#34;); for(Athlete a : ath) { System.out.println(a); } System.out.println(\u0026#34;\u0026#34;); // Name ascending using Comparator Arrays.sort(ath, new CompareAthleteNameAsc()); System.out.println(\u0026#34;Name ascending using Comparator\u0026#34;); for(Athlete a : ath) { System.out.println(a); } System.out.println(\u0026#34;\u0026#34;); // Name descending using Comparator Arrays.sort(ath, new CompareAthleteNameDes()); System.out.println(\u0026#34;Name descending using Comparator\u0026#34;); for(Athlete a : ath) { System.out.println(a); } System.out.println(\u0026#34;\u0026#34;); // Height descending using Lambda Expression Arrays.sort(ath, (o1,o2) -\u0026gt; o2.getHeight()-o1.getHeight()); System.out.println(\u0026#34;Height descending using Lambda Expression\u0026#34;); for(Athlete a : ath) { System.out.println(a); } System.out.println(\u0026#34;\u0026#34;); // Salary descending using Lambda Expression Arrays.sort(ath, (o1,o2) -\u0026gt; Double.compare(o2.getSalary(), o1.getSalary())); System.out.println(\u0026#34;Salary descending using Lambda Expression\u0026#34;); for(Athlete a : ath) { System.out.println(a); } System.out.println(\u0026#34;\u0026#34;); BasketballPlayer[] bas = new BasketballPlayer[3]; bas[0] = new BasketballPlayer(\u0026#34;Alice\u0026#34;, 170, 50, 10000,5,3.6); bas[1] = new BasketballPlayer(\u0026#34;Bob\u0026#34;, 185, 70, 10001,7,10.5); bas[2] = new BasketballPlayer(\u0026#34;Ferdinand\u0026#34;, 190, 80, 15000,9,7.4); // ShootLv ascending using Comparable Arrays.sort(bas); System.out.println(\u0026#34;ShootLv ascending using Comparable\u0026#34;); for(BasketballPlayer b: bas) { System.out.println(b); } System.out.println(\u0026#34;\u0026#34;); // ShootLv descending using Comparator Arrays.sort(bas,new CompareBasketballPlayerShootLvDes()); System.out.println(\u0026#34;ShootLv descending using Comparable\u0026#34;); for(BasketballPlayer b: bas) { System.out.println(b); } System.out.println(\u0026#34;\u0026#34;); // Weight descending using Lambda Expression Arrays.sort(bas,(o1,o2) -\u0026gt; o2.getWeight()-o1.getWeight()); System.out.println(\u0026#34;Weight descending using Lambda Expression\u0026#34;); for(BasketballPlayer b: bas) { System.out.println(b); } System.out.println(\u0026#34;\u0026#34;); // Salary ascending using Lambda Expression Arrays.sort(bas,(o1,o2) -\u0026gt; Double.compare(o1.getSalary(),o2.getSalary())); System.out.println(\u0026#34;Salary ascending using Lambda Expression\u0026#34;); for(BasketballPlayer b: bas) { System.out.println(b); } System.out.println(\u0026#34;\u0026#34;); } } class Athlete implements Comparable\u0026lt;Athlete\u0026gt; { private String name; private int height; private int weight; private double salary; public Athlete (String name, int height, int weight, double salary) { this.name = name; this.height = height; this.weight = weight; this.salary = salary; } public String getName() { return name; } public int getHeight() { return height; } public int getWeight() { return weight; } public double getSalary() { return salary; } @Override public String toString() { return String.format(\u0026#34;An Athlete %s with height of %d and weight of %d\u0026#34;, getName(),getHeight(),getWeight()); } @Override public int compareTo(Athlete o) { return name.compareTo(o.name); } } class BasketballPlayer extends Athlete { private int shootLv; private double ticketprofit; public BasketballPlayer(String name, int height, int weight, double salary, int shootLv, double ticketprofit) { super(name, height, weight, salary); this.shootLv = shootLv; this.ticketprofit = ticketprofit; } public int getShootLv() { return shootLv; } public double getTicketprofit() { return ticketprofit; } @Override public String toString() { return String.format(\u0026#34;An basketball player %s with shooting level %d\u0026#34;, getName(),getShootLv()); } public int compareTo(Athlete o) { BasketballPlayer b = (BasketballPlayer)o; return shootLv - b.shootLv; } } class CompareAthleteNameAsc implements Comparator\u0026lt;Athlete\u0026gt; { public int compare(Athlete o1, Athlete o2) { return o1.getName().compareTo(o2.getName()); } } class CompareAthleteNameDes implements Comparator\u0026lt;Athlete\u0026gt; { public int compare(Athlete o1, Athlete o2) { return o2.getName().compareTo(o1.getName()); } } class CompareBasketballPlayerShootLvDes implements Comparator\u0026lt;BasketballPlayer\u0026gt; { public int compare(BasketballPlayer o1, BasketballPlayer o2) { return o2.getShootLv()-o1.getShootLv(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 # Q2 class Athlete: def __init__(self, name, height, weight, salary): self.name = name self.height = height self.weight = weight self.salary = salary def __repr__(self): return \u0026#34;An Athlete {} with height of {} and weight of {}\u0026#34;.format(self.name,self.height,self.weight) def __lt__(self,other): return self.height - other.height class BasketballPlayer(Athlete): def __init__(self, name, height, weight, salary, shootLv, ticketprofit): super().__init__(name,height,weight,salary) self.shootLv = shootLv self.ticketprofit = ticketprofit def __repr__(self): return \u0026#34;An basketball player {} with shooting level of {} \u0026#34;.format(self.name, self.shootLv) def __lt__(self,other): return self.shootLv - other.shootLv a1 = Athlete(\u0026#34;Alice\u0026#34;, 170, 50, 10000) a2 = Athlete(\u0026#34;Bob\u0026#34;, 185, 70, 10001) a3 = Athlete(\u0026#34;Ferdinand\u0026#34;, 190, 80, 15000) athlete = [a1,a2,a3] # height ascending using __lt__ athlete.sort for i in athlete: print(i) # salary descending using Lambda Expression athlete.sort(key = lambda x:x.salary, reverse = True) for i in athlete: print(i) b1 = BasketballPlayer(\u0026#34;Alice\u0026#34;, 170, 50, 10000,5,3.6) b2 = BasketballPlayer(\u0026#34;Bob\u0026#34;, 185, 70, 10001,7,10.5) b3 = BasketballPlayer(\u0026#34;Ferdinand\u0026#34;, 190, 80, 15000,9,7.4) basketballplayer = [b1,b2,b3] # shooting level ascending using __lt__ basketballplayer.sort for i in basketballplayer: print(i) # Salary descending using Lambda Expression basketballplayer.sort(key = lambda x:x.salary, reverse = True) for i in basketballplayer: print(i) 需要掌握的Python标准库和Java外部库的使用 Python math库 导入\n1 import math 基本数学函数\nmath.sqrt(x)：计算平方根，如 math.sqrt(16) → 4.0 math.pow(x, y)：计算 x 的 y 次幂，如 math.pow(2, 3) → 8.0 math.exp(x)：计算 e 的 x 次幂，如 math.exp(1) → 2.71828... math.log(x, base)：计算对数，默认以 e 为底，如 math.log(100, 10) → 2.0 三角函数\nmath.sin(x)：正弦值（弧度） math.cos(x)：余弦值（弧度） math.radians(deg)：角度转弧度，如 math.radians(180) → 3.1415... math.degrees(rad)：弧度转角度，如 math.degrees(math.pi) → 180.0 特殊常量\nmath.pi：π（3.14159\u0026hellip;） math.e：自然常数 e（2.71828\u0026hellip;） math.inf：正无穷大（float(\u0026lsquo;inf\u0026rsquo;)） math.nan：非数值（float(\u0026rsquo;nan\u0026rsquo;)） random库 导入\n1 2 3 4 5 import random # 或 import random as r # 或 from random import * # 导入内部所有功能，后续可以直接使用 基础随机数生成\nrandom.random()：生成 [0.0, 1.0) 范围内的随机浮点数 random.uniform(a, b)：生成 [a, b] 范围内的随机浮点数 random.randint(a, b)：生成 [a, b] 范围内的随机整数（包括 a 和 b） 序列操作\nrandom.choice(seq)：从序列（如列表、元组）中随机选择一个元素 random.choices(seq, weights=None, k=1)：有放回地随机选择 k 个元素，可设置权重 random.sample(seq, k)：无放回地随机选择 k 个元素，不重复 random.shuffle(seq)：原地打乱序列的顺序（仅适用于可变序列，如列表） Java LocalDate 获取当前日期\n1 LocalDate rightDate = LocalDate.now(); 定义一个LocalDate类型的日期\n1 LocalDate newDate = LocalDate.of(2025, 6, 12); 获取日期的年月日\n1 2 3 4 System.out.println(newDate.getYear()); // 2025 System.out.println(newDate.getMonthValue()); // 6 System.out.println(newDate.getDayOfMonth()); // 13 System.out.println(newDate.getDayOfWeek()); // Thursday 输出日期，默认格式为 yyyy-mm-dd\n1 System.out.println(newDate); // 2025-06-12 JFrame 窗口初始化\n1 2 3 4 5 6 setTitle(\u0026#34;Swing Components\u0026#34;); setSize(300, 300); setLocationRelativeTo(null); // 窗体居中显示 setDefaultCloseOperation(EXIT_ON_CLOSE); setLayout(new FlowLayout()); // 流式布局管理 setVisible(true); // 可视化，一般放最后 添加组件\n1 add(btn1) 按钮 JButton\n1 JButton btn = new JButton(\u0026#34;Click me!\u0026#34;); JCheckBox\n1 2 JCheckBox bold = new JCheckBox(\u0026#34;Bold\u0026#34;); JCheckBox italic = new JCheckBox(\u0026#34;Italic\u0026#34;); 添加监听器后，JCheckBox选中判断\n1 if (bold.isSelected()) JRadioButton\n1 2 3 4 5 6 7 8 9 10 JRadioButton rbe = new JRadioButton(\u0026#34;Excellent\u0026#34;); JRadioButton rbg = new JRadioButton(\u0026#34;Good\u0026#34;); JRadioButton rbf = new JRadioButton(\u0026#34;Fair\u0026#34;); JRadioButton rbp = new JRadioButton(\u0026#34;Poor\u0026#34;); // 注意，要将按钮加入一个按钮组中来生效RadioButton的单选功能 ButtonGroup bg = new ButtonGroup(); bg.add(rbe); bg.add(rbg); bg.add(rbf); bg.add(rbp); 下拉表 JComboBox 1 2 3 4 5 6 7 JComboBox\u0026lt;String\u0026gt; faceCombo = new JComboBox\u0026lt;\u0026gt;(); faceCombo.addItem(\u0026#34;Serif\u0026#34;); faceCombo.addItem(\u0026#34;SansSerif\u0026#34;); faceCombo.addItem(\u0026#34;Monospaced\u0026#34;); faceCombo.addItem(\u0026#34;DialogInput\u0026#34;); JPanel comboPanel = new JPanel(); comboPanel.add(faceCombo); 文字框 JLabel 1 2 3 JLabel label = new JLabel(\u0026#34;The quick brown fox jumps over the lazy dog.\u0026#34;); label.setFont(new Font(fontStyle, mode, size)); // 设置字体样式 label.setForeground(Color.BLUE); // 设置字体颜色 监听器 ActionListener 1 2 3 4 5 6 7 btnNums[i].addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String num = e.getActionCommand(); display.setText(display.getText()+num); } }); 可用Lambda表达式简化代码 1 2 3 4 btnNums[i].addActionListener(e -\u0026gt; { String num = e.getActionCommand(); display.setText(display.getText()+num); }); HW16 参考代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 import java.awt.BorderLayout; import java.awt.Color; import java.awt.Font; import java.awt.Graphics; import javax.swing.ButtonGroup; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JRadioButton; class GUIFrame extends JFrame { Color color = Color.BLACK; int size = 30; int mode = 0; String fontStyle = \u0026#34;Serif\u0026#34;; Boolean isBold = false; Boolean isItalic = false; public void showUI() { setTitle(\u0026#34;Swing Components\u0026#34;); setSize(600,300); setLocationRelativeTo(null); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setLayout(new BorderLayout()); MyCanvas canvas = new MyCanvas(); add(canvas); JLabel label = new JLabel(\u0026#34;The quick brown fox jumps over the lazy dog.\u0026#34;); JComboBox\u0026lt;String\u0026gt; faceCombo = new JComboBox\u0026lt;\u0026gt;(); faceCombo.addItem(\u0026#34;Serif\u0026#34;); faceCombo.addItem(\u0026#34;SansSerif\u0026#34;); faceCombo.addItem(\u0026#34;Monospaced\u0026#34;); faceCombo.addItem(\u0026#34;DialogInput\u0026#34;); JPanel comboPanel = new JPanel(); comboPanel.add(faceCombo); JButton red = new JButton(\u0026#34;Red\u0026#34;); JButton green = new JButton(\u0026#34;Green\u0026#34;); JButton blue = new JButton(\u0026#34;Blue\u0026#34;); JCheckBox btn3 = new JCheckBox(\u0026#34;Bold\u0026#34;); JCheckBox btn4 = new JCheckBox(\u0026#34;Italic\u0026#34;); JRadioButton btn5 = new JRadioButton(\u0026#34;Samll\u0026#34;); JRadioButton btn6 = new JRadioButton(\u0026#34;Medium\u0026#34;); JRadioButton btn7 = new JRadioButton(\u0026#34;Large\u0026#34;); JRadioButton btn8 = new JRadioButton(\u0026#34;Exta large\u0026#34;); ButtonGroup group = new ButtonGroup(); group.add(btn5); group.add(btn6); group.add(btn7); group.add(btn8); JPanel sizeButtoPanel = new JPanel(); JPanel styleButtoPanel = new JPanel(); JPanel colorButtonPanel = new JPanel(); JPanel temPanel = new JPanel(); temPanel.setLayout(new BorderLayout()); sizeButtoPanel.add(btn5); sizeButtoPanel.add(btn6); sizeButtoPanel.add(btn7); sizeButtoPanel.add(btn8); styleButtoPanel.add(btn3); styleButtoPanel.add(btn4); colorButtonPanel.add(red); colorButtonPanel.add(green); colorButtonPanel.add(blue); temPanel.add(label, BorderLayout.NORTH); temPanel.add(comboPanel, BorderLayout.CENTER); temPanel.add(sizeButtoPanel, BorderLayout.SOUTH); add(temPanel, BorderLayout.NORTH); add(styleButtoPanel, BorderLayout.CENTER); add(colorButtonPanel, BorderLayout.SOUTH); faceCombo.addActionListener(e -\u0026gt; { fontStyle = (String)faceCombo.getSelectedItem(); label.setFont(new Font(fontStyle, mode, size)); }); red.addActionListener(e -\u0026gt; { label.setForeground(Color.RED); repaint(); }); green.addActionListener(e -\u0026gt; { label.setForeground(Color.GREEN); repaint(); }); blue.addActionListener(e -\u0026gt; { label.setForeground(Color.BLUE); repaint(); }); btn3.addActionListener(e -\u0026gt; { mode = Font.PLAIN; if (btn3.isSelected()) { mode += Font.BOLD; } if (btn4.isSelected()) { mode += Font.ITALIC; } label.setFont(new Font(fontStyle, mode, size)); repaint(); }); btn4.addActionListener(e -\u0026gt; { mode = Font.PLAIN; if (btn3.isSelected()) { mode += Font.BOLD; } if (btn4.isSelected()) { mode += Font.ITALIC; } label.setFont(new Font(fontStyle, mode, size)); repaint(); }); btn5.addActionListener(e -\u0026gt; { size = 20; label.setFont(new Font(fontStyle, mode, size)); repaint(); }); btn6.addActionListener(e -\u0026gt; { size = 30; label.setFont(new Font(fontStyle, mode, size)); repaint(); }); btn7.addActionListener(e -\u0026gt; { size = 40; label.setFont(new Font(fontStyle, mode, size)); repaint(); }); btn8.addActionListener(e -\u0026gt; { size = 50; label.setFont(new Font(fontStyle, mode, size)); repaint(); }); setVisible(true); } } class MyCanvas extends JPanel { @Override protected void paintComponent(Graphics g) { super.paintComponent(g); } } public class hujue20243143024_Q1 { public static void main(String[] args) { GUIFrame ui = new GUIFrame(); ui.showUI(); } } 本部分内容（除特别声明外）采用 署名 - 非商业性使用 - 保持一致 4.0 国际 (CC BY-NC-SA 4.0) 许可协议进行许可。\n","date":"2025-06-12T08:10:39+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A02/","title":"程序设计与算法语言期末复习2"},{"content":"Python版块 重点语法 1. 变量 Python在定义变量时无需声明变量类型，但在变量名选取时，需注意变量名不能以数字开头且不能包含空格，也不能用Python内的关键字作为变量名。\n2. 字符串 转义字符串\n字符串可参与数字运算和循环\n1 2 3 \u0026gt;\u0026gt;\u0026gt; text = \u0026#34;hello\u0026#34; \u0026gt;\u0026gt;\u0026gt; a * 3 \u0026#39;hellohellohello\u0026#39; 字符串索引\n可用a[n]形式选取字符串中的第n+1位 a[-1]代表最后一位 相关函数\n字符串长度：len(\u0026quot;hello world\u0026quot;)（也可用于计算列表长度） 数据类型转换：str(100)返回'100' 字符串转Unicode：ord('a')返回97 Unicode转字符串：chr(97)返回'a' replace：s.replace(old,new) 数据清洗函数strip：s.strip() 输出数据类型：str.format() 3. 数字 类型：整型（int），浮点型（float） 运算：+ - * / // % **\n注意：不建议在if语句中用浮点型数字进行比较，会有精度误差导致判断错误 相关函数 求绝对值：abs(x) 求幂：pow(x,y) 求最大值和最小值：max(x1,x2,...); min(x1,x2,...) 类型转换：int(float(4,1)) 4. 判断语句 基本结构： 1 2 3 4 5 6 if \u0026lt;Cond1\u0026gt;: \u0026lt;Statement1\u0026gt; elif \u0026lt;Cond2\u0026gt;: \u0026lt;Statement2\u0026gt; else: \u0026lt;StatementN\u0026gt; 条件判断连接词：and，or\n（注意不是\u0026amp;\u0026amp;和||） 5. 循环语句 while循环：内部要加上自增语句（count+=1）\nfor循环两种形式：\n1 2 for i in \u0026lt;字符串或列表\u0026gt;: Statements 1 2 3 4 5 for i in range(10): # i 从 0 到 9 Statements for i in range(10，20): # i 从 10 到 19 Statements break与continue\n在 Python 中，break 和 continue 是两个用于控制循环流程的关键字。它们可以帮助你在特定条件下提前结束循环或跳过当前迭代。\nbreak 语句\n立即终止当前所在的循环（for 或 while）\n跳出循环后，程序将继续执行循环后的代码\n示例\n1 2 3 4 5 6 7 8 9 # 找到第一个偶数后立即终止循环 numbers = [1, 3, 5, 8, 9, 10] for num in numbers: if num % 2 == 0: print(f\u0026#34;找到偶数:{num}\u0026#34;) break # 终止循环 print(f\u0026#34;当前数字:{num}\u0026#34;) print(\u0026#34;循环结束\u0026#34;) 输出：\n1 2 3 4 5 当前数字: 1 当前数字: 3 当前数字: 5 找到偶数: 8 循环结束 continue 语句\n立即跳过当前循环的剩余代码\n直接进入下一次循环迭代\n示例\n1 2 3 4 5 6 7 8 # 只打印奇数，跳过偶数 numbers = [1, 2, 3, 4, 5, 6] for num in numbers: if num % 2 == 0: continue # 跳过偶数 print(f\u0026#34;奇数: {num}\u0026#34;) print(\u0026#34;循环结束\u0026#34;) 输出：\n1 2 3 4 奇数: 1 奇数: 3 奇数: 5 循环结束 嵌套循环中的应用 break 和 continue 只影响当前所在的最内层循环：\n1 2 3 4 5 6 for i in range(3): print(f\u0026#34;外层循环 {i}:\u0026#34;) for j in range(3): if j == 1: break # 只跳出内层循环 print(f\u0026#34; 内层循环 {j}\u0026#34;) 输出：\n1 2 3 4 5 6 外层循环 0: 内层循环 0 外层循环 1: 内层循环 0 外层循环 2: 内层循环 0 总结：break结束本层循环，continue结束本次循环\n6. 函数 结构 1 2 3 def 函数名(传入的参数): \u0026lt;函数体\u0026gt; return 返回值 函数递归 经典问题：汉诺塔 7. 元组 Tuple 特点：\n括号内用逗号相隔 内部元素可以是字符串、数字、列表\u0026hellip; Immutable 元素不可改变，不可被重新复制（但是内部元素如果是列表，列表中的元素可以被重新赋值） 例如：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; T = (1, 2, 3, [4, 5]) \u0026gt;\u0026gt;\u0026gt; T[-1][0] = 0 (1, 2, 3, [0, 5]) 8. 列表 List 列表的初始化：\n1 L = [] 特点：\nMutable 可以自由添加、删除、更改元素 相关运算： 相关函数： 9. 集合 Set 特点： 无序 {1，2，3} 和 {2, 3, 1} 是同一个集合 无重复 无索引或切片操作 无法用 s1[0] 来访问元素 Hashable 意味着查找速度极快（时间复杂度O（1）） 运算：\n10. 字典 特点：以 \u0026ldquo;键-值\u0026quot;对 构成数据 相关函数： 注意： for key in dic.keys():字典默认遍历的就是其键（keys），因此也可以简化为for key in dic:\n11. 文件处理 文件读取 1 2 3 4 with open(\u0026#34;test.txt\u0026#34;,\u0026#34;rt\u0026#34;) as fo: # 文件输出 for line in fo: print(line) 文件写入 1 2 3 4 5 # 覆写写入 with open(\u0026#34;test.txt\u0026#34;,\u0026#34;w\u0026#34;) as fo: for line in fo: fo.write(\u0026#39;Hello, World!\\n\u0026#39;) fo.write(\u0026#39;This is a new line.\\n\u0026#39;) 1 2 3 4 # 追加写入 with open(\u0026#34;test.txt\u0026#34;,\u0026#34;a\u0026#34;) as fo: for line in fo: fo.write(\u0026#39;Appended line.\\n\u0026#39;) 12. try-except语句 基本语法 1 2 3 4 5 6 try: # 可能会抛出异常的代码块 result = 10 / 0 # 例如：除零错误 except ZeroDivisionError: # 当捕获到特定异常时执行的代码 print(\u0026#34;错误：不能除以零！\u0026#34;) 报错类型： SyntaxError：语法错误时触发 ZeroDivisionError：除数为零时触发 TypeError：操作或函数应用于不兼容类型的对象时触发 ValueError：操作或函数接收到类型正确但值无效的参数时触发 IndexError：使用超出序列范围的索引时触发 KeyError：尝试访问字典中不存在的键时触发 NameError：尝试访问未定义的变量时触发 本部分内容（除特别声明外）采用 署名 - 非商业性使用 - 保持一致 4.0 国际 (CC BY-NC-SA 4.0) 许可协议进行许可。\n","date":"2025-06-11T15:10:39+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AF%AD%E8%A8%80%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A01/","title":"程序设计与算法语言期末复习1"},{"content":"ToDoList 6.14 CET-6 准备近代史和军事理论期末考 留意交流项目申请通知 特别感谢学长提供的通识课题库 TAT，不然古建筑机考绝对寄。\n没有一点时间准备人工智能概论考试。需要复习的体量和课程本身的学分完全不匹配（1学分）。其实也很不理解学校为什么要开设这种完全考察学生记忆力的通识课，感觉有点本末倒置了。。。\n抽空了解一下学校通识课选课的相关信息。\n今天是高考第二天。回忆了以下高中发生的各种事以及当时自己对大学的憧憬，其实现在会发现很多事情都跟预想中的很不一样。过去会认为大学是一片极为自由的学术殿堂，当下苦命学习的一些自己其实不喜欢的科目都是为了能在未来更上层楼来触及到自己真正感兴趣且肯钻研的领域。但是，就目前而言，我发现大学其实已经和高中趋于同质化了。同质并没有体现在大学生的专业选择上，而其实源自于对自己的身份认知上。大家似乎还沉浸在过去12年的学生身份中无法自拔，将绩效主义功利主义作为核心的评判标准。“绩点为王”的差异化考核思想深入人心，迫使自己产生强大的“自驱力”来适应如此的竞争环境，殊不知所谓的“自驱力”已经不再来源与“自”而是来源于“绩点”了。\n大家甚至没能有一点喘息的机会，就被要求早早的确定下来自己的规划路线。这样的大学生活确实不是我想要的，至少也不是过去的我想要的。这学期初在选通识课时向学长求助，了解到《中国古建筑欣赏与设计》这门课为网络通识课，考核也相对简单，很容易拿到高分，于是高高兴兴的选上了这门课，殊不知从此刻开始选课的目的也不再单纯，眼中全是对高分的渴望，再无对兴趣的执守了（乐）。也就是这一周要考试了（那时候还没有搞到题库但是课程视频都刷完了），才在网上搜这门课有关的期末考试，然而偶然间看到一篇关于这门课的帖子，说的是在古建筑的保护问题这一章时，听到讲古建筑拆除那一块特别难受。其实我在听那节课的时候也深有感触。梁思成先生当年极力阻止北京古城墙的拆除，然而最终还是无果，贯穿多少代古人的艺术审美和艺术结晶就毁于一旦（好像扯远了）。其实我认为这才是通识课设计的真正意义所在，然而像是这样在网络上有关对这门课内容的讨论又有多少呢？现状是搜索“超星学习通《中国古建筑欣赏与设计》”第一个跳出来的不是章节习题答案就是题库解析，实在悲哀。\n刚刚鹰角发了高考应援曲，也属于是企业文化了。去年刚考完第一件事就是戴上耳机翻着应援曲的评论，与各地的高考生共享这来之不易且短暂的欢乐时光。但是不得不说今年的应援曲比去年的好听，塞壬唱片还是太有品了 Grow on My Way\n—— \u0026lsquo;Cause it\u0026rsquo;s all my past that makes me who I am\u0026rsquo;\n","date":"2025-06-08T18:31:42+08:00","permalink":"https://ferdinandhu.netlify.app/p/23%E5%91%A8-%E5%91%A8%E8%AE%B0/","title":"23周 周记"},{"content":"ToDoList 准备6.7三门水课考试 6.14 CET-6 NUS暑期项目材料准备 比较奇妙的一周。EAP的期末考试pre被抽到周一上午，同时下午又是解析几何考试，就是一整个手忙脚乱但是自我感觉考得还不错（）\n在学校国际部通知里翻到一个1月份发布的暑期交流项目，自认为相比去莱大，NUS的项目更有性价比而且与自身契合度更高（其实是下学期不想晨签罢）\n英语课结束意味着下周开始基本就没有什么课了，希望这样可以让我有充分的时间准备那些水课考试还有CET-6\n可以开始了解下学期的主要课程及任务\n","date":"2025-06-01T00:00:00Z","permalink":"https://ferdinandhu.netlify.app/p/22%E5%91%A8-%E5%91%A8%E8%AE%B0/","title":"22周 周记"},{"content":"编码类型 1. Base64 定义：一种基于64个可打印字符来表示二进制数据的表示方法 特点： 将二进制数据转换为ASCII字符串 常用于在HTTP协议中传输二进制数据 编码后的数据比原始数据大约增加33% 应用场景： 邮件传输 图片转码 简单的数据加密 示例： 1 2 3 4 5 原始文本：Hello World Base64编码：SGVsbG8gV29ybGQ= 原始文本：你好，世界 Base64编码：5L2g5aW977yM5LiW55WM 2. URL编码 定义：将URL中的特殊字符转换为%加上ASCII码的十六进制形式 特点： 保证URL中只包含ASCII字符 可逆的编码方式 应用场景： URL参数传递 网页表单提交 示例： 1 2 原始URL：https://example.com/path with spaces/file.txt URL编码：https%3A%2F%2Fexample.com%2Fpath%20with%20spaces%2Ffile.txt 3. Code49 定义：一种高密度条形码编码方式，可以编码全部128个ASCII字符 特点： 支持多行编码 每行最多8个字符 包含校验和 支持双向扫描 应用场景： 物流管理 库存控制 工业自动化 医疗设备标识 4. Code39 定义：一种字母数字条形码编码方式，可以编码43个字符（0-9, A-Z, -, ., $, /, +, %, SPACE） 特点： 自校验能力 双向可读 支持字母和数字 起始和结束必须有星号(*) 应用场景： 工业应用 物流管理 库存控制 文档管理 编码规则： 每个字符由9个元素组成（5个条和4个空） 3个元素是宽的，6个元素是窄的 字符间需要间隔 起始和结束必须有星号(*) 加密算法 1. 对称加密 1.1 AES (Advanced Encryption Standard) 特点： 密钥长度：128/192/256位 加密强度高 计算速度快 应用场景： 文件加密 通信加密 数据库加密 1.2 DES (Data Encryption Standard) 特点： 密钥长度：56位 分组长度：64位 已被AES替代 应用场景： 传统系统兼容 低安全性要求的场景 2. 非对称加密 2.1 RSA 特点： 基于大数分解难题 公钥加密，私钥解密 计算速度较慢 应用场景： 数字签名 密钥交换 证书加密 2.2 ECC (椭圆曲线加密) 特点： 密钥长度短 安全性高 计算速度快 应用场景： 移动设备加密 物联网设备 数字证书 3. 哈希算法 3.1 MD5 特点： 输出128位哈希值 已被证明不安全 计算速度快 应用场景： 文件完整性校验 密码存储（不推荐） 3.2 SHA系列 特点： SHA-1：160位输出 SHA-256：256位输出 SHA-512：512位输出 应用场景： 数字签名 密码存储 文件校验 使用Java实现Base64编码与解码 导入java自带的Base64类 1 2 import java.nio.charset.StandardCharsets; import java.util.Base64; 编码 1 2 3 4 5 6 7 8 9 10 11 // 编码 public static String encode(String str) { // 非空字符串才进行编码 if (str != null \u0026amp;\u0026amp; str.length() \u0026gt; 0) { // String 转 byte[] byte[] bytes = str.getBytes(StandardCharsets.UTF_8); // 编码（base64字符串） return Base64.getEncoder().encodeToString(bytes); } return \u0026#34;\u0026#34;; } 解码 1 2 3 4 5 6 7 8 9 10 11 //解码 public static String decode(String base64Str) { // 非空字符串才进行解码 if (base64Str != null \u0026amp;\u0026amp; base64Str.length() \u0026gt; 0) { // 编码 byte[] base64Bytes = Base64.getDecoder().decode(base64Str); // byte[] 转 String（解码后的字符串） return new String(base64Bytes, StandardCharsets.UTF_8); } return \u0026#34;\u0026#34;; } 测试代码 1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) { // 定义一个字符串 String s = \u0026#34;FerdinandHu\u0026#34;; // 使用方法二将字符串进行base64编码 String base64Str = encode(s); // 输出原始字符串 System.out.println(\u0026#34;原文：\u0026#34; + s); // 输出base64编码后的字符串 System.out.println(\u0026#34;base64编码后：\u0026#34; + base64Str); // 使用方法二将base64编码后的字符串进行解码 System.out.println(\u0026#34;base64解码后：\u0026#34; + decode(base64Str)); } 输出内容 1 2 3 原文：FerdinandHu base64编码后：RmVyZGluYW5kSHU= base64解码后：FerdinandHu ","date":"2025-05-30T11:28:52+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E4%B8%8E%E7%BC%96%E7%A0%81%E7%B1%BB%E5%9E%8B/","title":"常用加密算法与编码类型"},{"content":"Java File 类： 基础操作： 创建文件对象\n1 File file = new File(\u0026#34;blog.md\u0026#34;); // 只是代表一个文件路径的引用，并没有真正在系统中创建这个文件 使用相对路径创建文件对象并在系统中创建文件： 1 2 3 4 File f = new File(\u0026#34;test.txt\u0026#34;); f.creatNewFile(); // 在系统中创建test.txt文件，Java默认创建在项目文件夹的根目录 System.out.println(f.exists()); System.out.println(f.getAbsolutePath()); 可以得到：\n1 2 true C:\\Users\\HJ000\\IdeaProjects\\Pro-25\\test.txt 使用绝对路径创建文件对象并在系统中创建文件： 1 2 3 4 File f = new File(\u0026#34;C:\\\\Users\\\\HJ000\\\\IdeaProjects\\\\Pro-25\\\\test2.txt\u0026#34;); f.createNewFile(); System.out.println(f.exists()); System.out.println(f.getAbsolutePath()); 可以得到：\n1 2 true C:\\Users\\HJ000\\IdeaProjects\\Pro-25\\test2.txt 另外，可以通过 ../ 格式返回上一级目录并访问\n1 2 3 4 File f = new File(\u0026#34;../test.txt\u0026#34;); f.creatNewFile(); // 放回上一级目录并创建test.txt文件 System.out.println(f.exists()); System.out.println(f.getAbsolutePath()); 创建目录对象\n1 File dir = new File(\u0026#34;newDirectory\u0026#34;); 创建单层目录 1 dir.mkdir(); 创建多层目录 1 dir.mkdirs(); 清除操作\n1 2 file.delete(); // 删除文件 dir.delete(); // 删除空目录 文件属性查询 基本属性： 1 2 3 4 5 6 7 file.exists(); // 判断文件是否存在 file.isFile(); // 判断是否为文件 file.isDirectory(); // 判断是否为目录 file.length(); // 获取文件大小（字节） file.getName(); // 获取文件名 file.getPath(); // 获取相对路径 file.getAbsolutePath(); // 获取绝对路径 相关权限 1 2 3 4 5 6 file.canRead(); // 是否可读 file.canWrite(); // 是否可写 file.canExecute(); // 是否可执行 file.setReadable(true); // 设置可读权限 file.setWritable(true); // 设置可写权限 file.setExecutable(true); // 设置可执行权限 ","date":"2025-05-23T00:00:00Z","permalink":"https://ferdinandhu.netlify.app/p/java-file%E7%B1%BB%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E4%B8%8E%E7%AE%A1%E7%90%86/","title":"Java-File类文件操作与管理"},{"content":"作为本人第一篇周记，主要来分享一下从大一前的暑假到目前为止的个人总结\n学习进展 数学 本人数学专业，学校是中外合办，因此课程设置与其他学校不同，大一只上完了概论与Analytical Geometry，按部就班按照学校进度来学习，曾尝试自学数学分析，一个月后放弃 按照官网的教程学习了Matlab的基础语法，为后续数模比赛做准备 CS 大一上学期尝试自学爬虫，从zlibrary下了本崔庆才老师的 《Python3网络爬虫开发实战》 啃，貌似只学到requests，Beautiful Soup库的使用，后放弃是因为看到知乎上看到这些知识只供爬取一些无反爬的网站，而目前大部分网站为了保证网站的安全都会设置严格的反爬措施，因此需要更加高级的技巧来应对（晕） 学校进度超快。目前已经把Python和Java一些基本的语法和OOP的内容上完了，可能在期末前还要讲一部分C++ \u0026hellip; 高中阶段有一定的编程基础，所以目前看来不至于学得很吃力 用国科半导体所账户白嫖了一年的Cursor使用，开通账户12h后Cursor官方关闭了此注册渠道 目前正在自学数据结构，打算系统地学完一遍后再刷Leetcode（不是我懒） 在0 HTML 基础，0前端基础情况下搭建了第一个自己的技术博客（骄傲），后面也会着重聊聊这方面并分享一下我的心得 其他 当家教 旅游（港澳） 四级625，但是马上六级只有1个月不到了要凉凉 博客搭建分享 博客网站的搭建是一系列机缘巧合下的结果，中途曾几度想过放弃但是很庆幸自己还是坚持下来了，目前博客内容也逐渐丰富并且也使用了各种方法来辅助博客的搭建。 静态网页生成器 简单来说就是将你想体现在博客中的内容转换成HTML语言来呈现在网页中，这里我使用的是Hugo静态网页生成器。目前主流的还有Hexo等 Hugo中所有的博客内容支持用markdown语句编写，在public文件夹中会存储转化后的HTML语言。 Git GitHub 为每个注册用户提供一个专有的以(用户名).github.io格式的默认网址。因此可以将博客的相关内容上传到Github仓库中，并通过默认域名来访问自己的博客。具体操作可以参考左-岚大大的视频，里面给出了非常详细的博客搭建的全流程。 当然你也可以更改自己的网址，这里我推荐使用Netlify的网站服务平台来更改自己的域名 Hugo有非常明确的文件管理系统。在Terminal中可以输入指令Hugo new 文件夹地址/文件名.md来创建markdown格式的博客文件。同时可以执行Hugo server指令在本地查看网页的构建情况。确认无误后将Hugo文件夹作为本地仓库执行git指令将文件上传到Github远程仓库中 工具推荐 Cursor 虽然好像与这部分无关，但是我还是很想介绍一下这款非常强力的AI代码编辑器。除了常规的代码补全功能，Cursor还可以根据用户的自然语言描述进行代码生成。可以将Cursor看作像是VSCode一样的代码编辑器，内部的代码补全生成功能是直接体现在代码区域的，无需再有复制粘贴等操作 Obisidian 目前我其实正在用Obsidian编写当前的博客。Obsidian是一款开源且可操作性极强的一款笔记软件，完美支持MarkDown语法，并且有丰富的插件生态\n之前我是在VSCode中编写并且发布博客的，但是在VSCode中无法实时预览编写的内容，Obsidian完美的解决了这一痛点并且还增加了双链等丰富的功能辅助写作，极大提高了写作效率\n前段时间在知乎上看到一篇讲的是为什么程序员原意在GitHub上开源自己的成功给别人免费使用和学习，我觉得和搭建博客网站的想法如出一辙。有兴趣的话可以看看click here\n","date":"2025-05-22T00:00:00Z","permalink":"https://ferdinandhu.netlify.app/p/21%E5%91%A8-%E5%91%A8%E8%AE%B0/","title":"21周 周记"},{"content":"线性表 [例] 多项式表示\n方法一：顺序存储结构直接表示 下标i：指数 a[i]：对于项的系数 分析：对于形如 $x+3x^{2000}$ 的多项式，会造成存储和运算的浪费\n方法二：顺序存储结构表示非零项 下标 i （按指数大小有序排列） 系数 $a^i$ 指数 i 看作是一个($a_i$,i)的二元组集合\n可后续进行两个多项式的加法过程\n方法三：链表结构存储非零项\n1 2 3 4 5 6 typedef struct PolNode *Polynomial; struct PolyNode { int coef; int expon; Polynomial link; } 线性表(Linear List) 组成：数据元素 \u0026amp; 有序序列 操作集： List MakeEmpty(): 初始化一个空线性表L ElementType FindKth( int K, List L): 根据位序K，返回相应元素 int Find( ElementType X, List L): 在L中查找元素X第一次出现的位置 void Insert( ElementType X, int i, List L): 在位序i前插入一个新元素X void Delete( int i, List L): 清除指定位置的元素 int Length( List L): 返回L的长度n 顺序存储实现：利用数组 主要操作：\n","date":"2025-05-20T10:19:05+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84/","title":"线性结构"},{"content":"两个重要接口 Comparable Interface Comparator Interface Comparable Interface 对于Arrays.sort()函数，需要待排序的数组有排序标准\n对于下面Java代码\n1 2 3 4 5 6 7 Person[] persons = new Person[3]; persons[0] = new Person(\u0026#34;Han Mei\u0026#34;); persons[1] = new Person(\u0026#34;Li Lei\u0026#34;); persons[2] = new Person(\u0026#34;Tom\u0026#34;); Arrays.sort(persons); for (Person p : persons) System.out.println(p); 会有\n1 Person cannot be cast to java.lang.Comparable 报错信息，因此需要传入排序标准\nComparable接口原理：\n1 2 3 public interface Comparable { int compareTo(Object other); } 通过返回int类型的值来判断this与other的大小关系\nint \u0026lt; 0, if this \u0026lt; other\nint = 0, if this = other\nint \u0026gt; 0, if this \u0026gt; other\n具体实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Person implements Comparable{ private String name; public Person(String name) { this.name = name; } public String toString() { return \u0026#34;A person \u0026#34; + name; } // 对接口中的抽象函数进行复写 public int compareTo(Object o) { Person p = (Person)o; return name.compareTo(p.name); } } public static void main(String[] args) { Person[] persons = new Person[3]; persons[0] = new Person(\u0026#34;Han Mei\u0026#34;); persons[1] = new Person(\u0026#34;Li Lei\u0026#34;); persons[2] = new Person(\u0026#34;Tom\u0026#34;); // 使用sort函数进行排序 Arrays.sort(persons); for (Person p : persons) System.out.println(p); } 对于从父类继承来的子类对象，也可以继承其接口功能\n如果需要改变排序标准，可以重写其抽象方法\nComparator Interface Comparator接口原理\n1 2 3 4 public interface Comparator\u0026lt;T\u0026gt; { int compare(T first, T second); } 具体实现\n1 2 3 4 5 6 // 创建一个临时的类，其中补全Comparator的抽象方法 class CompareStuMajorAsc implements Comparator\u0026lt;Student\u0026gt; { public int compare(Student p1, Student p2) { return p1.getName().compareTo(p2.getName()); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 Student[] stus = new Student[3]; stus[0] = new Student(\u0026#34;Han Mei\u0026#34;, \u0026#34;E-Commerce\u0026#34;); stus[1] = new Student(\u0026#34;Li Lei\u0026#34;, \u0026#34;Bioinfomatics\u0026#34;); stus[2] = new Student(\u0026#34;Tom\u0026#34;, \u0026#34;Computer Science\u0026#34;); // Student类继承Person的接口，默认按照name排序 Arrays.sort(stus); for (Student p : stus) System.out.println(p); // new CompareStuNameAsc() 传入新排序标准，按major名称排序 Arrays.sort(stus, new CompareStuMajorAsc()); for (Student p : stus) System.out.println(p); 若需要改成降序排列，只需要改动临时类中return的代码\n1 2 3 4 5 class CompareStuNameDes implements Comparator\u0026lt;Student\u0026gt; { public int compare(Student p1, Student p2) { return p2.getName().compareTo(p1.getName()); // 将p2移前 } } 代码简化 v1 使用内部类，即将原先的单独的临时类放到主函数中\n1 2 3 4 5 6 7 8 9 10 // 简化前 class CompareIntDes implements Comparator\u0026lt;Integer\u0026gt; { public int compare(Integer i, Integer j) { return j - i; } } Integer[] intArr = new Integer[] {3, 1, 2}; Arrays.sort(intArr, new CompareIntDes()); for (int i : intArr) System.out.println(i); 1 2 3 4 5 6 7 8 9 // 简化后 Integer[] intArr = new Integer[] {3, 1, 2}; Arrays.sort(intArr, new Comparator\u0026lt;Integer\u0026gt;() { // 将临时类放在sort函数中 public int compare(Integer i, Integer j) { return j - i; } }); for (int i : intArr) System.out.println(i); 代码简化 v2 使用Lambda表达式简化代码量\n1 2 3 4 5 6 7 // 简化前 // 使用内部类 Arrays.sort(stus, new Comparator\u0026lt;Student\u0026gt;() { public int compare(Student s1, Student s2) { return s2.getMajor().compareTo(s1.getMajor()); } }); 1 2 // 简化后 Arrays.sort(stus, (s1,s2) -\u0026gt; s2.getMajor().compareTo(s1.getMajor())); 可用一行函数完成\n注意： 使用Lambda表达式可以看作没有使用任何一个接口，其中的.compareTo()方法是String类中自带的方法\n","date":"2025-05-19T21:05:05+08:00","permalink":"https://ferdinandhu.netlify.app/p/interface/","title":"Interface"},{"content":"二、算法基础 循环不变式性质：\n初始化 保持 终止 输入规模\n运行时间 c\n一些基础算法\n插入排序算法\n归并排序算法（分治法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 MERGE(A, p, q, r) { n1 = q - p + 1 x2 = r - q for i = 1 to n1 L[i] = A[p+i-1] for j = 1 to n2 R[j] = A[q+j] L[n1 + 1] = \u0026#34;Inf\u0026#34; R[n2 + 1] = \u0026#34;-Inf\u0026#34; i = 1 j = 1 for k = p to r if L[i] \u0026lt;= R[j] A[k] = L[i] i++ else A[k] = R[j] j++ } 分治算法时间复杂度：T(n) = 2T(n/2) + θ(n)\n当其中的 θ(n) = cn 时，可改写为 T(n) = 2T(n/2) + cn\nT(n) = θ(nlgn) 底数为2\n三、函数的增长 $\\theta(g(n))$ 有上界和下界 $O(g(n))$ 提供渐进上界 $\\Omega(g(n))$ 提供渐进下界 定理： 对于任意两个函数f(n)和g(n)，我们有 f(n) = θ(g(n))，当且仅当 f(n) = O(g(n)) 且 f(n) = Ω(g(n)) 四、分治策略 分治策略中递归步骤：\n分解 解决 合并 [例1]：股票收益最大化问题\n暴力求解 \u0026ndash; 时间复杂度 O($n^2$) 分治策略求解 \u0026ndash;\u0026gt; 求解和最大的非空连续子数组\n步骤： 将子数组分为两个尽可能相等的子数组，令中央位置为 mid 则待求的和最大子数组必然存在于： 完全位于mid左侧子数组中 完全位于mid右侧子数组中 穿越mid 最后分别求解各分类中得到和最大的子数组并相互比较，得到三者中和最最大的一个即为结果。求解其时间复杂度为 O(nlgn) [例2]：矩阵乘法的cc基本思想\n将n×n矩阵分解成四块 利用分治思想可以得到以下代码 实际的矩阵乘法的Strassen算法会更加复杂，但是可以实现将时间复杂度降到 O($n^{\\lg7}$)\n五、在线处理算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int MaxSubseqSum( int A[], int N ) { int ThisSum, MaxSum; int i; ThisSum = MaxSum = 0; for( i = 0; i \u0026lt; N; i++) { ThisSum += A[i]; if( ThisSum \u0026gt; MaxSum ) { MaxSum = ThisSum; // 找到了更大的子列，更新MaxSum } else if (ThisSum \u0026lt; 0) { ThisSum = 0; // 当前子列和小于零，在此基础上不可能让最终的子列和更大，故舍弃之 } } } 时间复杂度 T(N) = O(N)\n","date":"2025-05-19T15:14:58+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"数据结构基本概念"},{"content":"Java 面向对象编程 (OOP) 目录 面向对象 什么是面向对象 面向对象 vs 面向过程 类和对象 定义和使用 构造函数 Java中类定义的最简形式 public private static final 关键字 public 和 private static final 面向对象三大特性 1. 封装 2. 继承 3. 多态 面向对象 什么是面向对象 通俗来讲，面向对象就是让每一个对象有自己的属性和方法，并且进行封装的过程\n面向对象 vs 面向过程 特性 面向对象 (OOP) 面向过程 (POP) 重点 数据封装 功能实现 适用场景 复杂系统开发 小型程序开发 维护性 高 较低 代码复用 强 弱 类和对象 定义和使用 类：对象的模板\n包括：属性和方法 对象：类的实例 举例： 类：人 对象：学生，老师 构造函数 格式：public 类名 (传入的属性) {}\n1 2 3 4 5 6 7 8 9 10 class Employee { // 属性 private static String name; private double salary; private LocalDate hireDay; // 默认的无参构造函数 public Employee() { } } 使用 this 关键字可以访问当前对象和方法的属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Employee { private String name; private double salary; private LocalDate hireDay; // 默认构造函数 public Employee() { } // 带参数的构造函数 public Employee(String name, double salary, int year, int month, int day) { this.name = name; this.salary = salary; this.hireDay = LocalDate.of(year, month, day); } } 注意：一个类中可以包括多个构造函数（重载）\nJava中类定义的最简形式 1 2 3 4 5 6 7 8 9 10 11 class ClassName { 属性1 属性2 ... 构造函数1 构造函数2 ... 方法1 方法2 ... } public private static final 关键字 public 和 private 两个都是访问权限修饰符，用于限制或允许外界对类内部成员的访问，可以修饰 类 属性 方法 public：表示对象成员公开，整个项目中都可以使用 private：表示对象成员完全私有，不允许外界的任何访问 static 表示静态的，可以修饰 类 方法 代码块 特点： 修饰属性时，属性会在内存中并且只会存储唯一的一份。因此可以通过 类名.属性名 直接访问，不需要单独创建一个对象再访问\n例如：Math.PI 修饰方法时，也可以通过类名.方法名直接调用\n例如：Math.sin() 但是，静态方法中不能直接使用本类中的其他非static成员 1 2 3 4 5 6 7 8 9 class Test { String name; public static int id; public static void showInfo1() { System.out.println(\u0026#34;id:\u0026#34; + id); // id是static，不会报错 System.out.println(\u0026#34;name:\u0026#34; + name); // name不是staitc，这行代码会报错！ } } 修饰代码块时，只有类加载时静态方法快会执行且只执行一次 1 2 3 4 5 6 7 static { System.out.println(\u0026#34;静态代码块\u0026#34;); // 只在最开始执行一次，之后不会执行 } { System.out.println(\u0026#34;普通代码块\u0026#34;); // 只要类被加载，就会执行这段代码 } final 表示修饰的成员不可改变 特点： 修饰变量时，必须进行初始化复制，之后在任何位置使用时都不能修改值 修饰方法时，这个方法不能被子类重写 修饰类时，这个类不能被继承 面向对象三大特性 1. 封装 访问范围 private default protected public 同一个包中的同一类 √ √ √ √ 同一个包的不同类 √ √ √ 不同包中的子类 √ √ 不同包的非子类 √ 2. 继承 含义：在已有类（父类）的基础上，创建一个新的类（子类）添加一些新的属性和方法，实现对重复代码的复用，减少代码量 具体实现： 创建类时，使用 extends 关键字继承父类\n格式： public class 子类名 extends 父类名 {} 需要访问父类中的成员变量或者方法时，使用 super 关键字 1 2 3 4 5 6 7 8 9 10 11 // 父类 Employee public class Employee { private String name = \u0026#34;Hanmei\u0026#34;; private double salary; public Employee(String name, double salary) {} // 构造函数 public String getName() {} public double raiseSalary(double byPercent) {} public double getSalary() {} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 子类 Manager public class Manager extends Employee { // 在父类基础上添加新属性 bonus private double bonus; public Manager(String name, double salary) { super(name, salary); // 使用super获取父类中的属性 } public void setBonus(double bonus) { this.bonus = bonus; } // 重写父类getsalary()函数 public double getSalary() { return super.getSalary() + bonus; //使用super获取父类中的方法 } } 继承特点： 继承可以有多层继承：Person \u0026lt;-- Employee \u0026lt;-- Manager 继承可以有多分枝 3. 多态 含义：在继承体系下，当子类对父类中的方法进行重写后，创建子类对象并调用方法，程序执行的是对应类中的方法\n具体实现： 参照上面继承的代码，当执行下面的代码后\n1 2 3 4 Employee Alice = new Manager(\u0026#34;Alice\u0026#34;,10000); // 声明类型是Employee，实际类型是Manager Alice.setBonous(5000); Alice.getSalary(); 程序会输出15000而不是10000，因为程序调用的是Manager中重写的方法，尽管Alice声明的对象类型是Employee\n特别注意： 对于下面这段代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class SuperClass { void method1() {System.out.println(\u0026#34;SuperClass.method1\u0026#34;);} void method2() {System.out.println(\u0026#34;SuperClass.method2\u0026#34;);} } class SubClass extends SuperClass { void method2() {System.out.println(\u0026#34;SubClass.method2\u0026#34;);} void method3() {System.out.println(\u0026#34;SubClass.method3\u0026#34;);} } public static void main(String[] args) { SuperClass superC = new SuperClass(); SubClass subC = new SubClass(); SuperClass polyC = new SubClass(); //声明类型是superClass，实际类型是SubClass superC.method1(); superC.method2(); superC.method3(); subC.method1(); subC.method2(); subC.method3(); polyC.method1(); polyC.method2(); polyC.method3(); } 会有以下输出信息：\n1 2 3 4 5 6 7 8 9 SuperClass.method1 SuperClass.method2 method3() undefined SuperClass.method1 SubClass.method2 SubClass.method3 SuperClass.method1 SubClass.method2 method3() undefined // 尽管实际类型是SubClass，但是编译器只看声明类型，在SuperClass中无method3方法 多态的优点：\n可以降低代码的圈复杂度避免使用大量的if-else，提高代码的可读性 增强了代码的可扩展性，降低代码的修改成本 ","date":"2025-05-17T14:16:29+08:00","permalink":"https://ferdinandhu.netlify.app/p/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/","title":"Java面向对象编程"},{"content":"接口 Interface 概念： 接口是特殊的类，具体表现在接口中所有变量的属性都是 public static final 的，并且无方法体 用于制定统一标准，后续其他类实现这个接口后需要补全接口中的抽象方法 接口可以看作是一种约定，规定了实现类必须提供的方法 接口与class的区别 关键字不同（可看作调用接口是一种特殊的继承） 接口中定义的所有属性都是默认由 public static final 修饰的 接口中定义的所有方法默认都是由 public abstract 修饰的，并且没有方法体 一个类可以实现多个接口，但只能继承一个类 接口可以继承多个接口 接口的具体实现 在接口类中，用 interface 关键字声明一个接口（例如USB） 1 2 3 4 5 6 7 // 定义USB接口，包含输入和输出两个抽象方法 public interface USB { // 定义输入方法 void input(); // 定义输出方法 void output(); } 在普通类中（例如Keyboard），用 implement 关键字来实现接口，并重写接口中的所有抽象方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 键盘类，实现了USB接口 class Keyboard implements USB { // 获取键盘输入的字符串 public String getString() { return \u0026#34;从键盘获取的字符串\u0026#34;; } // 实现USB接口的input方法 // 用于接收USB供电 @Override public void input() { System.out.println(\u0026#34;接收USB供电\u0026#34;); } // 实现USB接口的output方法 // 用于输出键盘获取的字符串 @Override public void output() { System.out.println(\u0026#34;传入从键盘获取的字符串：\u0026#34; + getString()); } } 注意事项 接口中的方法必须是public的 实现类必须实现接口中的所有抽象方法 接口可以包含默认方法（default）和静态方法（static） 接口不能包含构造方法 接口中的变量默认是public static final的 ","date":"2025-05-17T14:15:40+08:00","permalink":"https://ferdinandhu.netlify.app/p/java%E6%8E%A5%E5%8F%A3/","title":"Java接口"},{"content":"交互式画板 v3.0 用Java实现一个功能丰富的交互式画图板\n在v2.0的基础上，添加了更多高级功能，包括画笔粗细调节、RGB颜色调节等，并优化了界面布局。\n各个类的功能介绍 DrawPadv3类：负责创建和初始化画板的图形界面，包括各种控制面板的布局和组件设置 DrawListener类：实现MouseListener、ActionListener和ChangeListener接口，用于处理鼠标事件、按钮点击事件和滑块值改变事件 具体实现 1. 界面布局设计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void showUI() { // 创建主窗口 JFrame jf = new JFrame(); jf.setTitle(\u0026#34;画板v3.0\u0026#34;); jf.setSize(1000,800); jf.setLocationRelativeTo(null); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 创建各个面板 JPanel topCtrlJP = new JPanel(); // 顶部控制面板 JPanel shapeBtnJP = new JPanel(); // 图形按钮面板 JPanel otherCtrlJP = new JPanel(); // 其他控制面板 JPanel drawJP = new JPanel(); // 绘图面板 JPanel penCtrlJP = new JPanel(); // 画笔控制面板 JPanel strokeWidthJslJP = new JPanel();// 画笔粗细滑块面板 JPanel colorBtnJP = new JPanel(); // 颜色按钮面板 JPanel colorJslJP = new JPanel(); // 颜色滑块面板 通过创建多个面板，实现了更清晰的界面布局：\n顶部控制面板：用于放置基本控制按钮 左侧图形按钮面板：用于选择绘图工具 中央绘图面板：主要的绘图区域 底部控制面板：包含画笔粗细调节和颜色选择功能 2. 画笔控制功能 1 2 3 4 5 6 7 8 9 10 11 12 public void initStrokeWidthJp(JPanel fontSizeJp) { JSlider sliderSize = new JSlider(JSlider.HORIZONTAL, 0, 20, 1); sliderSize.setMajorTickSpacing(4); sliderSize.setPaintLabels(true); sliderSize.addChangeListener(dl); JLabel labelSize = new JLabel(\u0026#34;画笔尺寸:\u0026#34; + 1); fontSizeJp.add(labelSize); fontSizeJp.add(sliderSize); dl.setStrokeWidthComponent(sliderSize, labelSize); } 实现了画笔粗细的实时调节功能：\n使用JSlider组件创建粗细调节滑块 范围从0到20，步长为1 添加刻度标记和数值标签 通过ChangeListener实时更新画笔粗细 3. RGB颜色调节 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void initColorJslJp(JPanel colorJslJp) { // 创建RGB颜色滑块 JSlider sliderR = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); JSlider sliderG = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); JSlider sliderB = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); // 设置滑块刻度 sliderR.setMajorTickSpacing(50); sliderG.setMajorTickSpacing(50); sliderB.setMajorTickSpacing(50); sliderR.setPaintLabels(true); sliderG.setPaintLabels(true); sliderB.setPaintLabels(true); } 添加了RGB颜色调节功能：\n为红、绿、蓝三个通道分别创建滑块 范围从0到255，步长为1 添加刻度标记和数值标签 实时预览颜色效果 4. 事件处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public void stateChanged(ChangeEvent e) { JSlider slider = (JSlider) e.getSource(); int value = slider.getValue(); int sliHashCode = slider.hashCode(); // 处理画笔粗细滑块 if (sliHashCode == jslFontSize.hashCode()) { fontSize = value; Graphics2D g2d = (Graphics2D) g; BasicStroke stroke = new BasicStroke(fontSize); g2d.setStroke(stroke); labelFontSize.setText(\u0026#34;画笔尺寸：\u0026#34; + fontSize); } // 处理颜色滑块 else { if (sliHashCode == sliderR.hashCode()) { red = value; labelR.setText(\u0026#34;红:\u0026#34; + red); } else if (sliHashCode == sliderG.hashCode()) { green = value; labelG.setText(\u0026#34;绿:\u0026#34; + green); } else if (sliHashCode == sliderB.hashCode()) { blue = value; labelB.setText(\u0026#34;蓝:\u0026#34; + blue); } Color color = new Color(red, green, blue); g.setColor(color); jslColorBtn.setBackground(color); } } 实现了完整的事件处理机制：\n处理滑块值改变事件，更新画笔粗细和颜色 处理按钮点击事件，切换绘图工具和颜色 处理鼠标事件，实现图形绘制 5. 绘图功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Override public void mouseReleased(MouseEvent e) { x2 = e.getX(); y2 = e.getY(); // 根据不同的绘图类型执行相应的绘制操作 if (type.equals(\u0026#34;直线\u0026#34;)) { g.drawLine(x1, y1, x2, y2); } else if (type.equals(\u0026#34;矩形\u0026#34;)) { g.drawRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;圆形\u0026#34;)) { g.drawOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } // ... 其他图形绘制代码 } 支持多种图形的绘制：\n直线、矩形、圆形等基本图形 实心图形和空心图形 等腰三角形及其变体 橡皮擦功能 6. 橡皮擦功能 橡皮擦功能的实现原理很简单，但非常实用：\n当用户选择橡皮擦工具时，程序会将画笔颜色设置为白色（Color.white） 由于画板的背景色也是白色，所以当用户使用橡皮擦工具绘制时，实际上是用白色覆盖了原有的图形 这种实现方式的优点是： 不需要额外的内存来存储绘图历史 可以精确擦除特定区域 擦除效果与画笔粗细设置保持一致 7. 清空功能 清空功能提供了一键清除整个画板的能力：\n实现原理：使用白色填充整个画板区域 具体步骤： 保存当前画笔颜色（Color currentColor = g.getColor()） 将画笔颜色设置为白色（g.setColor(Color.WHITE)） 使用fillRect方法填充整个画板区域（g.fillRect(0, 0, 1000, 800)） 恢复原来的画笔颜色（g.setColor(currentColor)） 这种实现方式的优点： 操作简单，一键完成 不会影响当前的画笔设置（颜色、粗细等） 可以快速开始新的绘制 主要改进 界面布局优化：使用多个面板实现更清晰的界面结构 画笔控制增强：添加画笔粗细调节功能 颜色系统升级：支持RGB颜色调节和预设颜色选择 事件处理完善：添加滑块值改变事件的处理 代码结构优化：更清晰的类设计和功能划分 使用说明 选择绘图工具：点击左侧面板中的工具按钮 调节画笔粗细：使用底部的粗细滑块 选择颜色： 使用预设颜色按钮 使用RGB滑块调节自定义颜色 绘制图形：在中央绘图区域按住鼠标拖动 使用橡皮擦：选择橡皮擦工具后，在需要擦除的区域拖动 清空画板：点击左侧面板中的\u0026quot;清空\u0026quot;按钮，可以一键清除所有绘制内容 最终效果 最终代码 DrawPadv3.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 package basic.hj0510; import javax.swing.*; import java.awt.*; /** * 画板程序的主类 * 负责创建和初始化画板的图形界面 * 实现了以下主要功能： * 1. 创建主窗口和各个功能面板 * 2. 设置面板布局和尺寸 * 3. 初始化各种控制组件（按钮、滑块等） * 4. 组装界面组件 * 5. 添加事件监听器 */ public class DrawPadv3 { // 创建绘图监听器实例，用于处理所有用户交互事件 DrawListener dl = new DrawListener(); /** * 显示画板界面 * 初始化所有UI组件并设置布局 * 主要步骤： * 1. 创建主窗口并设置基本属性 * 2. 创建并配置各个功能面板 * 3. 设置面板布局和尺寸 * 4. 初始化控制组件 * 5. 组装界面 * 6. 添加事件监听 */ public void showUI() { // 创建主窗口并设置基本属性 JFrame jf = new JFrame(); jf.setTitle(\u0026#34;画板v3.0\u0026#34;); jf.setSize(1000,800); // 设置窗口大小为1000x800像素 jf.setLocationRelativeTo(null); // 使窗口在屏幕中居中显示 jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置关闭窗口时退出程序 // 创建各个功能面板 JPanel topCtrlJP = new JPanel(); // 顶部控制面板：用于放置基本控制按钮 JPanel shapeBtnJP = new JPanel(); // 图形按钮面板：用于选择绘图工具 JPanel otherCtrlJP = new JPanel(); // 其他控制面板：包含绘图区域和其他控制组件 JPanel drawJP = new JPanel(); // 绘图面板：主要的绘图区域 JPanel penCtrlJP = new JPanel(); // 画笔控制面板：包含画笔粗细和颜色控制 JPanel strokeWidthJslJP = new JPanel();// 画笔粗细滑块面板：用于调节画笔粗细 JPanel colorBtnJP = new JPanel(); // 颜色按钮面板：用于选择预设颜色 JPanel colorJslJP = new JPanel(); // 颜色滑块面板：用于RGB颜色调节 // 设置各个面板的尺寸 Dimension dim_topCtrlJP = new Dimension(1100, 30); // 顶部控制面板尺寸 Dimension dim_shapeBtnJP = new Dimension(120, 570); // 图形按钮面板尺寸 Dimension dim_otherCtrlJP = new Dimension(900, 570); // 其他控制面板尺寸 Dimension dim_penCtrlJP = new Dimension(900, 150); // 画笔控制面板尺寸 Dimension dim_strokeWidthJslJP = new Dimension(260, 150);// 画笔粗细滑块面板尺寸 Dimension dim_colorBtnJP = new Dimension(360, 150); // 颜色按钮面板尺寸 Dimension dim_colorJslJP = new Dimension(280, 150); // 颜色滑块面板尺寸 // 应用尺寸设置到各个面板 topCtrlJP.setPreferredSize(dim_topCtrlJP); shapeBtnJP.setPreferredSize(dim_shapeBtnJP); otherCtrlJP.setPreferredSize(dim_otherCtrlJP); penCtrlJP.setPreferredSize(dim_penCtrlJP); strokeWidthJslJP.setPreferredSize(dim_strokeWidthJslJP); colorBtnJP.setPreferredSize(dim_colorBtnJP); colorJslJP.setPreferredSize(dim_colorJslJP); // 设置面板的布局管理器 topCtrlJP.setLayout(new BorderLayout()); // 使用边界布局 otherCtrlJP.setLayout(new BorderLayout()); // 使用边界布局 penCtrlJP.setLayout(new BorderLayout()); // 使用边界布局 // 设置各个面板的背景颜色 topCtrlJP.setBackground(Color.LIGHT_GRAY); // 浅灰色背景 shapeBtnJP.setBackground(Color.DARK_GRAY); // 深灰色背景 drawJP.setBackground(Color.WHITE); // 白色背景 strokeWidthJslJP.setBackground(Color.LIGHT_GRAY);// 浅灰色背景 colorBtnJP.setBackground(Color.LIGHT_GRAY); // 浅灰色背景 // 组装面板，构建界面层次结构 penCtrlJP.add(strokeWidthJslJP, BorderLayout.WEST); // 左侧放置画笔粗细控制 penCtrlJP.add(colorBtnJP, BorderLayout.EAST); // 右侧放置颜色按钮 penCtrlJP.add(colorJslJP, BorderLayout.CENTER); // 中间放置颜色滑块 otherCtrlJP.add(penCtrlJP, BorderLayout.SOUTH); // 底部放置画笔控制面板 otherCtrlJP.add(drawJP, BorderLayout.CENTER); // 中间放置绘图区域 jf.add(topCtrlJP, BorderLayout.NORTH); // 顶部放置控制面板 jf.add(shapeBtnJP, BorderLayout.WEST); // 左侧放置图形按钮 jf.add(otherCtrlJP, BorderLayout.CENTER); // 中间放置其他控制面板 // 初始化各个功能面板的组件 initColorBtnJp(colorBtnJP); // 初始化颜色按钮 initColorJslJp(colorJslJP); // 初始化颜色滑块 initStrokeWidthJp(strokeWidthJslJP);// 初始化画笔粗细控制 initShapeBtnJp(shapeBtnJP); // 初始化图形按钮 jf.setVisible(true); // 显示窗口 // 为绘图面板添加鼠标监听器，用于处理绘图操作 drawJP.addMouseListener(dl); // 获取绘图面板的Graphics对象并传递给监听器 Graphics g = drawJP.getGraphics(); dl.g = g; } /** * 初始化图形按钮面板 * 创建各种绘图工具的按钮 * 包括：直线、圆形、矩形等基本图形工具 * 以及实心图形和橡皮擦等特殊工具 */ public void initShapeBtnJp(JPanel shapeBtnJp) { // 定义所有可用的绘图工具 String[] btnType = {\u0026#34;直线\u0026#34;, \u0026#34;圆形\u0026#34;, \u0026#34;矩形\u0026#34;, \u0026#34;实心圆形\u0026#34;, \u0026#34;实心矩形\u0026#34;, \u0026#34;等腰三角形\u0026#34;, \u0026#34;实心等腰三角形\u0026#34;, \u0026#34;橡皮擦\u0026#34;, \u0026#34;清空\u0026#34;}; // 循环创建按钮并添加到面板 for (int i = 0; i \u0026lt; btnType.length; i++) { JButton btn = new JButton(btnType[i]); shapeBtnJp.add(btn); btn.addActionListener(dl); // 添加动作监听器 } } /** * 初始化颜色按钮面板 * 创建预设颜色的按钮 * 包括：黑色、红色、绿色等13种基本颜色 */ public void initColorBtnJp(JPanel colorBtnJp) { // 定义预设颜色数组，包含13种常用颜色 Color[] btnColors = {Color.BLACK, Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.CYAN, Color.MAGENTA, Color.GRAY, Color.LIGHT_GRAY, Color.DARK_GRAY, Color.PINK, Color.ORANGE, Color.WHITE}; // 创建颜色按钮 Dimension cDim = new Dimension(20, 20); // 设置按钮大小为20x20像素 for(int i = 0 ; i \u0026lt; btnColors.length ; i++) { JButton btn = new JButton(); btn.setActionCommand(\u0026#34;ColorBtn\u0026#34;); // 设置按钮命令 btn.setBackground(btnColors[i]); // 设置按钮背景色 colorBtnJp.add(btn); btn.setPreferredSize(cDim); // 设置按钮尺寸 btn.addActionListener(dl); // 添加动作监听器 } } /** * 初始化画笔粗细控制面板 * 创建画笔粗细滑块和标签 * 实现画笔粗细的实时调节功能 */ public void initStrokeWidthJp(JPanel fontSizeJp) { // 创建画笔粗细滑块，范围0-20，步长1 JSlider sliderSize = new JSlider(JSlider.HORIZONTAL, 0, 20, 1); sliderSize.setMajorTickSpacing(4); // 设置主刻度间隔 sliderSize.setPaintLabels(true); // 显示刻度标签 sliderSize.addChangeListener(dl); // 添加值改变监听器 // 创建显示当前画笔粗细的标签 JLabel labelSize = new JLabel(\u0026#34;画笔尺寸:\u0026#34; + 1); // 添加组件到面板 fontSizeJp.add(labelSize); fontSizeJp.add(sliderSize); // 将组件传递给监听器 dl.setStrokeWidthComponent(sliderSize, labelSize); } /** * 初始化颜色滑块面板 * 创建RGB颜色调节滑块和颜色预览按钮 * 实现颜色的精确调节功能 */ public void initColorJslJp(JPanel colorJslJp) { // 创建RGB三个颜色通道的滑块 JSlider sliderR = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); // 红色通道 JSlider sliderG = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); // 绿色通道 JSlider sliderB = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); // 蓝色通道 // 设置滑块刻度 sliderR.setMajorTickSpacing(50); // 设置主刻度间隔为50 sliderG.setMajorTickSpacing(50); sliderB.setMajorTickSpacing(50); sliderR.setPaintLabels(true); // 显示刻度标签 sliderG.setPaintLabels(true); sliderB.setPaintLabels(true); // 添加值改变监听器 sliderR.addChangeListener(dl); sliderG.addChangeListener(dl); sliderB.addChangeListener(dl); // 创建显示当前RGB值的标签 JLabel labelR = new JLabel(\u0026#34;R:\u0026#34; + 1); JLabel labelG = new JLabel(\u0026#34;G:\u0026#34; + 1); JLabel labelB = new JLabel(\u0026#34;B:\u0026#34; + 1); // 添加组件到面板 colorJslJp.add(labelR); colorJslJp.add(sliderR); colorJslJp.add(labelG); colorJslJp.add(sliderG); colorJslJp.add(labelB); colorJslJp.add(sliderB); // 创建颜色预览按钮 JButton jslColorBtn = new JButton(); jslColorBtn.setActionCommand(\u0026#34;ColorBtn\u0026#34;); jslColorBtn.setBackground(Color.BLACK); // 初始颜色设为黑色 jslColorBtn.setPreferredSize(new Dimension(200, 30)); // 设置按钮大小 colorJslJp.add(jslColorBtn); jslColorBtn.addActionListener(dl); dl.jslColorBtn = jslColorBtn; // 将按钮引用传递给监听器 // 将颜色相关组件传递给监听器 dl.setJslComponent(sliderR, sliderG, sliderB, labelR, labelG, labelB); } /** * 程序入口点 * 创建画板实例并显示界面 */ public static void main(String[] args) { DrawPadv3 dp = new DrawPadv3(); dp.showUI(); } } DrawListener.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 package basic.hj0510; import javax.swing.*; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; /** * 绘图监听器类 * 实现了鼠标监听器、动作监听器和状态改变监听器 * 用于处理画板的所有交互事件，包括： * 1. 鼠标事件：处理绘图操作 * 2. 按钮事件：处理工具选择和颜色选择 * 3. 滑块事件：处理画笔粗细和颜色调节 */ public class DrawListener implements MouseListener, ActionListener, ChangeListener { // 绘图对象，用于执行实际的绘图操作 public Graphics g; // 记录鼠标按下和释放的坐标，用于确定图形的位置和大小 int x1, y1, x2, y2; // 当前选择的绘图类型，默认为直线 String type = \u0026#34;直线\u0026#34;; // 颜色相关的组件和变量 int red = 1, green = 1, blue = 1; // RGB颜色值，初始值设为1 JSlider sliderR, sliderG, sliderB; // RGB颜色滑块 JLabel labelR, labelG, labelB; // RGB颜色值显示标签 JButton jslColorBtn; // 颜色预览按钮 /** * 设置颜色相关的组件 * 将RGB滑块和标签的引用保存到监听器中 */ public void setJslComponent(JSlider sliderR, JSlider sliderG, JSlider sliderB, JLabel labelR, JLabel labelG, JLabel labelB) { this.sliderR = sliderR; this.sliderG = sliderG; this.sliderB = sliderB; this.labelR = labelR; this.labelG = labelG; this.labelB = labelB; } // 画笔粗细相关组件 int fontSize = 1; // 画笔粗细值，初始值为1 JSlider jslFontSize; // 画笔粗细滑块 JLabel labelFontSize; // 画笔粗细显示标签 /** * 设置画笔粗细相关的组件 * 将滑块和标签的引用保存到监听器中 */ public void setStrokeWidthComponent(JSlider sliderSize, JLabel labelSize) { this.jslFontSize = sliderSize; this.labelFontSize = labelSize; } /** * 处理滑块值改变事件 * 用于更新颜色和画笔粗细 * 根据滑块的类型执行不同的更新操作 */ public void stateChanged(ChangeEvent e) { JSlider slider = (JSlider) e.getSource(); int value = slider.getValue(); int sliHashCode = slider.hashCode(); // 处理画笔粗细滑块 if (sliHashCode == jslFontSize.hashCode()) { fontSize = value; Graphics2D g2d = (Graphics2D) g; BasicStroke stroke = new BasicStroke(fontSize); g2d.setStroke(stroke); labelFontSize.setText(\u0026#34;画笔尺寸：\u0026#34; + fontSize); } // 处理颜色滑块 else { if (sliHashCode == sliderR.hashCode()) { red = value; labelR.setText(\u0026#34;红:\u0026#34; + red); } else if (sliHashCode == sliderG.hashCode()) { green = value; labelG.setText(\u0026#34;绿:\u0026#34; + green); } else if (sliHashCode == sliderB.hashCode()) { blue = value; labelB.setText(\u0026#34;蓝:\u0026#34; + blue); } // 更新当前颜色 Color color = new Color(red, green, blue); g.setColor(color); jslColorBtn.setBackground(color); } } /** * 处理按钮点击事件 * 用于切换绘图工具和颜色 * 根据按钮的类型执行不同的操作 */ @Override public void actionPerformed(ActionEvent e) { String ac = e.getActionCommand(); // 处理颜色按钮点击 if(ac.equals(\u0026#34;ColorBtn\u0026#34;)) { JButton btn = (JButton) e.getSource(); Color color = btn.getBackground(); // 更新RGB值 red = color.getRed(); green = color.getGreen(); blue = color.getBlue(); g.setColor(color); } // 处理橡皮擦工具 else if(ac.equals(\u0026#34;橡皮擦\u0026#34;)) { g.setColor(Color.white); // 设置颜色为白色，实现擦除效果 } // 处理清空画板 else if(ac.equals(\u0026#34;清空\u0026#34;)) { // 保存当前颜色 Color currentColor = g.getColor(); // 清除整个面板 g.setColor(Color.WHITE); g.fillRect(0, 0, 1000, 800); // 使用固定尺寸，确保覆盖整个绘图区域 // 恢复原来的颜色 g.setColor(currentColor); } // 处理其他绘图工具 else { type = ac; // 更新绘图类型 g.setColor(new Color(red, green, blue)); // 设置当前颜色 } } /** * 处理鼠标点击事件 * 目前仅用于调试输出 */ @Override public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;鼠标在窗体按钮上点击了\u0026#34;); } /** * 记录鼠标按下的起始位置 * 用于确定图形的起始点 */ @Override public void mousePressed(MouseEvent e) { x1 = e.getX(); y1 = e.getY(); } /** * 处理鼠标释放事件 * 根据选择的工具类型绘制相应的图形 * 支持多种图形的绘制，包括： * 1. 直线 * 2. 矩形（空心和实心） * 3. 圆形（空心和实心） * 4. 等腰三角形（空心和实心） */ @Override public void mouseReleased(MouseEvent e) { x2 = e.getX(); y2 = e.getY(); // 根据不同的绘图类型执行相应的绘制操作 if (type.equals(\u0026#34;直线\u0026#34;)) { g.drawLine(x1, y1, x2, y2); } else if (type.equals(\u0026#34;矩形\u0026#34;)) { g.drawRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;圆形\u0026#34;)) { g.drawOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;实心矩形\u0026#34;)) { g.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;实心圆形\u0026#34;)) { g.fillOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;实心等腰三角形\u0026#34;)) { // 绘制实心等腰三角形 int mx = (x1 + x2) / 2; // 计算顶点x坐标 int my = y1; // 顶点y坐标 int h = Math.abs(y2 - y1);// 计算高度 int w = Math.abs(x2 - x1);// 计算宽度 double dx = w / 2.0 / h; // 计算每行宽度变化量 // 逐行绘制三角形 for (int i = 0; i \u0026lt; h; i++) { if (y1 \u0026lt; y2) { g.drawLine((int) (mx - dx * i), my + i, (int) (mx + dx * i), my + i); } else { g.drawLine((int) (mx - dx * i), my - i, (int) (mx + dx * i), my - i); } } } else if (type.equals(\u0026#34;等腰三角形\u0026#34;)) { // 绘制等腰三角形轮廓 int mx = (x1 + x2) / 2; // 计算顶点x坐标 int my = y1; // 顶点y坐标 // 绘制三条边 g.drawLine(x1, y2, mx, my); // 左边 g.drawLine(mx, my, x2, y2); // 右边 g.drawLine(x1, y2, x2, y2); // 底边 } } /** * 处理鼠标进入事件 * 目前未实现具体功能 */ @Override public void mouseEntered(MouseEvent e) { } /** * 处理鼠标离开事件 * 目前未实现具体功能 */ @Override public void mouseExited(MouseEvent e) { } } ","date":"2025-05-11T10:31:36+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%94%BB%E6%9D%BF-v3.0/","title":"交互式画板 v3.0"},{"content":"交互式画板 v2.0 用java实现一个简单的可交互式画图板\n在v1.0的基础上，添加了更多的图形绘制功能，并优化了代码结构。\n各个类的功能介绍 DrawPadv2类：窗口的基础设置与可视化，并且添加鼠标监听器和动作监听器 DrawListener类：实现MouseListener和ActionListener接口，用于处理鼠标事件和按钮点击事件 具体操作 设置好窗体的基础属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 创建一个DrawListener对象 DrawListener dl = new DrawListener(); // 显示UI界面 public void showUI() { // 创建一个JFrame对象 JFrame jf = new JFrame(); // 设置窗口标题 jf.setTitle(\u0026#34;画板v2.0\u0026#34;); // 设置窗口大小 jf.setSize(850, 600); // 设置窗口居中显示 jf.setLocationRelativeTo(null); // 设置窗口关闭时的操作 jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗口布局为流式布局FlowLayout jf.setLayout(new FlowLayout()); 通过上述代码，我们创建了一个标题为 \u0026ldquo;画板 v2.0\u0026rdquo; 的窗口，设置其大小为 850x600 像素，并使其居中显示。同时，配置关闭窗口时终止程序运行，并采用流式布局（FlowLayout）管理组件排列。\n添加按钮和颜色按钮，并设置监听器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // 定义按钮类型 String [] btnType = {\u0026#34;直线\u0026#34;, \u0026#34;圆形\u0026#34;, \u0026#34;矩形\u0026#34;, \u0026#34;实心圆形\u0026#34;, \u0026#34;实心矩形\u0026#34;, \u0026#34;等腰三角形\u0026#34;, \u0026#34;实心等腰三角形\u0026#34;, \u0026#34;橡皮擦\u0026#34;}; // 循环创建按钮并添加到窗口中 for(int i = 0 ; i \u0026lt; btnType.length ; i++) { JButton btn = new JButton(btnType[i]); jf.add(btn); // 为按钮添加监听器 btn.addActionListener(dl); } // 定义颜色按钮的颜色 Color[] btnColors = {Color.BLACK, Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.CYAN, Color.MAGENTA, Color.GRAY, Color.LIGHT_GRAY, Color.DARK_GRAY, Color.PINK, Color.ORANGE, Color.WHITE}; // 循环创建颜色按钮并添加到窗口中 for(int i = 0 ; i \u0026lt; btnColors.length ; i++) { JButton btn = new JButton(); // 设置按钮的命令为ColorBtn btn.setActionCommand(\u0026#34;ColorBtn\u0026#34;); // 设置按钮的背景颜色 btn.setBackground(btnColors[i]); jf.add(btn); // 为按钮添加监听器 btn.addActionListener(dl); } // 设置窗口可见 jf.setVisible(true); // 为窗口添加鼠标监听器 jf.addMouseListener(dl); 通过循环创建两类按钮：一类用于选择绘制图形的类型，另一类用于切换画笔颜色。每个按钮均绑定了统一的事件监听器dl（DrawListener对象），实现交互逻辑的集中处理\n在DrawListener类中补全监听器中的方法，并创建一个Graphics对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class MouseListener implements java.awt.event.MouseListener { // 声明Graphics对象 Graphics g; public void actionPerformed(ActionEvent e) { System.out.println(\u0026#34;点击按钮\u0026#34;); } public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;鼠标点击\u0026#34;); } public void mousePressed(MouseEvent e) { System.out.println(\u0026#34;鼠标按下\u0026#34;); } public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;鼠标松开\u0026#34;); } public void mouseEntered(MouseEvent e) { System.out.println(\u0026#34;鼠标进入窗口\u0026#34;); } public void mouseExited(MouseEvent e) { System.out.println(\u0026#34;鼠标离开窗口\u0026#34;); } } 在DrawPadv2类中补全相关代码 1 2 3 4 // 获取窗口的Graphics对象 Graphics g = jf.getGraphics(); // 将Graphics对象赋值给DrawListener对象的g dl.g = g; 为窗口添加鼠标监听器，并将窗口的图形上下文（Graphics对象）传递给DrawListener，以便后续绘制操作。\n在DrawListener类中实现绘图逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 声明起始点和结束点的坐标 int x1, y1, x2, y2; // 声明图形类型和颜色 String type = \u0026#34;直线\u0026#34;; Color color = Color.black; @Override public void actionPerformed(ActionEvent e) { // 获取按钮的命令 String ac = e.getActionCommand(); System.out.println(\u0026#34;点击了按钮：\u0026#34; + ac); // 如果点击的是颜色按钮 if(ac.equals(\u0026#34;ColorBtn\u0026#34;)) { // 获取按钮的背景颜色 JButton btn = (JButton) e.getSource(); color = btn.getBackground(); } // 如果点击的是橡皮擦 else if(ac.equals(\u0026#34;橡皮擦\u0026#34;)) { // 设置画笔颜色为背景色 color = new Color(238, 238, 238); } // 否则设置画笔颜色 else { type = ac; g.setColor(color); } } 根据按钮的命令（actionCommand），判断用户是选择了颜色、橡皮擦还是图形类型，并更新画笔颜色或绘图模式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @Override public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;鼠标点击\u0026#34;); } @Override public void mousePressed(MouseEvent e) { System.out.println(\u0026#34;鼠标按下\u0026#34;); // 获取鼠标按下时的坐标 x1 = e.getX(); y1 = e.getY(); } @Override public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;鼠标松开\u0026#34;); // 获取鼠标松开时的坐标 x2 = e.getX(); y2 = e.getY(); // 如果y2小于80，则将y2设置为80 if(y2 \u0026lt; 80) { y2 = 80; } // 根据图形类型绘制图形 Graphics g = DrawPanel.getGraphics(); g.setColor(color); if (type.equals(\u0026#34;直线\u0026#34;)) { g.drawLine(x1, y1, x2, y2); } else if (type.equals(\u0026#34;圆形\u0026#34;)) { g.drawOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;矩形\u0026#34;)) { g.drawRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;实心圆形\u0026#34;)) { g.fillOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;实心矩形\u0026#34;)) { g.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;等腰三角形\u0026#34;)) { // 计算等腰三角形的顶点坐标 int mx = (x1 + x2) / 2; int my = y1; // 绘制等腰三角形 g.drawLine(x1, y2, mx, my); g.drawLine(mx, my, x2, y2); g.drawLine(x1, y2, x2, y2); } else if (type.equals(\u0026#34;实心等腰三角形\u0026#34;)) { // 计算等腰三角形的顶点坐标 int mx = (x1 + x2) / 2; int my = y1; int h = Math.abs(y2 - y1); int w = Math.abs(x2 - x1); double dx = w / 2.0 / h; // 绘制等腰三角形 for (int i = 0; i \u0026lt; h; i++) { if (y1 \u0026lt; y2) { g.drawLine((int) (mx - dx * i), my + i, (int) (mx + dx * i), my + i); } else { g.drawLine((int) (mx - dx * i), my - i, (int) (mx + dx * i), my - i); } } } } 在主函数中创建并显示窗口 1 2 3 4 5 6 public static void main(String[] args) { // 创建DrawPadv2对象 DrawPadv2 dl = new DrawPadv2(); // 调用showUI方法显示UI界面 dl.showUI(); } 通过mousePressed和mouseReleased方法记录鼠标按下与释放的坐标，结合当前选择的图形类型，调用Graphics对象的绘图方法完成绘制\n最终代码 DrawPadv2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 package basic.hj0507; import javax.swing.*; import java.awt.*; public class DrawPadv2 { // 创建一个DrawListener对象 DrawListener dl = new DrawListener(); // 显示UI界面 public void showUI() { // 创建一个JFrame对象 JFrame jf = new JFrame(); // 设置窗口标题 jf.setTitle(\u0026#34;画板v2.0\u0026#34;); // 设置窗口大小 jf.setSize(850,600); // 设置窗口居中显示 jf.setLocationRelativeTo(null); // 设置窗口关闭时的操作 jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 设置窗口布局为FlowLayout jf.setLayout(new FlowLayout()); // 定义按钮类型 String [] btnType = {\u0026#34;直线\u0026#34;, \u0026#34;圆形\u0026#34;, \u0026#34;矩形\u0026#34;, \u0026#34;实心圆形\u0026#34;, \u0026#34;实心矩形\u0026#34;, \u0026#34;等腰三角形\u0026#34;, \u0026#34;实心等腰三角形\u0026#34;, \u0026#34;橡皮擦\u0026#34;}; // 循环创建按钮并添加到窗口中 for(int i = 0 ; i \u0026lt; btnType.length ; i++) { JButton btn = new JButton(btnType[i]); jf.add(btn); // 为按钮添加监听器 btn.addActionListener(dl); } // 定义颜色按钮的颜色 Color[] btnColors = {Color.BLACK, Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.CYAN, Color.MAGENTA, Color.GRAY, Color.LIGHT_GRAY, Color.DARK_GRAY, Color.PINK, Color.ORANGE, Color.WHITE}; // 循环创建颜色按钮并添加到窗口中 for(int i = 0 ; i \u0026lt; btnColors.length ; i++) { JButton btn = new JButton(); // 设置按钮的命令为ColorBtn btn.setActionCommand(\u0026#34;ColorBtn\u0026#34;); // 设置按钮的背景颜色 btn.setBackground(btnColors[i]); jf.add(btn); // 为按钮添加监听器 btn.addActionListener(dl); } // 设置窗口可见 jf.setVisible(true); // 为窗口添加鼠标监听器 jf.addMouseListener(dl); // 获取窗口的Graphics对象 Graphics g = jf.getGraphics(); // 将Graphics对象赋值给DrawListener对象的g dl.g = g; } // 主方法 public static void main(String[] args) { // 创建DrawPadv2对象 DrawPadv2 dl = new DrawPadv2(); // 调用showUI方法显示UI界面 dl.showUI(); } } DrawListener\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 package basic.hj0507; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; public class DrawListener implements MouseListener, ActionListener { // 声明Graphics对象 Graphics g; // 声明起始点和结束点的坐标 int x1, y1, x2, y2; // 声明图形类型和颜色 String type = \u0026#34;直线\u0026#34;; Color color = Color.black; @Override public void actionPerformed(ActionEvent e) { // 获取按钮的命令 String ac = e.getActionCommand(); System.out.println(\u0026#34;点击了按钮：\u0026#34; + ac); // 如果点击的是颜色按钮 if(ac.equals(\u0026#34;ColorBtn\u0026#34;)) { // 获取按钮的背景颜色 JButton btn = (JButton) e.getSource(); color = btn.getBackground(); // 设置画笔颜色 g.setColor(color); } // 如果点击的是橡皮擦 else if(ac.equals(\u0026#34;橡皮擦\u0026#34;)) { // 设置画笔颜色为背景色 Color color2 = new Color(238,238,238); g.setColor(color2); } // 否则设置画笔颜色 else { type = ac; g.setColor(color); } } @Override public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;鼠标点击\u0026#34;); } @Override public void mousePressed(MouseEvent e) { System.out.println(\u0026#34;鼠标按下\u0026#34;); // 获取鼠标按下时的坐标 x1 = e.getX(); y1 = e.getY(); } @Override public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;鼠标松开\u0026#34;); // 获取鼠标松开时的坐标 x2 = e.getX(); y2 = e.getY(); // 如果y2小于80，则将y2设置为80 if(y2\u0026lt;80) { y2 = 80; } // 根据图形类型绘制图形 if (type.equals(\u0026#34;直线\u0026#34;)) { g.drawLine(x1, y1, x2, y2); } else if (type.equals(\u0026#34;矩形\u0026#34;)) { g.drawRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;圆形\u0026#34;)) { g.drawOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;实心矩形\u0026#34;)) { g.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;实心圆形\u0026#34;)) { g.fillOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;实心等腰三角形\u0026#34;)) { // 计算等腰三角形的顶点坐标 int mx = (x1 + x2) / 2; int my = y1; int h = Math.abs(y2 - y1); int w = Math.abs(x2 - x1); double dx = w / 2.0 / h; // 绘制等腰三角形 for (int i = 0; i \u0026lt; h; i++) { if (y1 \u0026lt; y2) { g.drawLine((int) (mx - dx * i), my + i, (int) (mx + dx * i), my + i); } else { g.drawLine((int) (mx - dx * i), my - i, (int) (mx + dx * i), my - i); } } } else if (type.equals(\u0026#34;等腰三角形\u0026#34;)) { // 计算等腰三角形的顶点坐标 int mx = (x1 + x2) / 2; int my = y1; // 绘制等腰三角形 g.drawLine(x1, y2, mx, my); g.drawLine(mx, my, x2, y2); g.drawLine(x1, y2, x2, y2); } } @Override public void mouseEntered(MouseEvent e) { System.out.println(\u0026#34;鼠标进入窗口\u0026#34;); } @Override public void mouseExited(MouseEvent e) { System.out.println(\u0026#34;鼠标离开窗口\u0026#34;); } } ","date":"2025-05-08T20:26:36+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%94%BB%E6%9D%BF-v2.0/","title":"交互式画板 v2.0"},{"content":"交互式画板 v1.0 用java实现一个简单的可交互式画图板\n各个类的功能介绍 DrawPad类： 窗口的基础设置与可视化，并且将鼠标和键盘的监听器添加到窗口中 MouseListener类： 创建一个监听器类实现鼠标监听器，实现鼠标点击、按下、释放、进入、离开等方法 KeyListener类： 创建一个监听器类实现键盘监听器，便于在键盘上控制和切换不同的绘画类型 具体步骤 在DrawPad类中创建一个窗体jf，并且设置好属性 1 2 3 4 5 6 7 8 JFrame jf = new JFrame(); String title = \u0026#34;画板v1.0\u0026#34;; jf.setTitle(title); jf.setSize(800,600); jf.setLocationRelativeTo(null); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setLayout(new FlowLayout()); jf.setVisible(true); 在监听器MouseListener类中创建一个鼠标监听器，并补全监听器中默认的所有方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class MouseListener implements java.awt.event.MouseListener { public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;点击\u0026#34;); } public void mousePressed(MouseEvent e) { System.out.println(\u0026#34;按下\u0026#34;); } public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;松开\u0026#34;); } public void mouseEntered(MouseEvent e) { System.out.println(\u0026#34;进入\u0026#34;); } public void mouseExited(MouseEvent e) { System.out.println(\u0026#34;离开\u0026#34;); } } 创建一个监听器类的对象m，并对窗体对象添加鼠标监听器 1 2 MouseListener m = new MouseListener(); jf.addMouseListener(m); 在可视化之后获取窗体的画笔对象 1 2 Graphics g = jf.getGraphics(); m.gr = g; // 将获取的画笔对象的引用地址 复制一份给监听器中画笔对象变量名 将刚刚的画笔对象传给监听器中的画笔对象中 1 Graphics gr; 相同的方法，创建一个键盘监听器KeyListener类便于控制和切换不同的绘画类型。在keyPressed方法块中： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class KeyListener implements java.awt.event.KeyListener { // 声明一个私有的 MouseListener 类型的成员变量 mouseListener，用于引用一个 MouseListener 对象，以便在键盘事件处理中与鼠标事件相关联 private MouseListener mouseListener; // 定义类的构造方法，接收一个 MouseListener 类型的参数 mouseListener public KeyListener(MouseListener mouseListener) { this.mouseListener = mouseListener; } public void keyTyped(KeyEvent e) { System.out.println(\u0026#34;输入：\u0026#34; + e.getKeyCode()); } public void keyPressed(KeyEvent e) { System.out.println(\u0026#34;按下：\u0026#34; + e.getKeyCode()); int keyCode = e.getKeyCode(); // 使用 switch 语句根据不同的键码执行不同的操作 switch (keyCode) { case KeyEvent.VK_1: // 调用 mouseListener 对象的 setDrawType 方法，将绘画类型设置为 1 mouseListener.setDrawType(1); System.out.println(\u0026#34;当前绘画类型：直线\u0026#34;); break; case KeyEvent.VK_2: mouseListener.setDrawType(2); System.out.println(\u0026#34;当前绘画类型：矩形\u0026#34;); break; case KeyEvent.VK_3: mouseListener.setDrawType(3); System.out.println(\u0026#34;当前绘画类型：实心矩形\u0026#34;); break; case KeyEvent.VK_4: mouseListener.setDrawType(4); System.out.println(\u0026#34;当前绘画类型：等腰三角形\u0026#34;); break; case KeyEvent.VK_5: mouseListener.setDrawType(5); System.out.println(\u0026#34;当前绘画类型：五角星\u0026#34;); break; } } public void keyReleased(KeyEvent e) { System.out.println(\u0026#34;松开：\u0026#34; + e.getKeyCode()); } } 在 MouseListener 类中补全相关代码 1 2 3 4 5 6 // 定义一个私有整型变量，用于存储当前的绘图类型 private int drawType; // 定义setDrawType方法，接收KeyListener类传入的drawType值 public void setDrawType(int drawType) { this.drawType = drawType; } 使用从窗体对象中传入的画笔和KeyListener类传入的drawType值，绘制直线来实现不同的图案类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;松开\u0026#34;); x2 = e.getX(); y2 = e.getY(); switch (drawType) { case 1: gr.drawLine(x1,y1,x2,y2); break; case 2: gr.drawLine(x1,y1,x2,y1); gr.drawLine(x2,y1,x2,y2); gr.drawLine(x1,y2,x2,y2); gr.drawLine(x1,y1,x1,y2); break; case 3: int height = Math.abs(y1 - y2); int yi = y1; while (Math.abs(yi-y1)\u0026lt;height) { gr.drawLine(x1,yi,x2,yi); if(y1\u0026lt;y2) { yi++; } else { yi--; } } break; case 4: int vertexX = ( x1 + x2 )/2; int vertexY = y1; gr.drawLine(vertexX,vertexY,x1,y2); gr.drawLine(vertexX,vertexY,x2,y2); gr.drawLine(x1,y2,x2,y2); break; case 5: int v1X = ( x1 + x2 )/2; int v1Y = y1; int v2X = x2; int v2Y = 2*y1/3 + y2/3; int v3X = x1/5 + 4*x2/5; int v3Y = y2; int v4X = x2/5 + 4*x1/5; int v4Y = y2; int v5X = x1; int v5Y = 2*y1/3 + y2/3; gr.drawLine(v1X,v1Y,v3X,v3Y); gr.drawLine(v3X,v3Y,v5X,v5Y); gr.drawLine(v5X,v5Y,v2X,v2Y); gr.drawLine(v2X,v2Y,v4X,v4Y); gr.drawLine(v4X,v4Y,v1X,v1Y); break; } } 最终代码 DrawPad.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.awt.*; import java.awt.event.KeyListener; import javax.swing.*; public class DrawPad { public void showUI(){ JFrame jf = new JFrame(); String title = \u0026#34;画板v1.0\u0026#34;; jf.setTitle(title); jf.setSize(800,600); jf.setLocationRelativeTo(null); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setLayout(new FlowLayout()); jf.setVisible(true); MouseListener m = new MouseListener(); jf.addMouseListener(m); KeyListener k = new basic.hj0430.KeyListener(m); jf.addKeyListener(k); Graphics g = jf.getGraphics(); m.gr = g; } public static void main(String[] args) { new DrawPad().showUI(); } } MouseListener.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import java.awt.*; import java.awt.event.MouseEvent; public class MouseListener implements java.awt.event.MouseListener { Graphics gr; int x1,x2,y1,y2; private int drawType; public void setDrawType(int drawType) { this.drawType = drawType; } public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;点击\u0026#34;); } public void mousePressed(MouseEvent e) { System.out.println(\u0026#34;按下\u0026#34;); x1 = e.getX(); y1 = e.getY(); } public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;松开\u0026#34;); x2 = e.getX(); y2 = e.getY(); switch (drawType) { case 1: gr.drawLine(x1,y1,x2,y2); break; case 2: gr.drawLine(x1,y1,x2,y1); gr.drawLine(x2,y1,x2,y2); gr.drawLine(x1,y2,x2,y2); gr.drawLine(x1,y1,x1,y2); break; case 3: int height = Math.abs(y1 - y2); int yi = y1; while (Math.abs(yi-y1)\u0026lt;height) { gr.drawLine(x1,yi,x2,yi); if(y1\u0026lt;y2) { yi++; } else { yi--; } } break; case 4: int vertexX = ( x1 + x2 )/2; int vertexY = y1; gr.drawLine(vertexX,vertexY,x1,y2); gr.drawLine(vertexX,vertexY,x2,y2); gr.drawLine(x1,y2,x2,y2); break; case 5: int v1X = ( x1 + x2 )/2; int v1Y = y1; int v2X = x2; int v2Y = 2*y1/3 + y2/3; int v3X = x1/5 + 4*x2/5; int v3Y = y2; int v4X = x2/5 + 4*x1/5; int v4Y = y2; int v5X = x1; int v5Y = 2*y1/3 + y2/3; gr.drawLine(v1X,v1Y,v3X,v3Y); gr.drawLine(v3X,v3Y,v5X,v5Y); gr.drawLine(v5X,v5Y,v2X,v2Y); gr.drawLine(v2X,v2Y,v4X,v4Y); gr.drawLine(v4X,v4Y,v1X,v1Y); break; } } public void mouseEntered(MouseEvent e) { System.out.println(\u0026#34;进入\u0026#34;); } public void mouseExited(MouseEvent e) { System.out.println(\u0026#34;离开\u0026#34;); } } KeyListener.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.awt.*; import java.awt.event.KeyEvent; public class KeyListener implements java.awt.event.KeyListener { private MouseListener mouseListener; public KeyListener(MouseListener mouseListener) { this.mouseListener = mouseListener; } public void keyTyped(KeyEvent e) { System.out.println(\u0026#34;输入：\u0026#34; + e.getKeyCode()); } public void keyPressed(KeyEvent e) { System.out.println(\u0026#34;按下：\u0026#34; + e.getKeyCode()); int keyCode = e.getKeyCode(); switch (keyCode) { case KeyEvent.VK_1: mouseListener.setDrawType(1); System.out.println(\u0026#34;当前绘画类型：直线\u0026#34;); break; case KeyEvent.VK_2: mouseListener.setDrawType(2); System.out.println(\u0026#34;当前绘画类型：矩形\u0026#34;); break; case KeyEvent.VK_3: mouseListener.setDrawType(3); System.out.println(\u0026#34;当前绘画类型：实心矩形\u0026#34;); break; case KeyEvent.VK_4: mouseListener.setDrawType(4); System.out.println(\u0026#34;当前绘画类型：等腰三角形\u0026#34;); break; case KeyEvent.VK_5: mouseListener.setDrawType(5); System.out.println(\u0026#34;当前绘画类型：五角星\u0026#34;); break; } } public void keyReleased(KeyEvent e) { System.out.println(\u0026#34;松开：\u0026#34; + e.getKeyCode()); } } ","date":"2025-05-03T19:51:27+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%94%BB%E6%9D%BF-v1.0/","title":"交互式画板 v1.0"},{"content":"用户身份验证界面 用java实现一个简单的用户身份验证界面，包含用户注册、登录、登出和注销功能，并且通过图形用户界面（GUI）生成一个窗口供用户进行交互\n各个类的功能介绍 User类\n数据模型 规定整个项目需要处理的数据 功能： 包含用户的基本信息 规定基本的登录、登出标准和功能 UserService类\n数据处理 实现具体的注册、登录、登出和注销的逻辑 功能： 负责管理用户具体的注册、登录、登出和注销等操作 利用HashMap存储所有用户信息和在线用户信息 LoginAction 类\n功能控制 处理用户在界面点击登录、注册、登出、注销按钮的事件,并根据返回结果弹出对应的提示对话框 功能： 实现了ActionListener接口 根据用户点击的结果跳转不同的功能 UI类\n用户接口 UI界面可视化 功能： 创建和显示界面窗口 加入输入框，按钮等组件 最终代码实现 User.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class User { // 用户属性 String name; String pwd; int score; boolean isLogin; // 定义一个login方法，根据输入的密码进行登录操作，返回不同的登录状态码 // 1001用户已在线 1002登录成功 1003密码错误 public int login(String pwdIn){ if (pwd.equals(pwdIn)){ if (isLogin) { return 1001; } score += 100; isLogin = true; return 1002; } return 1003; } // 定义一个logout方法，根据输入的密码进行登出操作，返回不同的登出状态码 // 1004登出成功 1005账号未登录 1006密码错误登出失败 public int logout(String pwdIn){ if (pwd.equals(pwdIn)){ if(isLogin){ isLogin = false; return 1004; } return 1005; } return 1006; } } UserService.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 import java.util.HashMap; public class UserService { // 用两个HashMap来分别存储所有用户和在线用户的数据 HashMap\u0026lt;String, User\u0026gt; usersGeneral = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;String, User\u0026gt; usersOnline = new HashMap\u0026lt;\u0026gt;(); // 下面四个方法分别用于在HashMap中添加和删除用户信息 public void addUserGeneral(User user){ usersGeneral.put(user.name, user); } public void removeUserGeneral(User user){ usersGeneral.remove(user.name); } public void addUserOnline(User user){ usersOnline.put(user.name, user); } public void removeUserOnline(User user) { usersOnline.remove(user.name); } // backstageInfoShow()用于显示后台信息 public void backstageInfoShow() { System.out.println(\u0026#34;\\n\u0026#34;); System.out.println(\u0026#34;====Backstage====\u0026#34;); System.out.println(\u0026#34;目前注册量： \u0026#34; + usersGeneral.size()); System.out.println(\u0026#34;在线用户数量： \u0026#34; + usersOnline.size()); System.out.println(\u0026#34;=================\u0026#34;); } // userInfoShow() 用于显示用户信息 public void userInfoShow(User user){ System.out.println(\u0026#34;\\n\u0026#34;); System.out.println(\u0026#34;-----------------\u0026#34;); System.out.println(\u0026#34;账号： \u0026#34; + user.name); System.out.println(\u0026#34;状态： \u0026#34; + ( user.isLogin ? \u0026#34;登录\u0026#34;:\u0026#34;未登录\u0026#34;)); System.out.println(\u0026#34;积分： \u0026#34; + user.score); System.out.println(\u0026#34;-----------------\u0026#34;); } // userLogin(), userLogout(), userCancel() 方法通过接收User类中login(), logout() // 方法传入的登录登出状态码，继续完善登录登出操作并返回新的状态码 public int userLogin(String name, String pwd){ boolean isContained = usersGeneral.containsKey(name); if (isContained){ User user = usersGeneral.get(name); int loginCode = user.login(pwd); if (loginCode == 1002){ addUserOnline(user); } backstageInfoShow(); userInfoShow(user); return loginCode; } else{ return 1000; } } public int userLogout(String name, String pwd){ boolean isContained = usersOnline.containsKey(name); if (isContained){ User user = usersOnline.get(name); int logoutCode = user.logout(pwd); if (logoutCode ==1004){ removeUserOnline(user); } backstageInfoShow(); userInfoShow(user); return logoutCode; } else{ return 1005; } } public boolean userRegister(String name, String pwd){ boolean isContained = usersGeneral.containsKey(name); if (isContained){ backstageInfoShow(); return false; } else{ User user = new User(); user.name = name; user.pwd = pwd; user.score = 10000; addUserGeneral(user); backstageInfoShow(); userInfoShow(user); return true; } } //1007注销成功 1008密码错误注销失败 1009用户未注册注销失败 public int userCancel(String name, String pwd){ boolean isContained = usersGeneral.containsKey(name); int cancelCode; if (isContained){ User user = usersGeneral.get(name); if(user.login(pwd) != 1003){ removeUserGeneral(user); removeUserOnline(user); cancelCode = 1007; } else { cancelCode = 1008; } backstageInfoShow(); return cancelCode; } else { cancelCode = 1009; backstageInfoShow(); return cancelCode; } } } LoginAction.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class LoginAction implements ActionListener { // 用于存储用户名输入框的引用，后续从该输入框获取用户输入的用户名和密码 JTextField nameJTF2 = null; JTextField pwdJTF2 = null; // 创建 UserService 类的实例，用于调用其中的用户管理方法（如登录、注册等） UserService userService = new UserService(); // 实现 ActionListener 接口的 actionPerformed 方法，当用户点击按钮时会触发此方法 public void actionPerformed(ActionEvent e){ // 获取用户点击按钮的命令文本 String ac = e.getActionCommand(); System.out.println(\u0026#34;Commend: \u0026#34; + ac); String name = nameJTF2.getText(); System.out.println(\u0026#34;账号： \u0026#34; + name); String pwd = pwdJTF2.getText(); System.out.println(\u0026#34;密码： \u0026#34; + pwd); // 根据用户点击的按钮命令进行不同的处理 switch (ac) { case \u0026#34;登录\u0026#34; -\u0026gt; { int loginCode = userService.userLogin(name, pwd); switch (loginCode) { case 1000: JOptionPane.showMessageDialog(null, \u0026#34;用户不存在！\u0026#34;); break; case 1001: JOptionPane.showMessageDialog(null, \u0026#34;用户已在线！\u0026#34;); break; case 1002: JOptionPane.showMessageDialog(null, \u0026#34;登录成功！\u0026#34;); break; case 1003: JOptionPane.showMessageDialog(null, \u0026#34;密码错误！\u0026#34;); break; } } case \u0026#34;注册\u0026#34; -\u0026gt; { boolean registerCode = userService.userRegister(name, pwd); if (registerCode) { JOptionPane.showMessageDialog(null, \u0026#34;注册成功！\u0026#34;); } else { JOptionPane.showMessageDialog(null, \u0026#34;注册失败！用户已存在\u0026#34;); } } case \u0026#34;登出\u0026#34; -\u0026gt; { int logoutCode = userService.userLogout(name, pwd); switch (logoutCode) { case 1004: JOptionPane.showMessageDialog(null, \u0026#34;登出成功！\u0026#34;); break; case 1005: JOptionPane.showMessageDialog(null, \u0026#34;用户未登录！\u0026#34;); break; case 1006: JOptionPane.showMessageDialog(null, \u0026#34;密码错误！登出失败\u0026#34;); break; } } //1007注销成功 1008密码错误注销失败 1009用户未注册注销失败 case \u0026#34;注销\u0026#34; -\u0026gt; { int cancelCode = userService.userCancel(name, pwd); switch (cancelCode) { case 1007: JOptionPane.showMessageDialog(null, \u0026#34;注销成功！\u0026#34;); break; case 1008: JOptionPane.showMessageDialog(null, \u0026#34;密码错误！注销失败\u0026#34;); break; case 1009: JOptionPane.showMessageDialog(null, \u0026#34;用户未注册！注销失败\u0026#34;); break; } } } } } UI.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import java.awt.*; import java.util.Objects; import javax.swing.*; public class UI { // showUI 方法用于初始化并展示图形用户界面 public void showUI(){ // 创建一个 JFrame 窗口对象 JFrame jf = new JFrame(); jf.setTitle(\u0026#34;操作窗口\u0026#34;); jf.setSize(270,280); jf.setLocationRelativeTo(null); // 设置窗口关闭时的默认操作，这里是退出应用程序 jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); FlowLayout fl = new FlowLayout(); jf.setLayout(fl); // 从类路径中获取名为 \u0026#34;Login.png\u0026#34; 的图片资源，并创建一个 ImageIcon 对象 // 使用 Objects.requireNonNull 确保获取的资源不为 null，若为 null 则抛出 NullPointerException ImageIcon img = new ImageIcon(Objects.requireNonNull(UI.class.getResource(\u0026#34;Login.png\u0026#34;))); JLabel imgJLa = new JLabel(img); // 创建 JLabel 标签并显示文本 JLabel nameJLa = new JLabel(\u0026#34;账号\u0026#34;); JLabel pwdJLa = new JLabel(\u0026#34;密码\u0026#34;); // 创建 JTextField 文本框 JTextField nameJTF = new JTextField(20); JTextField pwdJTF = new JPasswordField(20); // 创建 JButton 按钮并显示文本 JButton loginBtn = new JButton(\u0026#34;登录\u0026#34;); JButton registerBtn = new JButton(\u0026#34;注册\u0026#34;); JButton logoutBtn = new JButton(\u0026#34;登出\u0026#34;); JButton cancelBtn = new JButton(\u0026#34;注销\u0026#34;); // 将各个组件依次添加到窗口中 jf.add(imgJLa); jf.add(pwdJLa); jf.add(nameJLa); jf.add(nameJTF); jf.add(pwdJLa); jf.add(pwdJTF); jf.add(loginBtn); jf.add(registerBtn); jf.add(logoutBtn); jf.add(cancelBtn); // 设置窗口为可见状态，使其显示在屏幕上 jf.setVisible(true); // 创建一个 LoginAction 对象，用于处理按钮的点击事件 // 为各按钮添加事件监听器，关联到 LoginAction 对象 LoginAction la = new LoginAction(); loginBtn.addActionListener(la); registerBtn.addActionListener(la); logoutBtn.addActionListener(la); cancelBtn.addActionListener(la); // 将窗口中用户名和密码输入框的引用赋值给 LoginAction 对象中的相应字段 la.nameJTF2 = nameJTF; la.pwdJTF2 = pwdJTF; } public static void main(String[] args) { UI loginUI = new UI(); loginUI.showUI(); } } ","date":"2025-04-27T17:20:40+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE1%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E7%95%8C%E9%9D%A2/","title":"实战项目1——用户认证界面"},{"content":"事件监听器 原理 利用java外部库自带的java.awt.event资源包中的ActionListener接口,并利用actionPerformed(ActionEvent e)方法监听按钮的动作事件 前期工作 已创建 LoginUI 库，用于创建登录窗口，其中有用于输入账号和密码单行输入框和登录按钮 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //登录窗口 import java.awt.*; import javax.swing.*; public class LoginUI { public void showUI() { JFrame jf = new JFrame(); jf.setTitle(\u0026#34;登录窗口\u0026#34;); jf.setSize(270, 280); jf.setLocationRelativeTo(null); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); FlowLayout fl = new FlowLayout(); jf.setLayout(fl); ImageIcon img = new ImageIcon(\u0026#34;\u0026lt;图片地址\u0026gt;\u0026#34;); JLabel imgJLa = new JLabel(img); JLabel accountJLa = new JLabel(\u0026#34;账号\u0026#34;); JLabel passwordJLa = new JLabel(\u0026#34;密码\u0026#34;); JTextField accountJTF = new JTextField(20); JTextField passwordJTF = new JTextField(20); JButton loginBtn = new JButton(\u0026#34;登录\u0026#34;); JButton registerBtn = new JButton(\u0026#34;注册\u0026#34;); jf.add(imgJLa); jf.add(accountJLa); jf.add(accountJTF); jf.add(passwordJLa); jf.add(passwordJTF); jf.add(loginBtn); jf.add(registerBtn); jf.setVisible(true); } public static void main(String[] args) { LoginUI login_ui = new LoginUI(); login_ui.showUI(); } } ActionListener 接口 动作事件监听器接口 监听鼠标是否点击了按钮这类组件 注意： ActionListener接口是一个模板，并不能当作类进行操作，在创建类名时需要按以下操作 1 public class LoginAction implements ActionListener{ } 并在类中重写监听器中的抽象方法 actionPerformed() 1 public void actionPerformed(ActionEvent e){ } 具体步骤 为方便起见，先创建一个名为InfoStorage的类用于账号密码的存储 1 2 3 4 5 6 7 8 9 10 11 12 import java.util.HashMap; import java.util.Map; public class InfoStorage { Map\u0026lt;String,String\u0026gt; accountMap = new HashMap\u0026lt;\u0026gt;(); // 创建变量accountMap存储键值对 public InfoStorage() { accountMap.put(\u0026#34;user1\u0026#34;,\u0026#34;123\u0026#34;); accountMap.put(\u0026#34;user2\u0026#34;,\u0026#34;abc\u0026#34;); accountMap.put(\u0026#34;hj\u0026#34;,\u0026#34;1130\u0026#34;); } } 创建一个名为LoginAction的类，并导入相应库，实现接口的类创建一个对象与需要监听的按钮绑定 导入库 1 2 3 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; 创建LoginAction类并使用ActionListener模板 1 public class LoginAction implements ActionListener {} 创建actionPerformed方法 1 2 3 4 5 public void actionPerformed(ActionEvent e){ String ac = e.getActionCommand(); //定义字符串类型的变量ac用于接收button中的内容 System.out.println(\u0026#34;Commend: \u0026#34; + ac); String accountText = accountJTF2.getText(); String passwordText = passwordJTF2.getText(); 回到LoginUI类，现在可以创建对于LoginAction类的新对象la用于为两个按钮（loginBtn 和 registerBtn）添加动作监听器（注意：这里添加的是同一个动作监听器） 1 2 3 4 5 6 7 LoginAction la = new LoginAction(); loginBtn.addActionListener(la); registerBtn.addActionListener(la); //由于同一变量名不能在不同类中共用，所以这里声明LoginAction类中的accountJTF2和passwordJTF2就是accountJTF和accountJTF la.accountJTF2 = accountJTF; la.passwordJTF2 = passwordJTF; 再回到LoginAction类中，在开头添加一下代码 1 2 3 4 //定义刚刚的accountJTF2和passwordJTF2为JTextField类型，并设置为空 JTextField accountJTF2 = null; JTextField passwordJTF2 = null; private InfoStorage storage = new InfoStorage(); //对于之前的InfoStorage库，创建一个对象storage 最后设计判断模块，判断输入的账号密码是否符合登录要求 1 2 3 4 5 6 7 8 9 10 11 12 if(storage.accountMap.containsKey(accountText)) { String correctPassword = storage.accountMap.get(accountText); if (passwordText.equals(correctPassword)) { System.out.println(\u0026#34;登录成功！\u0026#34;); } else { System.out.println(\u0026#34;密码错误！登录失败！\u0026#34;); } } else{ System.out.println(\u0026#34;账号不存在！\u0026#34;); } 实现效果 最终代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //LoginUI.java import java.awt.*; import javax.swing.*; public class LoginUI { public void showUI(){ JFrame jf = new JFrame(); jf.setTitle(\u0026#34;登录窗口\u0026#34;); jf.setSize(270,280); jf.setLocationRelativeTo(null); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); FlowLayout fl = new FlowLayout(); jf.setLayout(fl); ImageIcon img = new ImageIcon(\u0026lt;图片文件地址\u0026gt;); JLabel imgJLa = new JLabel(img); JLabel accountJLa = new JLabel(\u0026#34;账号\u0026#34;); JLabel passwordJLa = new JLabel(\u0026#34;密码\u0026#34;); JTextField accountJTF = new JTextField(20); JTextField passwordJTF = new JTextField(20); JButton loginBtn = new JButton(\u0026#34;登录\u0026#34;); JButton registerBtn = new JButton(\u0026#34;注册\u0026#34;); jf.add(imgJLa); jf.add(accountJLa); jf.add(accountJTF); jf.add(passwordJLa); jf.add(passwordJTF); jf.add(loginBtn); jf.add(registerBtn); jf.setVisible(true); LoginAction la = new LoginAction(); loginBtn.addActionListener(la); registerBtn.addActionListener(la); la.accountJTF2 = accountJTF; la.passwordJTF2 = passwordJTF; } public static void main(String[] args) { LoginUI ui = new LoginUI(); ui.showUI(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //LoginAction.java import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class LoginAction implements ActionListener { JTextField accountJTF2 = null; JTextField passwordJTF2 = null; private InfoStorage storage = new InfoStorage(); public void actionPerformed(ActionEvent e){ String ac = e.getActionCommand(); System.out.println(\u0026#34;Commend: \u0026#34; + ac); String accountText = accountJTF2.getText(); String passwordText = passwordJTF2.getText(); if(storage.accountMap.containsKey(accountText)) { String correctPassword = storage.accountMap.get(accountText); if (passwordText.equals(correctPassword)) { System.out.println(\u0026#34;登录成功！\u0026#34;); } else { System.out.println(\u0026#34;密码错误！登录失败！\u0026#34;); } } else{ System.out.println(\u0026#34;账号不存在！\u0026#34;); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //InfoStorage.java import java.util.HashMap; import java.util.Map; public class InfoStorage { Map\u0026lt;String,String\u0026gt; accountMap = new HashMap\u0026lt;\u0026gt;(); public InfoStorage() { accountMap.put(\u0026#34;user1\u0026#34;,\u0026#34;123\u0026#34;); accountMap.put(\u0026#34;user2\u0026#34;,\u0026#34;abc\u0026#34;); accountMap.put(\u0026#34;hj\u0026#34;,\u0026#34;1130\u0026#34;); } } ","date":"2025-04-24T09:32:40+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8/","title":"事件监听器"},{"content":"窗口基础设置 原理 ： 利用java外部库自带的java.awt和javax.swing软件包来实现\n基本步骤： 创建一个新的类（例如LoginUI） 在这个类中定义一个方法（例如showUI(),用于开发界面） 导入java.awt和javax.swing两个界面开发包 在末尾创建一个主函数main，在其中创建LoginUI的对象（例如ui）并调用之前的showUI()方法） 细节步骤 使用import语句导入两个界面开发包，末尾.*代表导入该软件包中的所有类 1 2 import java.awt.*; import javax.swing.*; 在创建定义完方法showUI()之后，即可创建一个窗体类对象jf，利用刚刚导入的javax.swing中的JFrame进行创建 1 JFrame jf = new JFrame(); 设置窗体的属性 1 2 3 4 jf.setTitle(\u0026#34;登录窗口\u0026#34;); //设置窗口标题 jf.setSize(400, 500); //设置窗口大小 jf.setLocation(600, 200); //设置窗口位置 jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //点击关闭按钮时，java程序终止 设置窗口内的布局\n首先创建布局器对象（这里使用java.awt包内的FlowLayout类进行创建） 1 FlowLayout fl = new FlowLayout(); 添加图片（需要将图片传到标签Label上呈现） 1 2 ImageIcon img = new ImageIcon(\u0026lt;图片文件地址\u0026gt;); JLabel imgJla = new JLabel(img); 添加标签（文字） 1 2 JLabel nameJla = new JLabel(\u0026#34;账号：\u0026#34;); JLabel pwdJla = new JLabel(\u0026#34;密码：\u0026#34;); 添加单行文本输入框 1 JTextField nameJtf = new JTextField(35); // 输入框可以显示30个字符宽度，每个字符约10像素 添加按钮 1 JButton loginBtn = new JButton(\u0026#34;登录\u0026#34;); 将上面创建的布局组件全部添加到窗体对象jf中\n1 2 3 4 5 6 jf.add(imgJla); jf.add(nameJla); jf.add(nameJtf); jf.add(pwdJla); jf.add(pwdJtf); jf.add(loginBtn); 可视化 1 jf.setVisible(true); ","date":"2025-04-23T16:00:03+08:00","permalink":"https://ferdinandhu.netlify.app/p/%E7%AA%97%E5%8F%A3%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE/","title":"窗口基础设置"}]