[{"content":"Encoding Types 1. Base64 Definition: A representation method that uses 64 printable characters to represent binary data Features: Converts binary data into ASCII strings Commonly used to transmit binary data in HTTP protocols The encoded data increases by approximately 33% compared to the original data Application Scenarios: Email transmission Image transcoding Simple data encryption Examples: 1 2 3 4 5 Original text: Hello World Base64 encoding: SGVsbG8gV29ybGQ= Original text: 你好，世界 Base64 encoding: 5L2g5aW977yM5LiW55WM 2. URL Encoding Definition: Converts special characters in URLs into the form of % plus the hexadecimal of the ASCII code Features: Ensures that only ASCII characters are included in the URL Reversible encoding method Application Scenarios: URL parameter passing Web form submission Example: 1 2 Original URL: https://example.com/path with spaces/file.txt URL encoding: https%3A%2F%2Fexample.com%2Fpath%20with%20spaces%2Ffile.txt 3. Code49 Definition: A high-density barcode encoding method that can encode all 128 ASCII characters Features: Supports multi-line encoding Up to 8 characters per line Includes a checksum Supports bidirectional scanning Application Scenarios: Logistics management Inventory control Industrial automation Medical device identification 4. Code39 Definition: An alphanumeric barcode encoding method that can encode 43 characters (0-9, A-Z, -, ., $, /, +, %, SPACE) Features: Self-checking capability Bidirectional readability Supports letters and numbers Must start and end with an asterisk (*) Application Scenarios: Industrial applications Logistics management Inventory control Document management Encoding Rules: Each character consists of 9 elements (5 bars and 4 spaces) 3 elements are wide, and 6 elements are narrow Inter-character spacing is required Must start and end with an asterisk (*) Encryption Algorithms 1. Symmetric Encryption 1.1 AES (Advanced Encryption Standard) Features: Key lengths: 128/192/256 bits High encryption strength Fast calculation speed Application Scenarios: File encryption Communication encryption Database encryption 1.2 DES (Data Encryption Standard) Features: Key length: 56 bits Block length: 64 bits Has been replaced by AES Application Scenarios: Compatibility with legacy systems Scenarios with low security requirements 2. Asymmetric Encryption 2.1 RSA Features: Based on the difficulty of factoring large numbers Public key encryption, private key decryption Relatively slow calculation speed Application Scenarios: Digital signatures Key exchange Certificate encryption 2.2 ECC (Elliptic Curve Cryptography) Features: Short key length High security Fast calculation speed Application Scenarios: Mobile device encryption Internet of Things (IoT) devices Digital certificates 3. Hashing Algorithms 3.1 MD5 Features: Outputs a 128-bit hash value Has been proven insecure Fast calculation speed Application Scenarios: File integrity checking Password storage (not recommended) 3.2 SHA Series Features: SHA-1: 160-bit output SHA-256: 256-bit output SHA-512: 512-bit output Application Scenarios: Digital signatures Password storage File verification Implementing Base64 Encoding and Decoding in Java Import Java\u0026rsquo;s built-in Base64 class 1 2 import java.nio.charset.StandardCharsets; import java.util.Base64; Encoding 1 2 3 4 5 6 7 8 9 10 11 // Encoding public static String encode2(String str) { // Only encode non-null strings if (str != null \u0026amp;\u0026amp; str.length() \u0026gt; 0) { // Convert String to byte[] byte[] bytes = str.getBytes(StandardCharsets.UTF_8); // Encode (Base64 string) return Base64.getEncoder().encodeToString(bytes); } return \u0026#34;\u0026#34;; } Decoding 1 2 3 4 5 6 7 8 9 10 11 // Decoding public static String decode2(String base64Str) { // Only decode non-null strings if (base64Str != null \u0026amp;\u0026amp; base64Str.length() \u0026gt; 0) { // Decode byte[] base64Bytes = Base64.getDecoder().decode(base64Str); // Convert byte[] to String (decoded string) return new String(base64Bytes, StandardCharsets.UTF_8); } return \u0026#34;\u0026#34;; } Test code 1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) { // Define a string String s = \u0026#34;FerdinandHu\u0026#34;; // Use method two to perform Base64 encoding on the string String base64Str = encode2(s); // Output the original string System.out.println(\u0026#34;Original text: \u0026#34; + s); // Output the Base64-encoded string System.out.println(\u0026#34;Base64 encoded: \u0026#34; + base64Str); // Use method two to decode the Base64-encoded string System.out.println(\u0026#34;Base64 decoded: \u0026#34; + decode2(base64Str)); } Output 1 2 3 Original text: FerdinandHu Base64 encoded: RmVyZGluYW5kSHU= Base64 decoded: FerdinandHu ","date":"2025-05-30T11:29:16+08:00","permalink":"https://ferdinandhu.netlify.app/en/p/common-encryption-algorithms-and-encoding-types/","title":"Common Encryption Algorithms and Encoding Types"},{"content":"两个重要接口 Comparable Interface Comparator Interface Comparable Interface 对于Arrays.sort()函数，需要待排序的数组有排序标准\n对于下面Java代码\n1 2 3 4 5 6 7 Person[] persons = new Person[3]; persons[0] = new Person(\u0026#34;Han Mei\u0026#34;); persons[1] = new Person(\u0026#34;Li Lei\u0026#34;); persons[2] = new Person(\u0026#34;Tom\u0026#34;); Arrays.sort(persons); for (Person p : persons) System.out.println(p); 会有\n1 Person cannot be cast to java.lang.Comparable 报错信息，因此需要传入排序标准\nComparable接口原理：\n1 2 3 public interface Comparable { int compareTo(Object other); } 通过返回int类型的值来判断this与other的大小关系\nint \u0026lt; 0, if this \u0026lt; other\nint = 0, if this = other\nint \u0026gt; 0, if this \u0026gt; other\n具体实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Person implements Comparable{ private String name; public Person(String name) { this.name = name; } public String toString() { return \u0026#34;A person \u0026#34; + name; } // 对接口中的抽象函数进行复写 public int compareTo(Object o) { Person p = (Person)o; return name.compareTo(p.name); } } public static void main(String[] args) { Person[] persons = new Person[3]; persons[0] = new Person(\u0026#34;Han Mei\u0026#34;); persons[1] = new Person(\u0026#34;Li Lei\u0026#34;); persons[2] = new Person(\u0026#34;Tom\u0026#34;); // 使用sort函数进行排序 Arrays.sort(persons); for (Person p : persons) System.out.println(p); } 对于从父类继承来的子类对象，也可以继承其接口功能\n如果需要改变排序标准，可以重写其抽象方法\nComparator Interface Comparator接口原理\n1 2 3 4 public interface Comparator\u0026lt;T\u0026gt; { int compare(T first, T second); } 具体实现\n1 2 3 4 5 6 // 创建一个临时的类，其中补全Comparator的抽象方法 class CompareStuMajorAsc implements Comparator\u0026lt;Student\u0026gt; { public int compare(Student p1, Student p2) { return p1.getName().compareTo(p2.getName()); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 Student[] stus = new Student[3]; stus[0] = new Student(\u0026#34;Han Mei\u0026#34;, \u0026#34;E-Commerce\u0026#34;); stus[1] = new Student(\u0026#34;Li Lei\u0026#34;, \u0026#34;Bioinfomatics\u0026#34;); stus[2] = new Student(\u0026#34;Tom\u0026#34;, \u0026#34;Computer Science\u0026#34;); // Student类继承Person的接口，默认按照name排序 Arrays.sort(stus); for (Student p : stus) System.out.println(p); // new CompareStuNameAsc() 传入新排序标准，按major名称排序 Arrays.sort(stus, new CompareStuMajorAsc()); for (Student p : stus) System.out.println(p); 若需要改成降序排列，只需要改动临时类中return的代码\n1 2 3 4 5 class CompareStuNameDes implements Comparator\u0026lt;Student\u0026gt; { public int compare(Student p1, Student p2) { return p2.getName().compareTo(p1.getName()); // 将p2移前 } } 代码简化 v1 使用内部类，即将原先的单独的临时类放到主函数中\n1 2 3 4 5 6 7 8 9 10 // 简化前 class CompareIntDes implements Comparator\u0026lt;Integer\u0026gt; { public int compare(Integer i, Integer j) { return j - i; } } Integer[] intArr = new Integer[] {3, 1, 2}; Arrays.sort(intArr, new CompareIntDes()); for (int i : intArr) System.out.println(i); 1 2 3 4 5 6 7 8 9 // 简化后 Integer[] intArr = new Integer[] {3, 1, 2}; Arrays.sort(intArr, new Comparator\u0026lt;Integer\u0026gt;() { // 将临时类放在sort函数中 public int compare(Integer i, Integer j) { return j - i; } }); for (int i : intArr) System.out.println(i); 代码简化 v2 使用Lambda表达式简化代码量\n1 2 3 4 5 6 7 // 简化前 // 使用内部类 Arrays.sort(stus, new Comparator\u0026lt;Student\u0026gt;() { public int compare(Student s1, Student s2) { return s2.getMajor().compareTo(s1.getMajor()); } }); 1 2 // 简化后 Arrays.sort(stus, (s1,s2) -\u0026gt; s2.getMajor().compareTo(s1.getMajor())); 可用一行函数完成\n注意： 使用Lambda表达式可以看作没有使用任何一个接口，其中的.compareTo()方法是String类中自带的方法\n","date":"2025-05-19T21:05:05+08:00","permalink":"https://ferdinandhu.netlify.app/en/p/interface/","title":"Interface"},{"content":"Java Object-Oriented Programming (OOP) Contents Object-Oriented Programming What is Object-Oriented Programming Object-Oriented vs Procedural Programming Classes and Objects Definition and Usage Constructors Simplest Form of Class Definition in Java Keywords: public, private, static, final public and private static final Three Pillars of Object-Oriented Programming 1. Encapsulation 2. Inheritance 3. Polymorphism Object-Oriented Programming What is Object-Oriented Programming In simple terms, object-oriented programming is the process of encapsulating attributes and methods into individual objects.\nObject-Oriented vs Procedural Programming Feature Object-Oriented (OOP) Procedural (POP) Focus Data encapsulation Function implementation Use Case Complex system development Small program development Maintainability High Low Code Reusability Strong Weak Classes and Objects Definition and Usage Class: A blueprint for objects\nIncludes: attributes and methods Object: An instance of a class Example: Class: Person Objects: Student, Teacher Constructors Syntax: public ClassName (parameters) {}\n1 2 3 4 5 6 7 8 9 10 class Employee { // Attributes private static String name; private double salary; private LocalDate hireDay; // Default no-argument constructor public Employee() { } } Using the this keyword to access current object\u0026rsquo;s attributes and methods\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Employee { private String name; private double salary; private LocalDate hireDay; // Default constructor public Employee() { } // Parameterized constructor public Employee(String name, double salary, int year, int month, int day) { this.name = name; this.salary = salary; this.hireDay = LocalDate.of(year, month, day); } } Note: A class can have multiple constructors (overloading)\nSimplest Form of Class Definition in Java 1 2 3 4 5 6 7 8 9 10 11 class ClassName { attribute1; attribute2; ... constructor1(); constructor2(); ... method1(); method2(); ... } Keywords: public, private, static, final public and private Both are access modifiers used to restrict or allow access to class members. They can modify classes, attributes, and methods. public: Members are accessible throughout the project. private: Members are completely private and cannot be accessed from outside the class. static Indicates a static member. Can modify classes, methods, and code blocks. Characteristics: When modifying an attribute, the attribute is stored only once in memory. Can be accessed via ClassName.attributeName without creating an instance.\nExample: Math.PI When modifying a method, the method can be called via ClassName.methodName.\nExample: Math.sin()\nHowever, non-static members cannot be directly accessed within static methods. 1 2 3 4 5 6 7 8 9 class Test { String name; public static int id; public static void showInfo1() { System.out.println(\u0026#34;id:\u0026#34; + id); // id is static, no error System.out.println(\u0026#34;name:\u0026#34; + name); // name is not static, this line will cause an error! } } When modifying a code block, the static block executes once when the class is loaded. 1 2 3 4 5 6 7 static { System.out.println(\u0026#34;Static code block\u0026#34;); // Executes once when the class is first loaded } { System.out.println(\u0026#34;Instance code block\u0026#34;); // Executes every time an instance is created } final Indicates that the modified member cannot be changed. Characteristics: When modifying a variable, it must be initialized and cannot be reassigned. When modifying a method, the method cannot be overridden by subclasses. When modifying a class, the class cannot be inherited. Three Pillars of Object-Oriented Programming 1. Encapsulation Access Scope private default protected public Same class in same package √ √ √ √ Different class in same package √ √ √ Subclass in different package √ √ Non-subclass in different package √ 2. Inheritance Meaning: Creating a new class (subclass) based on an existing class (superclass) to reuse code and add new attributes and methods. Implementation: Use the extends keyword when defining a class.\nSyntax: public class SubclassName extends SuperclassName {}\nUse the super keyword to access superclass members. 1 2 3 4 5 6 7 8 9 10 11 // Superclass Employee public class Employee { private String name = \u0026#34;Hanmei\u0026#34;; private double salary; public Employee(String name, double salary) {} // Constructor public String getName() {} public double raiseSalary(double byPercent) {} public double getSalary() {} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // Subclass Manager public class Manager extends Employee { // New attribute added to the subclass private double bonus; public Manager(String name, double salary) { super(name, salary); // Call superclass constructor } public void setBonus(double bonus) { this.bonus = bonus; } // Override the getSalary() method public double getSalary() { return super.getSalary() + bonus; // Call superclass method } } Characteristics of Inheritance: Multiple levels of inheritance are allowed: Person \u0026lt;-- Employee \u0026lt;-- Manager Multiple branches of inheritance are possible 3. Polymorphism Meaning: In an inheritance hierarchy, when a subclass overrides a method of the superclass, calling the method on a subclass object will execute the subclass\u0026rsquo;s implementation.\nImplementation: Referring to the inheritance example above, when executing the following code:\n1 2 3 4 Employee Alice = new Manager(\u0026#34;Alice\u0026#34;,10000); // Declared type is Employee, actual type is Manager Alice.setBonus(5000); Alice.getSalary(); The program will output 15000 instead of 10000, because the overridden method in Manager is called, even though Alice is declared as an Employee.\nSpecial Note: For the following code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class SuperClass { void method1() {System.out.println(\u0026#34;SuperClass.method1\u0026#34;);} void method2() {System.out.println(\u0026#34;SuperClass.method2\u0026#34;);} } class SubClass extends SuperClass { void method2() {System.out.println(\u0026#34;SubClass.method2\u0026#34;);} void method3() {System.out.println(\u0026#34;SubClass.method3\u0026#34;);} } public static void main(String[] args) { SuperClass superC = new SuperClass(); SubClass subC = new SubClass(); SuperClass polyC = new SubClass(); // Declared type is SuperClass, actual type is SubClass superC.method1(); superC.method2(); superC.method3(); subC.method1(); subC.method2(); subC.method3(); polyC.method1(); polyC.method2(); polyC.method3(); } The output will be:\n1 2 3 4 5 6 7 8 9 SuperClass.method1 SuperClass.method2 method3() undefined SuperClass.method1 SubClass.method2 SubClass.method3 SuperClass.method1 SubClass.method2 method3() undefined // Although the actual type is SubClass, the compiler only checks the declared type which is SuperClass Advantages of Polymorphism:\nReduces code complexity by avoiding excessive if-else statements, improving code readability. Enhances code extensibility and reduces modification costs. ","date":"2025-05-17T14:16:37+08:00","permalink":"https://ferdinandhu.netlify.app/en/p/java-object-oriented-programming/","title":"Java Object-Oriented Programming"},{"content":"Interface of Java Concept: An interface is a special type of class where all variables are implicitly public static final and all methods are abstract (without method bodies). It serves as a contract that defines a set of methods that a class must implement, ensuring uniformity and standardization. Interfaces can be seen as a protocol that classes must adhere to, specifying the methods they must provide. Differences Between Interfaces and Classes Keywords: Uses interface instead of class (implementing an interface can be considered a special form of inheritance). Variables: All variables in an interface are implicitly public static final. Methods: All methods in an interface are implicitly public abstract and lack method bodies. Inheritance: A class can implement multiple interfaces but can only inherit from one superclass. Interface Inheritance: An interface can inherit from multiple interfaces. Implementing an Interface Declaring an Interface: Use the interface keyword to define an interface (e.g., USB). 1 2 3 4 5 6 7 // Define the USB interface with two abstract methods: input and output public interface USB { // Input method void input(); // Output method void output(); } Implementing an Interface: Use the implements keyword in a class to implement an interface and provide implementations for all abstract methods. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Keyboard class implements the USB interface class Keyboard implements USB { // Get string input from the keyboard public String getString() { return \u0026#34;String obtained from keyboard\u0026#34;; } // Implement the input method from the USB interface // Used to receive power from USB @Override public void input() { System.out.println(\u0026#34;Receiving power from USB\u0026#34;); } // Implement the output method from the USB interface // Used to output the string obtained from the keyboard @Override public void output() { System.out.println(\u0026#34;Sending string from keyboard: \u0026#34; + getString()); } } Key Notes Access Modifier: Methods in an interface are implicitly public and cannot be declared with a more restrictive access modifier. Implementation Requirement: A class implementing an interface must provide implementations for all abstract methods defined in the interface. Default and Static Methods: Interfaces can include default methods (default) and static methods (static). No Constructors: Interfaces cannot contain constructors. Variables: Variables in an interface are implicitly public static final (constants). ","date":"2025-05-17T14:16:07+08:00","permalink":"https://ferdinandhu.netlify.app/en/p/interface-of-java/","title":"Interface of Java"},{"content":"Interactive Drawing Board v3.0 Implement a feature - rich interactive drawing board using Java. Based on version 2.0, more advanced features are added, including brush thickness adjustment, RGB color adjustment, etc., and the interface layout is optimized.\nFunction Introduction of Each Class DrawPadv3 class: Responsible for creating and initializing the graphical interface of the drawing board, including the layout of various control panels and component settings. DrawListener class: Implements the MouseListener, ActionListener, and ChangeListener interfaces, used to handle mouse events, button click events, and slider value change events. Specific Implementations 1. Interface Layout Design 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public void showUI() { // Create the main window JFrame jf = new JFrame(); jf.setTitle(\u0026#34;Drawing Board v3.0\u0026#34;); jf.setSize(1000, 800); jf.setLocationRelativeTo(null); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Create various panels JPanel topCtrlJP = new JPanel(); // Top control panel JPanel shapeBtnJP = new JPanel(); // Shape button panel JPanel otherCtrlJP = new JPanel(); // Other control panel JPanel drawJP = new JPanel(); // Drawing panel JPanel penCtrlJP = new JPanel(); // Brush control panel JPanel strokeWidthJslJP = new JPanel();// Brush thickness slider panel JPanel colorBtnJP = new JPanel(); // Color button panel JPanel colorJslJP = new JPanel(); // Color slider panel By creating multiple panels, a clearer interface layout is achieved:\nTop control panel: Used to place basic control buttons. Left - side shape button panel: Used to select drawing tools. Central drawing panel: The main drawing area. Bottom control panel: Contains brush thickness adjustment and color selection functions. 2. Brush Control Function 1 2 3 4 5 6 7 8 9 10 11 12 public void initStrokeWidthJp(JPanel fontSizeJp) { JSlider sliderSize = new JSlider(JSlider.HORIZONTAL, 0, 20, 1); sliderSize.setMajorTickSpacing(4); sliderSize.setPaintLabels(true); sliderSize.addChangeListener(dl); JLabel labelSize = new JLabel(\u0026#34;Brush Size: \u0026#34; + 1); fontSizeJp.add(labelSize); fontSizeJp.add(sliderSize); dl.setStrokeWidthComponent(sliderSize, labelSize); } The real - time adjustment function of the brush thickness is implemented:\nUse the JSlider component to create a thickness adjustment slider. The range is from 0 to 20, with a step of 1. Add scale marks and numerical labels. Update the brush thickness in real - time through the ChangeListener. 3. RGB Color Adjustment 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void initColorJslJp(JPanel colorJslJp) { // Create RGB color sliders JSlider sliderR = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); JSlider sliderG = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); JSlider sliderB = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); // Set slider scales sliderR.setMajorTickSpacing(50); sliderG.setMajorTickSpacing(50); sliderB.setMajorTickSpacing(50); sliderR.setPaintLabels(true); sliderG.setPaintLabels(true); sliderB.setPaintLabels(true); } The RGB color adjustment function is added:\nCreate sliders for the red, green, and blue channels respectively. The range is from 0 to 255, with a step of 1. Add scale marks and numerical labels. Provide real - time color preview. 4. Event Handling 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public void stateChanged(ChangeEvent e) { JSlider slider = (JSlider) e.getSource(); int value = slider.getValue(); int sliHashCode = slider.hashCode(); // Handle the brush thickness slider if (sliHashCode == jslFontSize.hashCode()) { fontSize = value; Graphics2D g2d = (Graphics2D) g; BasicStroke stroke = new BasicStroke(fontSize); g2d.setStroke(stroke); labelFontSize.setText(\u0026#34;Brush Size: \u0026#34; + fontSize); } // Handle the color sliders else { if (sliHashCode == sliderR.hashCode()) { red = value; labelR.setText(\u0026#34;Red: \u0026#34; + red); } else if (sliHashCode == sliderG.hashCode()) { green = value; labelG.setText(\u0026#34;Green: \u0026#34; + green); } else if (sliHashCode == sliderB.hashCode()) { blue = value; labelB.setText(\u0026#34;Blue: \u0026#34; + blue); } Color color = new Color(red, green, blue); g.setColor(color); jslColorBtn.setBackground(color); } } A complete event - handling mechanism is implemented:\nHandle slider value change events to update the brush thickness and color. Handle button click events to switch drawing tools and colors. Handle mouse events to achieve graphic drawing. 5. Drawing Function 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Override public void mouseReleased(MouseEvent e) { x2 = e.getX(); y2 = e.getY(); // Perform corresponding drawing operations according to different drawing types if (type.equals(\u0026#34;Line\u0026#34;)) { g.drawLine(x1, y1, x2, y2); } else if (type.equals(\u0026#34;Rectangle\u0026#34;)) { g.drawRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Circle\u0026#34;)) { g.drawOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } //... Other graphic drawing code } Supports the drawing of multiple graphics:\nBasic graphics such as lines, rectangles, and circles. Solid and hollow graphics. Isosceles triangles and their variants. Eraser function. 6. Eraser Function The implementation principle of the eraser function is very simple but practical:\nWhen the user selects the eraser tool, the program sets the brush color to white (Color.white). Since the background color of the drawing board is also white, when the user draws with the eraser tool, it actually covers the original graphics with white. The advantages of this implementation method are: No additional memory is required to store the drawing history. Specific areas can be accurately erased. The erasing effect is consistent with the brush thickness setting. 7. Clear Function The clear function provides the ability to clear the entire drawing board with one click:\nImplementation principle: Fill the entire drawing board area with white. Specific steps: Save the current brush color (Color currentColor = g.getColor()). Set the brush color to white (g.setColor(Color.WHITE)). Use the fillRect method to fill the entire drawing board area (g.fillRect(0, 0, 1000, 800)). Restore the original brush color (g.setColor(currentColor)). The advantages of this implementation method are: Simple operation, completed with one click. Does not affect the current brush settings (color, thickness, etc.). Allows for a quick start of a new drawing. Main Improvements Interface layout optimization: Use multiple panels to achieve a clearer interface structure. Enhanced brush control: Add a brush thickness adjustment function. Upgraded color system: Support RGB color adjustment and preset color selection. Improved event handling: Add handling of slider value change events. Optimized code structure: Clearer class design and function division. Instructions Select a drawing tool: Click the tool buttons in the left - hand panel. Adjust the brush thickness: Use the thickness slider at the bottom. Select a color: Use the preset color buttons. Use the RGB sliders to adjust custom colors. Draw a graphic: Hold down the mouse and drag in the central drawing area. Use the eraser: After selecting the eraser tool, drag in the area to be erased. Clear the drawing board: Click the \u0026ldquo;Clear\u0026rdquo; button in the left - hand panel to clear all drawn content with one click. Final Effect Final Code DrawPadv3.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 package basic.hj0510; import javax.swing.*; import java.awt.*; /** * The main class of the drawing board program. * Responsible for creating and initializing the graphical interface of the drawing board. * Implements the following main functions: * 1. Create the main window and various functional panels. * 2. Set the layout and size of the panels. * 3. Initialize various control components (buttons, sliders, etc.). * 4. Assemble the interface components. * 5. Add event listeners. */ public class DrawPadv3 { // Create an instance of the drawing listener to handle all user interaction events DrawListener dl = new DrawListener(); /** * Display the drawing board interface. * Initialize all UI components and set the layout. * Main steps: * 1. Create the main window and set its basic properties. * 2. Create and configure various functional panels. * 3. Set the layout and size of the panels. * 4. Initialize the control components. * 5. Assemble the interface. * 6. Add event listeners. */ public void showUI() { // Create the main window and set its basic properties JFrame jf = new JFrame(); jf.setTitle(\u0026#34;Drawing Board v3.0\u0026#34;); jf.setSize(1000, 800); // Set the window size to 1000x800 pixels jf.setLocationRelativeTo(null); // Center the window on the screen jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Exit the program when the window is closed // Create various functional panels JPanel topCtrlJP = new JPanel(); // Top control panel: used to place basic control buttons JPanel shapeBtnJP = new JPanel(); // Shape button panel: used to select drawing tools JPanel otherCtrlJP = new JPanel(); // Other control panel: contains the drawing area and other control components JPanel drawJP = new JPanel(); // Drawing panel: the main drawing area JPanel penCtrlJP = new JPanel(); // Brush control panel: contains brush thickness and color control JPanel strokeWidthJslJP = new JPanel();// Brush thickness slider panel: used to adjust the brush thickness JPanel colorBtnJP = new JPanel(); // Color button panel: used to select preset colors JPanel colorJslJP = new JPanel(); // Color slider panel: used for RGB color adjustment // Set the size of each panel Dimension dim_topCtrlJP = new Dimension(1100, 30); // Size of the top control panel Dimension dim_shapeBtnJP = new Dimension(120, 570); // Size of the shape button panel Dimension dim_otherCtrlJP = new Dimension(900, 570); // Size of the other control panel Dimension dim_penCtrlJP = new Dimension(900, 150); // Size of the brush control panel Dimension dim_strokeWidthJslJP = new Dimension(260, 150);// Size of the brush thickness slider panel Dimension dim_colorBtnJP = new Dimension(360, 150); // Size of the color button panel Dimension dim_colorJslJP = new Dimension(280, 150); // Size of the color slider panel // Apply the size settings to each panel topCtrlJP.setPreferredSize(dim_topCtrlJP); shapeBtnJP.setPreferredSize(dim_shapeBtnJP); otherCtrlJP.setPreferredSize(dim_otherCtrlJP); penCtrlJP.setPreferredSize(dim_penCtrlJP); strokeWidthJslJP.setPreferredSize(dim_strokeWidthJslJP); colorBtnJP.setPreferredSize(dim_colorBtnJP); colorJslJP.setPreferredSize(dim_colorJslJP); // Set the layout manager of the panels topCtrlJP.setLayout(new BorderLayout()); // Use border layout otherCtrlJP.setLayout(new BorderLayout()); // Use border layout penCtrlJP.setLayout(new BorderLayout()); // Use border layout // Set the background color of each panel topCtrlJP.setBackground(Color.LIGHT_GRAY); // Light gray background shapeBtnJP.setBackground(Color.DARK_GRAY); // Dark gray background drawJP.setBackground(Color.WHITE); // White background strokeWidthJslJP.setBackground(Color.LIGHT_GRAY);// Light gray background colorBtnJP.setBackground(Color.LIGHT_GRAY); // Light gray background // Assemble the panels to build the interface hierarchy penCtrlJP.add(strokeWidthJslJP, BorderLayout.WEST); // Place the brush thickness control on the left penCtrlJP.add(colorBtnJP, BorderLayout.EAST); // Place the color buttons on the right penCtrlJP.add(colorJslJP, BorderLayout.CENTER); // Place the color sliders in the middle otherCtrlJP.add(penCtrlJP, BorderLayout.SOUTH); // Place the brush control panel at the bottom otherCtrlJP.add(drawJP, BorderLayout.CENTER); // Place the drawing area in the middle jf.add(topCtrlJP, BorderLayout.NORTH); // Place the control panel at the top jf.add(shapeBtnJP, BorderLayout.WEST); // Place the shape buttons on the left jf.add(otherCtrlJP, BorderLayout.CENTER); // Place the other control panel in the middle // Initialize the components of each functional panel initColorBtnJp(colorBtnJP); // Initialize the color buttons initColorJslJp(colorJslJP); // Initialize the color sliders initStrokeWidthJp(strokeWidthJslJP);// Initialize the brush thickness control initShapeBtnJp(shapeBtnJP); // Initialize the shape buttons jf.setVisible(true); // Display the window // Add a mouse listener to the drawing panel to handle drawing operations drawJP.addMouseListener(dl); // Get the Graphics object of the drawing panel and pass it to the listener Graphics g = drawJP.getGraphics(); dl.g = g; } /** * Initialize the shape button panel. * Create buttons for various drawing tools. * Include basic graphic tools such as lines, circles, rectangles, etc. * And special tools such as solid graphics and erasers. */ public void initShapeBtnJp(JPanel shapeBtnJp) { // Define all available drawing tools String[] btnType = {\u0026#34;Line\u0026#34;, \u0026#34;Circle\u0026#34;, \u0026#34;Rectangle\u0026#34;, \u0026#34;Solid Circle\u0026#34;, \u0026#34;Solid Rectangle\u0026#34;, \u0026#34;Isosceles Triangle\u0026#34;, \u0026#34;Solid Isosceles Triangle\u0026#34;, \u0026#34;Eraser\u0026#34;, \u0026#34;Clear\u0026#34;}; // Loop to create buttons and add them to the panel for (int i = 0; i \u0026lt; btnType.length; i++) { JButton btn = new JButton(btnType[i]); shapeBtnJp.add(btn); btn.addActionListener(dl); // Add an action listener } } /** * Initialize the color button panel. * Create buttons for preset colors. * Include 13 basic colors such as black, red, green, etc. */ public void initColorBtnJp(JPanel colorBtnJp) { // Define an array of preset colors, containing 13 common colors Color[] btnColors = {Color.BLACK, Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.CYAN, Color.MAGENTA, Color.GRAY, Color.LIGHT_GRAY, Color.DARK_GRAY, Color.PINK, Color.ORANGE, Color.WHITE}; // Create color buttons Dimension cDim = new Dimension(20, 20); // Set the button size to 20x20 pixels for(int i = 0 ; i \u0026lt; btnColors.length ; i++) { JButton btn = new JButton(); btn.setActionCommand(\u0026#34;ColorBtn\u0026#34;); // Set the button command btn.setBackground(btnColors[i]); // Set the button background color colorBtnJp.add(btn); btn.setPreferredSize(cDim); // Set the button size btn.addActionListener(dl); // Add an action listener } } /** * Initialize the brush thickness control panel. * Create a brush thickness slider and a label. * Implement the real - time adjustment function of the brush thickness. */ public void initStrokeWidthJp(JPanel fontSizeJp) { // Create a brush thickness slider, range 0 - 20, step 1 JSlider sliderSize = new JSlider(JSlider.HORIZONTAL, 0, 20, 1); sliderSize.setMajorTickSpacing(4); // Set the main scale interval sliderSize.setPaintLabels(true); // Display scale labels sliderSize.addChangeListener(dl); // Add a value change listener // Create a label to display the current brush thickness JLabel labelSize = new JLabel(\u0026#34;Brush Size: \u0026#34; + 1); // Add components to the panel fontSizeJp.add(labelSize); fontSizeJp.add(sliderSize); // Pass the components to the listener dl.setStrokeWidthComponent(sliderSize, labelSize); } /** * Initialize the color slider panel. * Create RGB color adjustment sliders and a color preview button. * Implement the precise color adjustment function. */ public void initColorJslJp(JPanel colorJslJp) { // Create sliders for the three RGB color channels JSlider sliderR = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); // Red channel JSlider sliderG = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); // Green channel JSlider sliderB = new JSlider(JSlider.HORIZONTAL, 0, 255, 1); // Blue channel // Set the slider scales sliderR.setMajorTickSpacing(50); // Set the main scale interval to 50 sliderG.setMajorTickSpacing(50); sliderB.setMajorTickSpacing(50); sliderR.setPaintLabels(true); // Display scale labels sliderG.setPaintLabels(true); sliderB.setPaintLabels(true); // Add value change listeners sliderR.addChangeListener(dl); sliderG.addChangeListener(dl); sliderB.addChangeListener(dl); // Create labels to display the current RGB values JLabel labelR = new JLabel(\u0026#34;R: \u0026#34; + 1); JLabel labelG = new JLabel(\u0026#34;G: \u0026#34; + 1); JLabel labelB = new JLabel(\u0026#34;B: \u0026#34; + 1); // Add components to the panel colorJslJp.add(labelR); colorJslJp.add(sliderR); colorJslJp.add(labelG); colorJslJp.add(sliderG); colorJslJp.add(labelB); colorJslJp.add(sliderB); // Create a color preview button JButton jslColorBtn = new JButton(); jslColorBtn.setActionCommand(\u0026#34;ColorBtn\u0026#34;); jslColorBtn.setBackground(Color.BLACK); // Set the initial color to black jslColorBtn.setPreferredSize(new Dimension(200, 30)); // Set the button size colorJslJp.add(jslColorBtn); jslColorBtn.addActionListener(dl); dl.jslColorBtn = jslColorBtn; // Pass the button reference to the listener // Pass the color - related components to the listener dl.setJslComponent(sliderR, sliderG, sliderB, labelR, labelG, labelB); } /** * The entry point of the program. * Create an instance of the drawing board and display the interface. */ public static void main(String[] args) { DrawPadv3 dp = new DrawPadv3(); dp.showUI(); } } DrawListener.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 package basic.hj0510; import javax.swing.*; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; /** * Drawing listener class * Implements MouseListener, ActionListener, and ChangeListener * Handles all interactive events for the drawing board, including: * 1. Mouse events: Handle drawing operations * 2. Button events: Handle tool selection and color selection * 3. Slider events: Handle brush thickness and color adjustment */ public class DrawListener implements MouseListener, ActionListener, ChangeListener { // Graphics object for performing actual drawing operations public Graphics g; // Coordinates where the mouse is pressed and released, used to determine the position and size of the graphic int x1, y1, x2, y2; // Currently selected drawing type, default is line String type = \u0026#34;Line\u0026#34;; // Color-related components and variables int red = 1, green = 1, blue = 1; // RGB color values, initialized to 1 JSlider sliderR, sliderG, sliderB; // RGB color sliders JLabel labelR, labelG, labelB; // Labels to display RGB color values JButton jslColorBtn; // Color preview button /** * Sets the color-related components * Saves references to the RGB sliders and labels in the listener */ public void setJslComponent(JSlider sliderR, JSlider sliderG, JSlider sliderB, JLabel labelR, JLabel labelG, JLabel labelB) { this.sliderR = sliderR; this.sliderG = sliderG; this.sliderB = sliderB; this.labelR = labelR; this.labelG = labelG; this.labelB = labelB; } // Brush thickness-related components int fontSize = 1; // Brush thickness value, initialized to 1 JSlider jslFontSize; // Brush thickness slider JLabel labelFontSize; // Label to display brush thickness /** * Sets the brush thickness-related components * Saves references to the slider and label in the listener */ public void setStrokeWidthComponent(JSlider sliderSize, JLabel labelSize) { this.jslFontSize = sliderSize; this.labelFontSize = labelSize; } /** * Handles slider value change events * Updates color and brush thickness * Performs different update operations based on the slider type */ public void stateChanged(ChangeEvent e) { JSlider slider = (JSlider) e.getSource(); int value = slider.getValue(); int sliHashCode = slider.hashCode(); // Handle brush thickness slider if (sliHashCode == jslFontSize.hashCode()) { fontSize = value; Graphics2D g2d = (Graphics2D) g; BasicStroke stroke = new BasicStroke(fontSize); g2d.setStroke(stroke); labelFontSize.setText(\u0026#34;Brush Size: \u0026#34; + fontSize); } // Handle color sliders else { if (sliHashCode == sliderR.hashCode()) { red = value; labelR.setText(\u0026#34;Red: \u0026#34; + red); } else if (sliHashCode == sliderG.hashCode()) { green = value; labelG.setText(\u0026#34;Green: \u0026#34; + green); } else if (sliHashCode == sliderB.hashCode()) { blue = value; labelB.setText(\u0026#34;Blue: \u0026#34; + blue); } // Update current color Color color = new Color(red, green, blue); g.setColor(color); jslColorBtn.setBackground(color); } } /** * Handles button click events * Switches drawing tools and colors * Performs different operations based on the button type */ @Override public void actionPerformed(ActionEvent e) { String ac = e.getActionCommand(); // Handle color button click if(ac.equals(\u0026#34;ColorBtn\u0026#34;)) { JButton btn = (JButton) e.getSource(); Color color = btn.getBackground(); // Update RGB values red = color.getRed(); green = color.getGreen(); blue = color.getBlue(); g.setColor(color); } // Handle eraser tool else if(ac.equals(\u0026#34;Eraser\u0026#34;)) { g.setColor(Color.white); // Set color to white for erasing effect } // Handle clearing the canvas else if(ac.equals(\u0026#34;Clear\u0026#34;)) { // Save current color Color currentColor = g.getColor(); // Clear entire panel g.setColor(Color.WHITE); g.fillRect(0, 0, 1000, 800); // Use fixed size to ensure full coverage // Restore original color g.setColor(currentColor); } // Handle other drawing tools else { type = ac; // Update drawing type g.setColor(new Color(red, green, blue)); // Set current color } } /** * Handles mouse click events * Currently used for debugging output only */ @Override public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;Mouse clicked on window button\u0026#34;); } /** * Records the starting position where the mouse is pressed * Determines the starting point of the graphic */ @Override public void mousePressed(MouseEvent e) { x1 = e.getX(); y1 = e.getY(); } /** * Handles mouse release events * Draws corresponding graphics based on the selected tool type * Supports drawing multiple types of graphics, including: * 1. Lines * 2. Rectangles (hollow and filled) * 3. Circles (hollow and filled) * 4. Isosceles triangles (hollow and filled) */ @Override public void mouseReleased(MouseEvent e) { x2 = e.getX(); y2 = e.getY(); // Draw corresponding graphics based on the selected type if (type.equals(\u0026#34;Line\u0026#34;)) { g.drawLine(x1, y1, x2, y2); } else if (type.equals(\u0026#34;Rectangle\u0026#34;)) { g.drawRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Circle\u0026#34;)) { g.drawOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Solid Rectangle\u0026#34;)) { g.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Solid Circle\u0026#34;)) { g.fillOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Solid Isosceles Triangle\u0026#34;)) { // Draw a solid isosceles triangle int mx = (x1 + x2) / 2; // Calculate x-coordinate of the apex int my = y1; // y-coordinate of the apex int h = Math.abs(y2 - y1);// Calculate height int w = Math.abs(x2 - x1);// Calculate width double dx = w / 2.0 / h; // Calculate width change per line // Draw the triangle line by line for (int i = 0; i \u0026lt; h; i++) { if (y1 \u0026lt; y2) { g.drawLine((int) (mx - dx * i), my + i, (int) (mx + dx * i), my + i); } else { g.drawLine((int) (mx - dx * i), my - i, (int) (mx + dx * i), my - i); } } } else if (type.equals(\u0026#34;Isosceles Triangle\u0026#34;)) { // Draw the outline of an isosceles triangle int mx = (x1 + x2) / 2; // Calculate x-coordinate of the apex int my = y1; // y-coordinate of the apex // Draw the three sides g.drawLine(x1, y2, mx, my); // Left side g.drawLine(mx, my, x2, y2); // Right side g.drawLine(x1, y2, x2, y2); // Base } } /** * Handles mouse enter events * Currently no specific functionality implemented */ @Override public void mouseEntered(MouseEvent e) { } /** * Handles mouse exit events * Currently no specific functionality implemented */ @Override public void mouseExited(MouseEvent e) { } } ","date":"2025-05-11T10:33:34+08:00","permalink":"https://ferdinandhu.netlify.app/en/p/interactive-drawing-board-v3.0/","title":"Interactive Drawing Board v3.0"},{"content":"Interactive Drawing Board v2.0 Implement a simple interactive drawing board using Java. Based on version 1.0, more graphic drawing functions have been added, and the code structure has been optimized.\nFunction Introduction of Each Class DrawPadv2 class: Basic settings and visualization of the window, and add mouse listeners and action listeners. DrawListener class: Implement the MouseListener and ActionListener interfaces to handle mouse events and button click events. Specific Operations Set the basic properties of the form. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Create a DrawListener object DrawListener dl = new DrawListener(); // Display the UI interface public void showUI() { // Create a JFrame object JFrame jf = new JFrame(); // Set the window title jf.setTitle(\u0026#34;Drawing Board v2.0\u0026#34;); // Set the window size jf.setSize(850, 600); // Set the window to be centered jf.setLocationRelativeTo(null); // Set the operation when the window is closed jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Set the window layout to FlowLayout jf.setLayout(new FlowLayout()); Through the above code, we create a window titled \u0026ldquo;Drawing Board v2.0\u0026rdquo;, set its size to 850x600 pixels, and center it. At the same time, configure the program to terminate when the window is closed and use the FlowLayout to manage the arrangement of components.\nAdd buttons and color buttons, and set listeners. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // Define button types String[] btnType = {\u0026#34;Line\u0026#34;, \u0026#34;Circle\u0026#34;, \u0026#34;Rectangle\u0026#34;, \u0026#34;Filled Circle\u0026#34;, \u0026#34;Filled Rectangle\u0026#34;, \u0026#34;Isosceles Triangle\u0026#34;, \u0026#34;Filled Isosceles Triangle\u0026#34;, \u0026#34;Eraser\u0026#34;}; // Loop to create buttons and add them to the window for (int i = 0; i \u0026lt; btnType.length; i++) { JButton btn = new JButton(btnType[i]); jf.add(btn); // Add a listener to the button btn.addActionListener(dl); } // Define the colors of the color buttons Color[] btnColors = {Color.BLACK, Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.CYAN, Color.MAGENTA, Color.GRAY, Color.LIGHT_GRAY, Color.DARK_GRAY, Color.PINK, Color.ORANGE, Color.WHITE}; // Loop to create color buttons and add them to the window for (int i = 0; i \u0026lt; btnColors.length; i++) { JButton btn = new JButton(); // Set the action command of the button to ColorBtn btn.setActionCommand(\u0026#34;ColorBtn\u0026#34;); // Set the background color of the button btn.setBackground(btnColors[i]); jf.add(btn); // Add a listener to the button btn.addActionListener(dl); } // Set the window to be visible jf.setVisible(true); // Add a mouse listener to the window jf.addMouseListener(dl); Create two types of buttons through loops: one for selecting the type of graphic to be drawn, and the other for switching the pen color. Each button is bound to a unified event listener dl (a DrawListener object) to achieve centralized processing of interaction logic.\nComplete the methods in the listener in the DrawListener class and create a Graphics object. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class MouseListener implements java.awt.event.MouseListener { // Declare a Graphics object Graphics g; public void actionPerformed(ActionEvent e) { System.out.println(\u0026#34;Button clicked\u0026#34;); } public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;Mouse clicked\u0026#34;); } public void mousePressed(MouseEvent e) { System.out.println(\u0026#34;Mouse pressed\u0026#34;); } public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;Mouse released\u0026#34;); } public void mouseEntered(MouseEvent e) { System.out.println(\u0026#34;Mouse entered the window\u0026#34;); } public void mouseExited(MouseEvent e) { System.out.println(\u0026#34;Mouse left the window\u0026#34;); } Complete the relevant code in the DrawPadv2 class. 1 2 3 4 // Get the Graphics object of the window Graphics g = jf.getGraphics(); // Assign the Graphics object to the g of the DrawListener object dl.g = g; Add a mouse listener to the window and pass the graphics context (Graphics object) of the window to DrawListener for subsequent drawing operations.\nImplement the drawing logic in the DrawListener class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // Declare the coordinates of the starting and ending points int x1, y1, x2, y2; // Declare the graphic type and color String type = \u0026#34;Line\u0026#34;; Color color = Color.black; @Override public void actionPerformed(ActionEvent e) { // Get the action command of the button String ac = e.getActionCommand(); System.out.println(\u0026#34;Clicked the button: \u0026#34; + ac); // If the clicked button is a color button if (ac.equals(\u0026#34;ColorBtn\u0026#34;)) { // Get the background color of the button JButton btn = (JButton) e.getSource(); color = btn.getBackground(); } // If the clicked button is an eraser else if (ac.equals(\u0026#34;Eraser\u0026#34;)) { // Set the pen color to the background color color = new Color(238, 238, 238); } // Otherwise, set the pen color else { type = ac; g.setColor(color); } Judge whether the user has selected a color, an eraser, or a graphic type according to the action command of the button, and update the pen color or drawing mode.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @Override public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;Mouse clicked\u0026#34;); } @Override public void mousePressed(MouseEvent e) { System.out.println(\u0026#34;Mouse pressed\u0026#34;); // Get the coordinates when the mouse is pressed x1 = e.getX(); y1 = e.getY(); } @Override public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;Mouse released\u0026#34;); // Get the coordinates when the mouse is released x2 = e.getX(); y2 = e.getY(); // If y2 is less than 80, set y2 to 80 if (y2 \u0026lt; 80) { y2 = 80; } // Draw the graphic according to the graphic type Graphics g = DrawPanel.getGraphics(); g.setColor(color); if (type.equals(\u0026#34;Line\u0026#34;)) { g.drawLine(x1, y1, x2, y2); } else if (type.equals(\u0026#34;Circle\u0026#34;)) { g.drawOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Rectangle\u0026#34;)) { g.drawRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Filled Circle\u0026#34;)) { g.fillOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Filled Rectangle\u0026#34;)) { g.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Isosceles Triangle\u0026#34;)) { // Calculate the vertex coordinates of the isosceles triangle int mx = (x1 + x2) / 2; int my = y1; // Draw the isosceles triangle g.drawLine(x1, y2, mx, my); g.drawLine(mx, my, x2, y2); g.drawLine(x1, y2, x2, y2); } else if (type.equals(\u0026#34;Filled Isosceles Triangle\u0026#34;)) { // Calculate the vertex coordinates of the isosceles triangle int mx = (x1 + x2) / 2; int my = y1; int h = Math.abs(y2 - y1); int w = Math.abs(x2 - x1); double dx = w / 2.0 / h; // Draw the isosceles triangle for (int i = 0; i \u0026lt; h; i++) { if (y1 \u0026lt; y2) { g.drawLine((int) (mx - dx * i), my + i, (int) (mx + dx * i), my + i); } else { g.drawLine((int) (mx - dx * i), my - i, (int) (mx + dx * i), my - i); } } } } Create and display the window in the main function. 1 2 3 4 5 6 public static void main(String[] args) { // Create a DrawPadv2 object DrawPadv2 dl = new DrawPadv2(); // Call the showUI method to display the UI interface dl.showUI(); } Record the coordinates when the mouse is pressed and released through the mousePressed and mouseReleased methods, and combine the currently selected graphic type to call the drawing method of the Graphics object to complete the drawing.\nFinal Code DrawPadv2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 package basic.hj0507; import javax.swing.*; import java.awt.*; public class DrawPadv2 { // Create a DrawListener object DrawListener dl = new DrawListener(); // Display the UI interface public void showUI() { // Create a JFrame object JFrame jf = new JFrame(); // Set the window title jf.setTitle(\u0026#34;Drawing Board v2.0\u0026#34;); // Set the window size jf.setSize(850,600); // Set the window to be centered jf.setLocationRelativeTo(null); // Set the operation when the window is closed jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // Set the window layout to FlowLayout jf.setLayout(new FlowLayout()); // Define button types String[] btnType = {\u0026#34;Line\u0026#34;, \u0026#34;Circle\u0026#34;, \u0026#34;Rectangle\u0026#34;, \u0026#34;Filled Circle\u0026#34;, \u0026#34;Filled Rectangle\u0026#34;, \u0026#34;Isosceles Triangle\u0026#34;, \u0026#34;Filled Isosceles Triangle\u0026#34;, \u0026#34;Eraser\u0026#34;}; // Loop to create buttons and add them to the window for (int i = 0; i \u0026lt; btnType.length; i++) { JButton btn = new JButton(btnType[i]); jf.add(btn); // Add a listener to the button btn.addActionListener(dl); } // Define the colors of the color buttons Color[] btnColors = {Color.BLACK, Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.CYAN, Color.MAGENTA, Color.GRAY, Color.LIGHT_GRAY, Color.DARK_GRAY, Color.PINK, Color.ORANGE, Color.WHITE}; // Loop to create color buttons and add them to the window for (int i = 0; i \u0026lt; btnColors.length; i++) { JButton btn = new JButton(); // Set the action command of the button to ColorBtn btn.setActionCommand(\u0026#34;ColorBtn\u0026#34;); // Set the background color of the button btn.setBackground(btnColors[i]); jf.add(btn); // Add a listener to the button btn.addActionListener(dl); } // Set the window to be visible jf.setVisible(true); // Add a mouse listener to the window jf.addMouseListener(dl); // Get the Graphics object of the window Graphics g = jf.getGraphics(); // Assign the Graphics object to the g of the DrawListener object dl.g = g; } // Main method public static void main(String[] args) { // Create a DrawPadv2 object DrawPadv2 dl = new DrawPadv2(); // Call the showUI method to display the UI interface dl.showUI(); } } DrawListener\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 package basic.hj0507; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; public class DrawListener implements MouseListener, ActionListener { // Declare a Graphics object Graphics g; // Declare the coordinates of the starting and ending points int x1, y1, x2, y2; // Declare the graphic type and color String type = \u0026#34;Line\u0026#34;; Color color = Color.black; @Override public void actionPerformed(ActionEvent e) { // Get the action command of the button String ac = e.getActionCommand(); System.out.println(\u0026#34;Clicked the button: \u0026#34; + ac); // If the clicked button is a color button if (ac.equals(\u0026#34;ColorBtn\u0026#34;)) { // Get the background color of the button JButton btn = (JButton) e.getSource(); color = btn.getBackground(); // Set the pen color g.setColor(color); } // If the clicked button is an eraser else if (ac.equals(\u0026#34;Eraser\u0026#34;)) { // Set the pen color to the background color Color color2 = new Color(238,238,238); g.setColor(color2); } // Otherwise, set the pen color else { type = ac; g.setColor(color); } } @Override public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;Mouse clicked\u0026#34;); } @Override public void mousePressed(MouseEvent e) { System.out.println(\u0026#34;Mouse pressed\u0026#34;); // Get the coordinates when the mouse is pressed x1 = e.getX(); y1 = e.getY(); } @Override public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;Mouse released\u0026#34;); // Get the coordinates when the mouse is released x2 = e.getX(); y2 = e.getY(); // If y2 is less than 80, set y2 to 80 if (y2\u0026lt;80) { y2 = 80; } // Draw the graphic according to the graphic type if (type.equals(\u0026#34;Line\u0026#34;)) { g.drawLine(x1, y1, x2, y2); } else if (type.equals(\u0026#34;Rectangle\u0026#34;)) { g.drawRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Circle\u0026#34;)) { g.drawOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Filled Rectangle\u0026#34;)) { g.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Filled Circle\u0026#34;)) { g.fillOval(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1)); } else if (type.equals(\u0026#34;Filled Isosceles Triangle\u0026#34;)) { // Calculate the vertex coordinates of the isosceles triangle int mx = (x1 + x2) / 2; int my = y1; int h = Math.abs(y2 - y1); int w = Math.abs(x2 - x1); double dx = w / 2.0 / h; // Draw the isosceles triangle for (int i = 0; i \u0026lt; h; i++) { if (y1 \u0026lt; y2) { g.drawLine((int) (mx - dx * i), my + i, (int) (mx + dx * i), my + i); } else { g.drawLine((int) (mx - dx * i), my - i, (int) (mx + dx * i), my - i); } } } else if (type.equals(\u0026#34;Isosceles Triangle\u0026#34;)) { // Calculate the vertex coordinates of the isosceles triangle int mx = (x1 + x2) / 2; int my = y1; // Draw the isosceles triangle g.drawLine(x1, y2, mx, my); g.drawLine(mx, my, x2, y2); g.drawLine(x1, y2, x2, y2); } } @Override public void mouseEntered(MouseEvent e) { System.out.println(\u0026#34;Mouse entered the window\u0026#34;); } @Override public void mouseExited(MouseEvent e) { System.out.println(\u0026#34;Mouse left the window\u0026#34;); } } ","date":"2025-05-08T20:31:26+08:00","permalink":"https://ferdinandhu.netlify.app/en/p/interactive-drawing-board-v2.0/","title":"Interactive Drawing Board v2.0"},{"content":"Interactive Drawing Board v1.0 Implement a simple interactive drawing board using Java.\nFunction Introduction of Each Class DrawPad class: Basic settings and visualization of the window, and add mouse and keyboard listeners to the window. MouseListener class: Create a listener class that implements the mouse listener, and implement methods such as mouse click, press, release, enter, and exit. KeyListener class: Create a listener class that implements the keyboard listener to facilitate controlling and switching different drawing types on the keyboard. Specific Steps Create a form jf in the DrawPad class and set its properties. 1 2 3 4 5 6 7 8 JFrame jf = new JFrame(); String title = \u0026#34;Drawing Board v1.0\u0026#34;; jf.setTitle(title); jf.setSize(800,600); jf.setLocationRelativeTo(null); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setLayout(new FlowLayout()); jf.setVisible(true); Create a mouse listener in the MouseListener class of the listener, and complete all the default methods in the listener. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class MouseListener implements java.awt.event.MouseListener { public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;Clicked\u0026#34;); } public void mousePressed(MouseEvent e) { System.out.println(\u0026#34;Pressed\u0026#34;); } public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;Released\u0026#34;); } public void mouseEntered(MouseEvent e) { System.out.println(\u0026#34;Entered\u0026#34;); } public void mouseExited(MouseEvent e) { System.out.println(\u0026#34;Exited\u0026#34;); } } Create an object m of the listener class and add the mouse listener to the form object. 1 2 MouseListener m = new MouseListener(); jf.addMouseListener(m); Obtain the graphics object of the form after visualization. 1 2 Graphics g = jf.getGraphics(); m.gr = g; // Copy the reference address of the obtained graphics object to the graphics object variable name in the listener Pass the just obtained graphics object to the graphics object in the listener. 1 Graphics gr; In the same way, create a keyboard listener KeyListener class to facilitate controlling and switching different drawing types. In the keyPressed method block: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class KeyListener implements java.awt.event.KeyListener { // Declare a private member variable of type MouseListener named mouseListener, which is used to reference a MouseListener object to associate with mouse events during keyboard event handling. private MouseListener mouseListener; // Define the constructor of the class, which accepts a MouseListener type parameter mouseListener public KeyListener(MouseListener mouseListener) { this.mouseListener = mouseListener; } public void keyTyped(KeyEvent e) { System.out.println(\u0026#34;Typed: \u0026#34; + e.getKeyCode()); } public void keyPressed(KeyEvent e) { System.out.println(\u0026#34;Pressed: \u0026#34; + e.getKeyCode()); int keyCode = e.getKeyCode(); // Use a switch statement to perform different operations according to different key codes switch (keyCode) { case KeyEvent.VK_1: // Call the setDrawType method of the mouseListener object to set the drawing type to 1 mouseListener.setDrawType(1); System.out.println(\u0026#34;Current Drawing Type: Line\u0026#34;); break; case KeyEvent.VK_2: mouseListener.setDrawType(2); System.out.println(\u0026#34;Current Drawing Type: Rectangle\u0026#34;); break; case KeyEvent.VK_3: mouseListener.setDrawType(3); System.out.println(\u0026#34;Current Drawing Type: Filled Rectangle\u0026#34;); break; case KeyEvent.VK_4: mouseListener.setDrawType(4); System.out.println(\u0026#34;Current Drawing Type: Isosceles Triangle\u0026#34;); break; case KeyEvent.VK_5: mouseListener.setDrawType(5); System.out.println(\u0026#34;Current Drawing Type: Five-pointed Star\u0026#34;); break; } } public void keyReleased(KeyEvent e) { System.out.println(\u0026#34;Released: \u0026#34; + e.getKeyCode()); } } Complete the relevant code in the MouseListener class. 1 2 3 4 5 6 // Define a private integer variable to store the current drawing type private int drawType; // Define the setDrawType method to receive the drawType value passed in by the KeyListener class public void setDrawType(int drawType) { this.drawType = drawType; } Use the graphics object passed in from the form object and the drawType value passed in by the KeyListener class to draw a line to implement different pattern types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;Released\u0026#34;); x2 = e.getX(); y2 = e.getY(); switch (drawType) { case 1: gr.drawLine(x1,y1,x2,y2); break; case 2: gr.drawLine(x1,y1,x2,y1); gr.drawLine(x2,y1,x2,y2); gr.drawLine(x1,y2,x2,y2); gr.drawLine(x1,y1,x1,y2); break; case 3: int height = Math.abs(y1 - y2); int yi = y1; while (Math.abs(yi-y1)\u0026lt;height) { gr.drawLine(x1,yi,x2,yi); if(y1\u0026lt;y2) { yi++; } else { yi--; } } break; case 4: int vertexX = ( x1 + x2 )/2; int vertexY = y1; gr.drawLine(vertexX,vertexY,x1,y2); gr.drawLine(vertexX,vertexY,x2,y2); gr.drawLine(x1,y2,x2,y2); break; case 5: int v1X = ( x1 + x2 )/2; int v1Y = y1; int v2X = x2; int v2Y = 2*y1/3 + y2/3; int v3X = x1/5 + 4*x2/5; int v3Y = y2; int v4X = x2/5 + 4*x1/5; int v4Y = y2; int v5X = x1; int v5Y = 2*y1/3 + y2/3; gr.drawLine(v1X,v1Y,v3X,v3Y); gr.drawLine(v3X,v3Y,v5X,v5Y); gr.drawLine(v5X,v5Y,v2X,v2Y); gr.drawLine(v2X,v2Y,v4X,v4Y); gr.drawLine(v4X,v4Y,v1X,v1Y); break; } } Final Code DrawPad.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.awt.*; import java.awt.event.KeyListener; import javax.swing.*; public class DrawPad { public void showUI(){ JFrame jf = new JFrame(); String title = \u0026#34;Drawing Board v1.0\u0026#34;; jf.setTitle(title); jf.setSize(800,600); jf.setLocationRelativeTo(null); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); jf.setLayout(new FlowLayout()); jf.setVisible(true); MouseListener m = new MouseListener(); jf.addMouseListener(m); KeyListener k = new basic.hj0430.KeyListener(m); jf.addKeyListener(k); Graphics g = jf.getGraphics(); m.gr = g; } public static void main(String[] args) { new DrawPad().showUI(); } } MouseListener.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import java.awt.*; import java.awt.event.MouseEvent; public class MouseListener implements java.awt.event.MouseListener { Graphics gr; int x1,x2,y1,y2; private int drawType; public void setDrawType(int drawType) { this.drawType = drawType; } public void mouseClicked(MouseEvent e) { System.out.println(\u0026#34;Clicked\u0026#34;); } public void mousePressed(MouseEvent e) { System.out.println(\u0026#34;Pressed\u0026#34;); x1 = e.getX(); y1 = e.getY(); } public void mouseReleased(MouseEvent e) { System.out.println(\u0026#34;Released\u0026#34;); x2 = e.getX(); y2 = e.getY(); switch (drawType) { case 1: gr.drawLine(x1,y1,x2,y2); break; case 2: gr.drawLine(x1,y1,x2,y1); gr.drawLine(x2,y1,x2,y2); gr.drawLine(x1,y2,x2,y2); gr.drawLine(x1,y1,x1,y2); break; case 3: int height = Math.abs(y1 - y2); int yi = y1; while (Math.abs(yi-y1)\u0026lt;height) { gr.drawLine(x1,yi,x2,yi); if(y1\u0026lt;y2) { yi++; } else { yi--; } } break; case 4: int vertexX = ( x1 + x2 )/2; int vertexY = y1; gr.drawLine(vertexX,vertexY,x1,y2); gr.drawLine(vertexX,vertexY,x2,y2); gr.drawLine(x1,y2,x2,y2); break; case 5: int v1X = ( x1 + x2 )/2; int v1Y = y1; int v2X = x2; int v2Y = 2*y1/3 + y2/3; int v3X = x1/5 + 4*x2/5; int v3Y = y2; int v4X = x2/5 + 4*x1/5; int v4Y = y2; int v5X = x1; int v5Y = 2*y1/3 + y2/3; gr.drawLine(v1X,v1Y,v3X,v3Y); gr.drawLine(v3X,v3Y,v5X,v5Y); gr.drawLine(v5X,v5Y,v2X,v2Y); gr.drawLine(v2X,v2Y,v4X,v4Y); gr.drawLine(v4X,v4Y,v1X,v1Y); break; } } public void mouseEntered(MouseEvent e) { System.out.println(\u0026#34;Entered\u0026#34;); } public void mouseExited(MouseEvent e) { System.out.println(\u0026#34;Exited\u0026#34;); } } KeyListener.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import java.awt.*; import java.awt.event.KeyEvent; public class KeyListener implements java.awt.event.KeyListener { private MouseListener mouseListener; public KeyListener(MouseListener mouseListener) { this.mouseListener = mouseListener; } public void keyTyped(KeyEvent e) { System.out.println(\u0026#34;Typed: \u0026#34; + e.getKeyCode()); } public void keyPressed(KeyEvent e) { System.out.println(\u0026#34;Pressed: \u0026#34; + e.getKeyCode()); int keyCode = e.getKeyCode(); switch (keyCode) { case KeyEvent.VK_1: mouseListener.setDrawType(1); System.out.println(\u0026#34;Current Drawing Type: Line\u0026#34;); break; case KeyEvent.VK_2: mouseListener.setDrawType(2); System.out.println(\u0026#34;Current Drawing Type: Rectangle\u0026#34;); break; case KeyEvent.VK_3: mouseListener.setDrawType(3); System.out.println(\u0026#34;Current Drawing Type: Filled Rectangle\u0026#34;); break; case KeyEvent.VK_4: mouseListener.setDrawType(4); System.out.println(\u0026#34;Current Drawing Type: Isosceles Triangle\u0026#34;); break; case KeyEvent.VK_5: mouseListener.setDrawType(5); System.out.println(\u0026#34;Current Drawing Type: Five-pointed Star\u0026#34;); break; } } public void keyReleased(KeyEvent e) { System.out.println(\u0026#34;Released: \u0026#34; + e.getKeyCode()); } } ","date":"2025-05-03T19:54:22+08:00","permalink":"https://ferdinandhu.netlify.app/en/p/interactive-drawing-board-v1.0/","title":"Interactive Drawing Board v1.0"},{"content":"User Authentication Interface Implement a simple user authentication interface using Java, which includes user registration, login, logout, and cancellation functions, and generate a window through the Graphical User Interface (GUI) for users to interact with.\nFunction Introduction of Each Class User Class\nData Model Specifies the data that needs to be processed throughout the project. Functions: Contains the basic information of the user. Specifies the basic standards and functions for login and logout. UserService Class\nData Processing Implements the specific logic of registration, login, logout, and cancellation. Functions: Responsible for managing the specific operations of user registration, login, logout, and cancellation. Uses HashMap to store all user information and the information of online users. LoginAction Class\nFunction Control Handles the events when the user clicks the login, registration, logout, and cancellation buttons on the interface, and pops up the corresponding prompt dialog box according to the return result. Functions: Implements the ActionListener interface. Jumps to different functions according to the result of the user\u0026rsquo;s click. UI Class\nUser Interface Visualizes the UI interface. Functions: Creates and displays the interface window. Adds components such as input boxes and buttons. Final Code Implementation User.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class User { // User attributes String name; String pwd; int score; boolean isLogin; // Define a login method to perform the login operation according to the input password and return different login status codes // 1001 User is already online 1002 Login successful 1003 Password is incorrect public int login(String pwdIn){ if (pwd.equals(pwdIn)){ if (isLogin) { return 1001; } score += 100; isLogin = true; return 1002; } return 1003; } // Define a logout method to perform the logout operation according to the input password and return different logout status codes // 1004 Logout successful 1005 Account is not logged in 1006 Password is incorrect, logout failed public int logout(String pwdIn){ if (pwd.equals(pwdIn)){ if(isLogin){ isLogin = false; return 1004; } return 1005; } return 1006; } } UserService.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 import java.util.HashMap; public class UserService { // Use two HashMaps to store the data of all users and online users respectively HashMap\u0026lt;String, User\u0026gt; usersGeneral = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;String, User\u0026gt; usersOnline = new HashMap\u0026lt;\u0026gt;(); // The following four methods are used to add and remove user information in the HashMap respectively public void addUserGeneral(User user){ usersGeneral.put(user.name, user); } public void removeUserGeneral(User user){ usersGeneral.remove(user.name); } public void addUserOnline(User user){ usersOnline.put(user.name, user); } public void removeUserOnline(User user) { usersOnline.remove(user.name); } // backstageInfoShow() is used to display the background information public void backstageInfoShow() { System.out.println(\u0026#34;\\n\u0026#34;); System.out.println(\u0026#34;====Backstage====\u0026#34;); System.out.println(\u0026#34;Current number of registrations: \u0026#34; + usersGeneral.size()); System.out.println(\u0026#34;Number of online users: \u0026#34; + usersOnline.size()); System.out.println(\u0026#34;=================\u0026#34;); } // userInfoShow() is used to display user information public void userInfoShow(User user){ System.out.println(\u0026#34;\\n\u0026#34;); System.out.println(\u0026#34;-----------------\u0026#34;); System.out.println(\u0026#34;Account: \u0026#34; + user.name); System.out.println(\u0026#34;Status: \u0026#34; + ( user.isLogin ? \u0026#34;Logged in\u0026#34;:\u0026#34;Not logged in\u0026#34;)); System.out.println(\u0026#34;Points: \u0026#34; + user.score); System.out.println(\u0026#34;-----------------\u0026#34;); } // The userLogin(), userLogout(), and userCancel() methods continue to complete the login and logout operations and return new status codes // by receiving the login and logout status codes passed in by the login() and logout() methods in the User class. public int userLogin(String name, String pwd){ boolean isContained = usersGeneral.containsKey(name); if (isContained){ User user = usersGeneral.get(name); int loginCode = user.login(pwd); if (loginCode == 1002){ addUserOnline(user); } backstageInfoShow(); userInfoShow(user); return loginCode; } else{ return 1000; } } public int userLogout(String name, String pwd){ boolean isContained = usersOnline.containsKey(name); if (isContained){ User user = usersOnline.get(name); int logoutCode = user.logout(pwd); if (logoutCode ==1004){ removeUserOnline(user); } backstageInfoShow(); userInfoShow(user); return logoutCode; } else{ return 1005; } } public boolean userRegister(String name, String pwd){ boolean isContained = usersGeneral.containsKey(name); if (isContained){ backstageInfoShow(); return false; } else{ User user = new User(); user.name = name; user.pwd = pwd; user.score = 10000; addUserGeneral(user); backstageInfoShow(); userInfoShow(user); return true; } } // 1007 Cancellation successful 1008 Password is incorrect, cancellation failed 1009 User is not registered, cancellation failed public int userCancel(String name, String pwd){ boolean isContained = usersGeneral.containsKey(name); int cancelCode; if (isContained){ User user = usersGeneral.get(name); if(user.login(pwd) != 1003){ removeUserGeneral(user); removeUserOnline(user); cancelCode = 1007; } else { cancelCode = 1008; } backstageInfoShow(); return cancelCode; } else { cancelCode = 1009; backstageInfoShow(); return cancelCode; } } } LoginAction.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class LoginAction implements ActionListener { // Used to store the reference of the username input box, and obtain the username and password entered by the user from this input box later JTextField nameJTF2 = null; JTextField pwdJTF2 = null; // Create an instance of the UserService class to call its user management methods (such as login, registration, etc.) UserService userService = new UserService(); // Implement the actionPerformed method of the ActionListener interface, which will be triggered when the user clicks a button public void actionPerformed(ActionEvent e){ // Get the command text of the button clicked by the user String ac = e.getActionCommand(); System.out.println(\u0026#34;Commend: \u0026#34; + ac); String name = nameJTF2.getText(); System.out.println(\u0026#34;Account: \u0026#34; + name); String pwd = pwdJTF2.getText(); System.out.println(\u0026#34;Password: \u0026#34; + pwd); // Perform different processing according to the command text of the button clicked by the user switch (ac) { case \u0026#34;Login\u0026#34; -\u0026gt; { int loginCode = userService.userLogin(name, pwd); switch (loginCode) { case 1000: JOptionPane.showMessageDialog(null, \u0026#34;User does not exist!\u0026#34;); break; case 1001: JOptionPane.showMessageDialog(null, \u0026#34;User is already online!\u0026#34;); break; case 1002: JOptionPane.showMessageDialog(null, \u0026#34;Login successful!\u0026#34;); break; case 1003: JOptionPane.showMessageDialog(null, \u0026#34;Password is incorrect!\u0026#34;); break; } } case \u0026#34;Register\u0026#34; -\u0026gt; { boolean registerCode = userService.userRegister(name, pwd); if (registerCode) { JOptionPane.showMessageDialog(null, \u0026#34;Registration successful!\u0026#34;); } else { JOptionPane.showMessageDialog(null, \u0026#34;Registration failed! User already exists\u0026#34;); } } case \u0026#34;Logout\u0026#34; -\u0026gt; { int logoutCode = userService.userLogout(name, pwd); switch (logoutCode) { case 1004: JOptionPane.showMessageDialog(null, \u0026#34;Logout successful!\u0026#34;); break; case 1005: JOptionPane.showMessageDialog(null, \u0026#34;User is not logged in!\u0026#34;); break; case 1006: JOptionPane.showMessageDialog(null, \u0026#34;Password is incorrect! Logout failed\u0026#34;); break; } } // 1007 Cancellation successful 1008 Password is incorrect, cancellation failed 1009 User is not registered, cancellation failed case \u0026#34;Cancel\u0026#34; -\u0026gt; { int cancelCode = userService.userCancel(name, pwd); switch (cancelCode) { case 1007: JOptionPane.showMessageDialog(null, \u0026#34;Cancellation successful!\u0026#34;); break; case 1008: JOptionPane.showMessageDialog(null, \u0026#34;Password is incorrect! Cancellation failed\u0026#34;); break; case 1009: JOptionPane.showMessageDialog(null, \u0026#34;User is not registered! Cancellation failed\u0026#34;); break; } } } } } UI.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 import java.awt.*; import java.util.Objects; import javax.swing.*; public class UI { // The showUI method is used to initialize and display the graphical user interface public void showUI(){ // Create a JFrame window object JFrame jf = new JFrame(); jf.setTitle(\u0026#34;Operation Window\u0026#34;); jf.setSize(270,280); jf.setLocationRelativeTo(null); // Set the default operation when the window is closed, here it is to exit the application jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); FlowLayout fl = new FlowLayout(); jf.setLayout(fl); // Get the image resource named \u0026#34;Login.png\u0026#34; from the class path and create an ImageIcon object // Use Objects.requireNonNull to ensure that the obtained resource is not null, and throw a NullPointerException if it is null ImageIcon img = new ImageIcon(Objects.requireNonNull(UI.class.getResource(\u0026#34;Login.png\u0026#34;))); JLabel imgJLa = new JLabel(img); // Create JLabel tags and display the text JLabel nameJLa = new JLabel(\u0026#34;Account\u0026#34;); JLabel pwdJLa = new JLabel(\u0026#34;Password\u0026#34;); // Create JTextField text boxes JTextField nameJTF = new JTextField(20); JTextField pwdJTF = new JPasswordField(20); // Create JButton buttons and display the text JButton loginBtn = new JButton(\u0026#34;Login\u0026#34;); JButton registerBtn = new JButton(\u0026#34;Register\u0026#34;); JButton logoutBtn = new JButton(\u0026#34;Logout\u0026#34;); JButton cancelBtn = new JButton(\u0026#34;Cancel\u0026#34;); // Add each component to the window in turn jf.add(imgJLa); jf.add(pwdJLa); jf.add(nameJLa); jf.add(nameJTF); jf.add(pwdJLa); jf.add(pwdJTF); jf.add(loginBtn); jf.add(registerBtn); jf.add(logoutBtn); jf.add(cancelBtn); // Set the window to be visible so that it is displayed on the screen jf.setVisible(true); // Create a LoginAction object to handle the click events of the buttons // Add event listeners to each button and associate them with the LoginAction object LoginAction la = new LoginAction(); loginBtn.addActionListener(la); registerBtn.addActionListener(la); logoutBtn.addActionListener(la); cancelBtn.addActionListener(la); // Assign the references of the username and password input boxes in the window to the corresponding fields in the LoginAction object la.nameJTF2 = nameJTF; la.pwdJTF2 = pwdJTF; } public static void main(String[] args) { UI loginUI = new UI(); loginUI.showUI(); } } ","date":"2025-04-27T17:25:19+08:00","permalink":"https://ferdinandhu.netlify.app/en/p/pratical-project-1--user-authentication-interface/","title":"Pratical Project 1 -- User Authentication Interface"},{"content":"Event Listener Principle Utilize the ActionListener interface from the java.awt.event package provided by Java\u0026rsquo;s external libraries, and use the actionPerformed(ActionEvent e) method to listen for action events of buttons. Preliminary Work A LoginUI library has been created to create a login window, which contains single-line input fields for entering the account and password, as well as a login button. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // Login Window import java.awt.*; import javax.swing.*; public class LoginUI { public void showUI() { JFrame jf = new JFrame(); jf.setTitle(\u0026#34;Login Window\u0026#34;); jf.setSize(270, 280); jf.setLocationRelativeTo(null); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); FlowLayout fl = new FlowLayout(); jf.setLayout(fl); ImageIcon img = new ImageIcon(\u0026#34;\u0026lt;Image Address\u0026gt;\u0026#34;); JLabel imgJLa = new JLabel(img); JLabel accountJLa = new JLabel(\u0026#34;Account\u0026#34;); JLabel passwordJLa = new JLabel(\u0026#34;Password\u0026#34;); JTextField accountJTF = new JTextField(20); JTextField passwordJTF = new JTextField(20); JButton loginBtn = new JButton(\u0026#34;Login\u0026#34;); JButton registerBtn = new JButton(\u0026#34;Register\u0026#34;); jf.add(imgJLa); jf.add(accountJLa); jf.add(accountJTF); jf.add(passwordJLa); jf.add(passwordJTF); jf.add(loginBtn); jf.add(registerBtn); jf.setVisible(true); } public static void main(String[] args) { LoginUI login_ui = new LoginUI(); login_ui.showUI(); } } ActionListener Interface An action event listener interface that listens for whether a component like a button has been clicked by the mouse. Note: The ActionListener interface is a template and cannot be used as a class. When creating a class name, you need to perform the following operations: 1 public class LoginAction implements ActionListener{ } And override the abstract method actionPerformed() in the listener within the class: 1 public void actionPerformed(ActionEvent e){ } Specific Steps For convenience, first create a class named InfoStorage to store account and password information. 1 2 3 4 5 6 7 8 9 10 11 12 import java.util.HashMap; import java.util.Map; public class InfoStorage { Map\u0026lt;String,String\u0026gt; accountMap = new HashMap\u0026lt;\u0026gt;(); // Create a variable accountMap to store key - value pairs public InfoStorage() { accountMap.put(\u0026#34;user1\u0026#34;,\u0026#34;123\u0026#34;); accountMap.put(\u0026#34;user2\u0026#34;,\u0026#34;abc\u0026#34;); accountMap.put(\u0026#34;hj\u0026#34;,\u0026#34;1130\u0026#34;); } } Create a class named LoginAction, import the corresponding libraries, and create an object of the class that implements the interface to bind it to the button that needs to be listened to. Import the libraries: 1 2 3 import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; Create the LoginAction class and use the ActionListener template: 1 public class LoginAction implements ActionListener {} Create the actionPerformed method: 1 2 3 4 5 public void actionPerformed(ActionEvent e){ String ac = e.getActionCommand(); // Define a variable ac of string type to receive the content in the button System.out.println(\u0026#34;Command: \u0026#34; + ac); String accountText = accountJTF2.getText(); String passwordText = passwordJTF2.getText(); Return to the LoginUI class. Now you can create a new object la of the LoginAction class to add an action listener to two buttons (loginBtn and registerBtn). (Note: The same action listener is added here.) 1 2 3 4 5 6 7 LoginAction la = new LoginAction(); loginBtn.addActionListener(la); registerBtn.addActionListener(la); // Since the same variable name cannot be shared between different classes, here we declare that accountJTF2 and passwordJTF2 in the LoginAction class are accountJTF and accountJTF. la.accountJTF2 = accountJTF; la.passwordJTF2 = passwordJTF; Then return to the LoginAction class and add the following code at the beginning: 1 2 3 4 // Define the previously mentioned accountJTF2 and passwordJTF2 as JTextField types and set them to null. JTextField accountJTF2 = null; JTextField passwordJTF2 = null; private InfoStorage storage = new InfoStorage(); // Create an object storage for the previous InfoStorage library. Finally, design a judgment module to determine whether the entered account and password meet the login requirements. 1 2 3 4 5 6 7 8 9 10 11 12 if(storage.accountMap.containsKey(accountText)) { String correctPassword = storage.accountMap.get(accountText); if (passwordText.equals(correctPassword)) { System.out.println(\u0026#34;Login successful!\u0026#34;); } else { System.out.println(\u0026#34;Incorrect password! Login failed!\u0026#34;); } } else{ System.out.println(\u0026#34;Account does not exist!\u0026#34;); } Implementation Effect Final Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 //LoginUI.java import java.awt.*; import javax.swing.*; public class LoginUI { public void showUI(){ JFrame jf = new JFrame(); jf.setTitle(\u0026#34;Login Window\u0026#34;); jf.setSize(270,280); jf.setLocationRelativeTo(null); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); FlowLayout fl = new FlowLayout(); jf.setLayout(fl); ImageIcon img = new ImageIcon(\u0026lt;Address of the image file\u0026gt;); JLabel imgJLa = new JLabel(img); JLabel accountJLa = new JLabel(\u0026#34;Account\u0026#34;); JLabel passwordJLa = new JLabel(\u0026#34;Password\u0026#34;); JTextField accountJTF = new JTextField(20); JTextField passwordJTF = new JTextField(20); JButton loginBtn = new JButton(\u0026#34;Login\u0026#34;); JButton registerBtn = new JButton(\u0026#34;Register\u0026#34;); jf.add(imgJLa); jf.add(accountJLa); jf.add(accountJTF); jf.add(passwordJLa); jf.add(passwordJTF); jf.add(loginBtn); jf.add(registerBtn); jf.setVisible(true); LoginAction la = new LoginAction(); loginBtn.addActionListener(la); registerBtn.addActionListener(la); la.accountJTF2 = accountJTF; la.passwordJTF2 = passwordJTF; } public static void main(String[] args) { LoginUI ui = new LoginUI(); ui.showUI(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //LoginAction.java import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class LoginAction implements ActionListener { JTextField accountJTF2 = null; JTextField passwordJTF2 = null; private InfoStorage storage = new InfoStorage(); public void actionPerformed(ActionEvent e){ String ac = e.getActionCommand(); System.out.println(\u0026#34;Command: \u0026#34; + ac); String accountText = accountJTF2.getText(); String passwordText = passwordJTF2.getText(); if(storage.accountMap.containsKey(accountText)) { String correctPassword = storage.accountMap.get(accountText); if (passwordText.equals(correctPassword)) { System.out.println(\u0026#34;Login successful!\u0026#34;); } else { System.out.println(\u0026#34;Incorrect password! Login failed!\u0026#34;); } } else{ System.out.println(\u0026#34;Account does not exist!\u0026#34;); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //InfoStorage.java import java.util.HashMap; import java.util.Map; public class InfoStorage { Map\u0026lt;String,String\u0026gt; accountMap = new HashMap\u0026lt;\u0026gt;(); public InfoStorage() { accountMap.put(\u0026#34;user1\u0026#34;,\u0026#34;123\u0026#34;); accountMap.put(\u0026#34;user2\u0026#34;,\u0026#34;abc\u0026#34;); accountMap.put(\u0026#34;hj\u0026#34;,\u0026#34;1130\u0026#34;); } } ","date":"2025-04-24T09:28:48+08:00","permalink":"https://ferdinandhu.netlify.app/en/p/event-listener/","title":"Event listener"},{"content":"Basic Window Settings Principle: It is implemented using the java.awt and javax.swing packages that come with Java external libraries.\nBasic Steps: Create a new class (e.g., LoginUI). Define a method in this class (e.g., showUI(), used for interface development). Import the two interface development packages, java.awt and javax.swing. Create a main function main at the end. In it, create an object of LoginUI (e.g., ui) and call the previous showUI() method. Detailed Steps Use the import statement to import the two interface development packages. The .* at the end means to import all classes in the package. 1 2 import java.awt.*; import javax.swing.*; After defining the method showUI(), you can create a form class object jf using the JFrame in the javax.swing package you just imported. 1 JFrame jf = new JFrame(); Set the properties of the form. 1 2 3 4 jf.setTitle(\u0026#34;Login Window\u0026#34;); // Set the window title jf.setSize(400, 500); // Set the window size jf.setLocation(600, 200); // Set the window position jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // When the close button is clicked, the Java program terminates. Set the layout inside the window.\nFirst, create a layout manager object (here, use the FlowLayout class in the java.awt package to create it). 1 FlowLayout fl = new FlowLayout(); Add an image (you need to transfer the image to a Label for display). 1 2 ImageIcon img = new ImageIcon(\u0026lt;Image File Path\u0026gt;); JLabel imgJla = new JLabel(img); Add labels (text). 1 2 JLabel nameJla = new JLabel(\u0026#34;Account:\u0026#34;); JLabel pwdJla = new JLabel(\u0026#34;Password:\u0026#34;); Add a single - line text input box. 1 JTextField nameJtf = new JTextField(35); // The input box can display a width of 30 characters, and each character is about 10 pixels. Add a button. 1 JButton loginBtn = new JButton(\u0026#34;Login\u0026#34;); Add all the layout components created above to the form object jf.\n1 2 3 4 5 6 jf.add(imgJla); jf.add(nameJla); jf.add(nameJtf); jf.add(pwdJla); jf.add(pwdJtf); jf.add(loginBtn); Make it visible. 1 jf.setVisible(true); ","date":"2025-04-23T17:01:42+08:00","permalink":"https://ferdinandhu.netlify.app/en/p/basic-window-settings/","title":"Basic Window Settings"}]