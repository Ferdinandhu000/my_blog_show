---
title: "算法笔记3——二叉树、二叉搜索树、BFS与DFS"
date: 2025-12-17T16:28:22+08:00
math: true
draft: false
categories : 
  - Java
  - Notes
---

## 二叉树

### 遍历二叉树
![](https://raw.githubusercontent.com/Ferdinandhu000/my_blog_img/master/20251210141033.png)
#### pre-order
口诀：**中左右**  
顺序：`[F, B, A, D, C, E, G, I, H]`  
##### 代码
```java
public static void preOrder(Node root) {
    if(root == null) return;
    System.out.println(root.val); // 中
    preOrder_v1(root.left); // 左
    preOrder_v1(root.right); // 右
}
```

#### in-order
口诀：**左中右**  
顺序：`[A, B, C, D, E, F, G, H, I]`  
##### 代码
```java
public static void inOrder(Node root) {
    if(root == null) return;
    inOrder_v1(root.left); // 左
    System.out.println(root.val); // 中
    inOrder_v1(root.right); // 右
}
```

#### post-order
口诀：**左右中**  
顺序：`[A, C, E, D, B, H, I, G, F]`  
##### 代码
```java
public static void postOrder(Node root){
    if(root == null) return;
    postOrder_v1(root.left); // 左
    postOrder_v1(root.right); // 右
    System.out.println(root.val); // 中
}
```

**注**: 以上这些方法都可以通过在参数中传入一个`ArrayList`并在每次存入节点来直接得到一个列表

### 获取树高

#### 思路
递归思想，每次递归左右子树的树高并`+1`
#### 代码
```java
public static int getHeight(Node root) {
    if(root == null) return 0;
    
    return Math.max(getHeight(root.left), getHeight(root.right)) + 1;
}
```

### 获取节点数
#### 思路
同上
#### 代码
```java
public static int nodeCount(Node root) {
    if(root == null) return 0;
    return 1 + nodeCount(root.left) + nodeCount(root.right);
}
```

## 二叉搜索树(BST)
任意节点的左节点值都小于该节点值，右节点都大于该节点值
### 判断一个树是否是`BST`
#### 思路
如果左节点非空且左节点的最大值大于该点的值，则一定不是`BST`，同样逻辑判断右节点，如果左右节点都符合，递归处理左右节点
#### 代码
```java
public static boolean isBST(Node n) {
    if(n == null) return true;
    if(n.left != null && treeMax(n.left).key > n.key) return false;
    else if(n.right != null && treeMin(n.right).key < n.key) return false;
    else return isBST(n.left) && isBST(n.right);
}

// Using recursion to implement treeMax
public static Node treeMax(Node n) {
    if(n.right != null) return treeMax(n.right);
    else return n;
}
// Using iteration to implement treeMin
public static Node treeMin(Node n) {
    while(n.left != null) {
        n = n.left;
    }
    return n;
}
```

**注意：** 这里的`treeMax`和`treeMin`方法是假设该树已经是`BST`的条件下寻找的，也就是找到`right`的末尾或者`left`的末尾，有点类似用必要性条件验证是否是`BST`

### 插入操作(`insert`)
#### 思路
循环判断是否满足插入的位置（小了就往左放，大了就往右放），循环终止条件为找到了待插入的位置，注意此时这个位置没有节点，因此终止条件即为`x == null`。最后判断到底是插在该节点左侧还是右侧
#### 代码
```java
public static void insert(Node root, Node n) {
    Node y = null; // y 用来临时存放上一步的节点
    Node x = root;
    while(x != null) {
        y = x;
        if(n.key < x.key) {
            x = x.left;
        }
        else {
            x = x.right;
        }
    }
    n.p = y;
    // check whether insert left or right side of y
    if(y == null) root = n;
    else if(n.key < y.key) y.left = n;
    else y.right = n;
}
```

### 搜索操作(`search`)
#### 思路
递归搜索。终止条件为找到或此条路走到尽头了(`root == null`)
#### 代码
```java
public static Node search(Node root, char c) {
    if(root == null || c == root.key) return root;
    if(c < root.key) return search(root.left, c);
    else return search(root.right, c);
}
```

### 前驱和后继(`predecessor` & `successor`)
前驱：第一个比此节点值小的节点  
后继：第一个比此节点值大的节点
#### 思路
如果要找前驱或者后继，节点在事先定义时要存入对应的父节点(`node.p`)。  
如果是找前驱(`predecessor`)，首先如果该节点存在左节点，则直接返回左节点中的最大值即可(`treeMax()`)。如果该节点不存在左节点，则需要不断往上找它的父节点。如果其不是其第一个父节点的右节点（说明其比其第一个父节点小），则循环继续往上找。找后继亦然。
#### 代码
```java
public static Node successor(Node x) {
    if(x.right != null) return treeMin(x.right);
    Node y = x.p;
    while(y != null && x == y.right) {
        x = y;
        y = y.p;
    }
    return y;
}
public static Node predecessor(Node x) {
    if(x.left != null) return treeMax(x.left);
    Node y = x.p;
    while(y != null && x == y.left) {
        x = y;
        y = y.p;
    }
    return y;
}
```

## 广度优先搜索(BFS)
![](https://raw.githubusercontent.com/Ferdinandhu000/my_blog_img/master/20251214155916.png)
### 思路
在图搜索中，每个点不再成为节点(`Node`)，而是顶点(`Vertex`)。每一个`Vertex`中包含以下属性：
- `name`：节点名称
- `pi`：`parent`父节点（上一个位置）
- `d`：距离初始位置的距离
- `color`：状态标记（白-未搜索，灰-待搜索，黑-已搜索）
在`BFS`中，使用一个队列维护待搜索的`vertex`（灰色）。初始化将初始位置设为灰色并存入队列中，将其余的点设为白色。每次弹出队首元素，更改状态（灰->黑），并依次将其周围一圈连接的元素（且为白的）存入队列中，更改颜色和`pi`

### 代码
```java
// Vertex 类
class Vertex implements Comparable<Vertex> {
    Color color;
    Vertex pi;
    String name;
    int d;

    public Vertex(String name) {
        this.name = name;
        this.color = Color.WHITE;
        this.pi = null;
        this.d = 0;
    }

    // 要接入Comparable接口并重写compareTo方法，否则存入G时会与TreeMap冲突
    @Override
    public int compareTo(Vertex o) {
        return this.name.compareTo(o.name);
    }
    @Override
    public String toString() {
        return name;
    }
}
```

```java
// BFS
public static void BFS(Map<Vertex, ArrayList<Vertex>> G, Vertex s) {
    s.color = Color.GRAY;
    Queue q = new LinkedList<>();
    q.add(s);
    while(!q.isEmpty()) {
        Vertex u = (Vertex) q.poll();
        for(Vertex v : G.get(u)) { // 与u相邻的元素
            if(v.color == Color.WHITE) {
                v.color = Color.GRAY;
                v.d = u.d + 1;
                v.pi = u;
                q.add(v);
            }
        }
        u.color = Color.BLACK;
    }
}
```
此时若要查询从起始位置`s`到某一位置`v`的最短路径，返回`v.d`即可

## 深度优先搜索(DFS)
![](https://raw.githubusercontent.com/Ferdinandhu000/my_blog_img/master/20251214155916.png)
### 思路
与`BFS`相似，只需将队列改为栈即可实现深度搜索的功能

### 代码
```java
public static void DFS(Map<Vertex, ArrayList<Vertex>> G, Vertex s) {
    Stack st = new Stack<>();
    st.push(s);
    while(!st.isEmpty()) {
        Vertex u = (Vertex) st.pop();
        System.out.printf("Visiting %s\n", u);
        if(u.color == "white") {
            u.color = "grey";
            for(Vertex v : G.get(u)) {
                st.push(v);
            }
        }
        u.color = "black";
    }
}
```

## 最小生成树(MST)
![](https://raw.githubusercontent.com/Ferdinandhu000/my_blog_img/master/20251217154448.png)

### 思路
核心思想：**贪心策略**  
开始时将所有元素存入一个优先队列中，方便后续`poll`操作并维护队列。将起始点的`d`设为`0`，其余设为无穷大。每次`poll`出队列头元素`u`并遍历其相邻的元素`v`，若该点的值小于目前的值，则更改`v.pi`和`v.d`  
**注意java的`PriorityQueue`无法直接更改某个元素的值，需要先从队列中删除这个元素，单独在外部修改好所有值，再重新添加到队列中才行**

### 代码
```java
public static void prim(Map<Vertex, Map<Vertex, Integer>> G, Vertex r) {
    r.d = 0;
    PriorityQueue<Vertex> Q = new PriorityQueue<>((v1, v2) -> v1.d -v2.d); // Lambda表达式
    for(Vertex v : G.keySet()) {
        Q.add(v);
    }
    while(!Q.isEmpty()) {
        Vertex u = Q.poll();
        for(Map.Entry<Vertex, Integer> v : G.get(u).entrySet()) { // 留意这里的写法，是entrySet()
            if(Q.contains(v.getKey()) && v.getValue() < v.getKey().d) {
                Q.remove(v.getKey()); // 先删除
                v.getKey().pi = u; // 在外部修改
                v.getKey().d = v.getValue();
                Q.add(v.getKey()); // 最后添加回去
            }
        }
    }
}

```