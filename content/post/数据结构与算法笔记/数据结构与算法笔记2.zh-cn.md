---
title: "算法笔记2——栈、队列与链表"
date: 2025-12-17T16:26:22+08:00
math: true
draft: false
categories : 
  - Java
  - Notes
---

## 栈 (Stack)

### 数组模拟栈

- 特点：长度固定
- 成员变量：`int[] data`, `int top`
- 函数：`push()`, `pop()`

#### 代码
```java
class Stack {
    private double[] data;
    private int top = -1;

    public Stack(int len) {
        data = new double[len];
    }

    public void push(double x) throws Exception{
        if(top == data.length - 1) throw new Exception("Stack Overflow!");
        data[++top] = x;
    }

    public double pop() throws Exception {
        if(top == -1) throw new Exception("Stack Underflow!");
        return data[top--];
    }
}
```

### Java `Stack`类

#### 基本使用方法

| 方法签名          | 描述                                     | 示例                                  |
| :---------------- | :--------------------------------------- | :------------------------------------ |
| `E push(E item)`  | 将元素推入栈顶，并返回该元素。           | `stack.push(10);`                     |
| `E pop()`         | 移除并返回栈顶元素。如果栈为空，抛出 `EmptyStackException`。 | `int topElement = stack.pop();`       |
| `E peek()`        | 返回栈顶元素，但不移除。如果栈为空，抛出 `EmptyStackException`。 | `int topElement = stack.peek();`      |
| `boolean empty()` | 检查栈是否为空。如果为空，返回 `true`。  | `if (stack.empty()) { ... }`          |
| `int search(Object o)` | 从栈顶开始搜索指定元素，返回其 1-based 位置。如果未找到，返回 -1。 | `int position = stack.search(20);` |

#### 代码示例
```java
import java.util.Stack;
import java.util.EmptyStackException;

public class StackExample {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();

        // 1. push: 将元素压入栈顶
        stack.push(10);
        stack.push(20);
        stack.push(30);
        System.out.println("栈内容: " + stack); // 输出: 栈内容: [10, 20, 30] (注意这里是Vector的toString，栈顶在右侧)

        // 2. peek: 查看栈顶元素但不移除
        try {
            System.out.println("栈顶元素 (peek): " + stack.peek()); // 输出: 栈顶元素 (peek): 30
            System.out.println("栈内容 (peek后): " + stack); // 输出: 栈内容 (peek后): [10, 20, 30]
        } catch (EmptyStackException e) {
            System.out.println("栈为空，无法查看栈顶元素。");
        }

        // 3. pop: 移除并返回栈顶元素
        try {
            System.out.println("移除元素 (pop): " + stack.pop()); // 输出: 移除元素 (pop): 30
            System.out.println("栈内容 (pop后): " + stack); // 输出: 栈内容 (pop后): [10, 20]
        } catch (EmptyStackException e) {
            System.out.println("栈为空，无法移除元素。");
        }

        // 4. empty: 检查栈是否为空
        System.out.println("栈是否为空: " + stack.empty()); // 输出: 栈是否为空: false

        // 继续移除所有元素直至栈空
        while (!stack.empty()) {
            System.out.println("移除元素: " + stack.pop());
        }
        System.out.println("栈是否为空: " + stack.empty()); // 输出: 栈是否为空: true

        // 5. search: 搜索元素 (注意：1-based索引)
        stack.push(5); stack.push(15); stack.push(25);
        System.out.println("栈内容: " + stack);
        System.out.println("元素 15 的位置 (从栈顶算起，1-based): " + stack.search(15)); // 输出: 2
        System.out.println("元素 5 的位置: " + stack.search(5));   // 输出: 3
        System.out.println("元素 100 的位置: " + stack.search(100)); // 输出: -1 (未找到)
    }
}
```

#### 替代方案
在现代 `Java` 中，更推荐使用 `java.util.Deque` 接口作为栈，因为它提供了更一致且高效的 `API`。`ArrayDeque` 是一个基于数组的可调整大小的实现，通常是作为栈的首选。

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class DequeAsStackExample {
    public static void main(String[] args) {
        // 使用 Deque 作为栈（栈顶在列表的“末尾”或“头部”，取决于你的习惯）
        Deque<Integer> stack = new ArrayDeque<>();

        // 入栈操作：通常使用 push() 或 addFirst()
        stack.push(10); // 等同于 addFirst(10)
        stack.push(20);
        stack.push(30);
        System.out.println("栈内容 (ArrayDeque): " + stack); // 输出: [30, 20, 10] (ArrayDeque的toString，栈顶在左侧)

        // 出栈操作：通常使用 pop() 或 removeFirst()
        System.out.println("移除元素 (pop): " + stack.pop()); // 输出: 移除元素 (pop): 30
        System.out.println("栈内容 (pop后): " + stack); // 输出: 栈内容 (pop后): [20, 10]

        // 查看栈顶元素：通常使用 peek() 或 peekFirst()
        System.out.println("栈顶元素 (peek): " + stack.peek()); // 输出: 栈顶元素 (peek): 20
        System.out.println("栈内容 (peek后): " + stack); // 输出: 栈内容 (peek后): [20, 10]

        // 检查是否为空：isEmpty()
        System.out.println("栈是否为空: " + stack.isEmpty()); // 输出: 栈是否为空: false
    }
}
```

## 队列(Queue)

### 数组模拟队列
- 特点：长度固定
- 成员变量：`int[] data`, `int head`, `int tail` (初始都设为`-1`)
- 函数：`enqueue()`, `dequeue()`

#### 代码
```java
class Queue {
    private double[] data;
    private int head = -1;
    private int tail = -1;

    public Queue(int len) {
        data = new double[len];
    }
    public void enQueue(double x) throws Exception {

        if ((tail + 1) % data.length == head) {
            throw new Exception("Queue Overflow!");
        }

        if (head == -1) {
            head = 0;
        }

        tail = (tail + 1) % data.length;
        data[tail] = x;

    }

    public double deQueue() throws Exception {

        if (head == -1) {
            throw new Exception("Queue Underflow!");
        }

        double x = data[head];
        if (head == tail) {
            head = -1;
            tail = -1;
        } else {
            head = (head + 1) % data.length;
        }

        return x;
    }
}
```

### Java `Queue` 接口
由于 `Queue` 是一个接口，不能直接实例化，通常使用 `LinkedList` 作为其实现类。

#### 基本使用方法

| 方法签名 | 描述 | 示例 |
| :--- | :--- | :--- |
| `boolean offer(E e)` | 将元素插入队列尾部。如果插入成功返回 `true`。 | `queue.offer(10);` |
| `E poll()` | 移除并返回队列头部的元素。如果队列为空，返回 `null`。 | `Integer head = queue.poll();` |
| `E peek()` | 返回队列头部的元素，但不移除。如果队列为空，返回 `null`。 | `Integer head = queue.peek();` |
| `boolean isEmpty()` | 检查队列是否为空（继承自 Collection）。如果为空，返回 `true`。 | `if (queue.isEmpty()) { ... }` |
| `boolean add(E e)` | 将元素插入队列尾部。如果成功返回 `true`，如果没有可用空间则抛出 `IllegalStateException`。 | `queue.add(20);` |

#### 代码示例

```java
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        // 注意：Queue 是接口，通常使用 LinkedList 作为实现类
        Queue<Integer> queue = new LinkedList<>();

        // 1. add: 将元素添加到队尾
        queue.add(10);
        queue.add(20);
        queue.add(30);
        System.out.println("队列内容: " + queue); // 输出: 队列内容: [10, 20, 30] (左侧是队头，右侧是队尾)

        // 2. peek: 查看队头元素但不移除
        Integer headPeek = queue.peek();
        if (headPeek != null) {
            System.out.println("队头元素 (peek): " + headPeek); // 输出: 队头元素 (peek): 10
        } else {
            System.out.println("队列为空 (peek)");
        }
        System.out.println("队列内容 (peek后): " + queue); // 输出: 队列内容 (peek后): [10, 20, 30]

        // 3. poll: 移除并返回队头元素 (FIFO: 先进先出)
        Integer headPoll = queue.poll();
        System.out.println("移除元素 (poll): " + headPoll); // 输出: 移除元素 (poll): 10
        System.out.println("队列内容 (poll后): " + queue); // 输出: 队列内容 (poll后): [20, 30]

        // 4. isEmpty: 检查队列是否为空
        System.out.println("队列是否为空: " + queue.isEmpty()); // 输出: 队列是否为空: false

        // 继续移除所有元素
        while (!queue.isEmpty()) {
            System.out.println("处理并移除: " + queue.poll());
        }
        System.out.println("队列是否为空: " + queue.isEmpty()); // 输出: 队列是否为空: true
    }
}
```  

`PriorityQueue`也实现了`Queue`接口，在[二叉树](https://ferdinandhu.netlify.app/p/算法笔记3二叉树二叉搜索树bfs与dfs/#最小生成树mst)部分会有介绍

## 栈模拟队列

### Version 1: Enqueue `O(1)`
![](https://raw.githubusercontent.com/Ferdinandhu000/my_blog_img/master/20251210104349.png)
#### 结构
- `inbox`: 直接存储`enqueue`元素
- `outbox`: 存储`inbox`翻转后的元素，栈顶为`dequeue`元素

#### 流程
`inbox`直接接收`enqueue`元素。`dequeue`时，先判断`outbox`中是否有元素，若有则直接`pop`即可，若`outbox`为空，则按顺序将`inbox`中的元素`pop`到`outbox`中

#### 代码
```java
class QueueOnStack_v1 {
    private Stack<Double> inBox = new Stack<Double>();
    private Stack<Double> outBox = new Stack<Double>();

    public void enQueue(double x) {
        inBox.push(x);
    }

    public double deQueue() {
        if(outBox.isEmpty()) {
            while(!inBox.isEmpty()) outBox.push(inBox.pop());
            return (double)outBox.pop();
        }
        return (double)outBox.pop();
    }
}
```

### Version 2: Dequeue `O(1)`
![](https://raw.githubusercontent.com/Ferdinandhu000/my_blog_img/master/20251210104630.png)
#### 结构
- `in_outBox`: 时刻保持队列的结构，即栈顶元素为`dequeue`对象
- `auxiliary`: 辅助调换`in_outBox`中元素，临时存放`in_outBox`元素

#### 流程
`enqueue`时先判断`in_outBox`中有无元素，若无元素（即将放入第一个元素）则`push`进`in_outBox`。若有元素，则先将`in_outBox`元素清空，暂时存放至`auxiliary`中，再`push`待存元素进`in_outBox`，最后还原。`dequeue`时，直接`pop`出`in_outBox`中的栈顶元素即可

#### 代码
```java
class QueueOnStack_v2 {
    private Stack<Double> in_outBox = new Stack<Double>();
    private Stack<Double> auxiliary = new Stack<Double>();

    public void enQueue(double x) {
        if(in_outBox.isEmpty()) in_outBox.push(x);
        else {
            while(!in_outBox.isEmpty()) {
                auxiliary.push(in_outBox.pop());
            }
            in_outBox.push(x);
            while(!auxiliary.isEmpty()) {
                in_outBox.push(auxiliary.pop());
            }
        }
    }

    public double deQueue() {
        return (double)in_outBox.pop();
    }

}
```

## 队列模拟栈

### Version 1: Push `O(1)`
正常压入进`q1`中，`pop`时清空其余元素(临时存放至`q2`)，`pop`最后一个元素，最后还原  
![](https://raw.githubusercontent.com/Ferdinandhu000/my_blog_img/master/20251210122909.png)
#### 代码
```java
class StackOnQueue_v1 {
    private Queue<Double> q1 = new LinkedList<>();
    private Queue<Double> q2 = new LinkedList<>();

    public void push(double x) {
        q1.add(x);
    }

    public double pop() {
        while(q1.size() - 1 != 0) {
            q2.add(q1.poll());
        }
        double x = q1.poll();
        q1.clear();
        while(!q2.isEmpty()) {
            q1.add(q2.poll());
        }
        return x;
    }
}
```

### Version 2: Pop `O(1)`
始终维持`q1`是栈的结构，即队列尾是`pop`的对象(借助`q2`临时存放`q1`元素来实现)  
![](https://raw.githubusercontent.com/Ferdinandhu000/my_blog_img/master/20251210123402.png)
#### 代码
```java
class StackOnQueue_v2 {
    private Queue<Double> q1 = new LinkedList<>();
    private Queue<Double> q2 = new LinkedList<>();

    public void push(double x) {
        if(!q1.isEmpty()) {
            while(!q1.isEmpty()) {
                q2.add(q1.poll());
            }
            q1.add(x);
            while(!q2.isEmpty()) {
                q1.add(q2.poll());
            }
        } else {
            q1.add(x);
        }
    }

    public double pop() {
        return q1.poll();
    }
}
```

## 链表(LinkedList)
### 节点 (`Node`)
#### 构成
- 值 `val`
- 前向指针 `prev`
- 后向指针 `next`

#### 代码
```java
class Node {
    int val;
    Node prev;
    Node next;

    public Node(int x) {
        this.val = x;
        prev = next = null;
    }
}
```

### 带有`Sentinel`节点的双向链表
#### 特点
- 含有`Sentinel`哨兵节点`nil`
- 初始化阶段`nil`节点的前和后都指向自己

#### 代码
```java
class LinkedNodeSentinel {
    Node nil;

    public LinkedNodeSentinel () {
        nil = new Node(-1);
        nil.prev = nil;
        nil.next = nil;
    }

    // Sentinel的插入操作是插在nil节点后
    // 先搭建x的后向连接(x.next & nil.next.pre)，再搭建x的前向连接(nil.next & x.prev)
    public void insert(Node x) {
        x.next = nil.next;
        nil.next.prev = x;
        nil.next = x;
        x.prev = nil;
    }

    public Node search(int x) {
        Node n = nil.next; // 从nil.next开始寻找
        // 如果找到或者回到nil则循环停止
        while(n != nil && n.val != x) {
            n = n.next;
        }
        if(n == nil) {
            System.out.println(" Value Not Found!");
        }
        return n;
    }

    public void delete(int x) {
        Node n = search(x);
        if(n == nil) {
            return;
        }
        // 记得要重新搭建连接
        n.prev.next = n.next;
        n.next.prev = n.prev;
    }

    public boolean isEmpty() {
        if(nil.next == nil) return true;
        return false;
    }

    @Override
    public String toString() {
        String s = "";
        Node n = nil.next;
        while(n != nil) {
            s += n.val + " ";
            n = n.next;
        }
        return s;
    }
}
```

## 链表模拟栈

### 思路
- 栈的`push`方法对应链表中的`insert`方法
- 栈的`pop`方法对应链表中的`popFront`方法(需再写一个`popFront`)

#### 代码

`LinkedList`的`popFront`方法
```java
public Node popFront() {
    Node n = nil.next;
    return n;
}
```

`StackOnLL`
```java
class StackOnLL {
    LinkedNodeSentinel ll;

    // 在构造函数中创建一个链表的实例
    public StackOnLL() {
        ll = new LinkedNodeSentinel();
    }
    
    public void push(int x) {
        ll.insert(new Node(x));
    }

    public int pop() {
        if(isEmpty()) System.out.println("The stack is empty!");
        int x = ll.popFront().val;
        ll.delete(x);
        return x;
    }

    public boolean isEmpty() {
        if(ll.isEmpty()) return true;
        return false;
    }

    @Override
    public String toString() {
        return ll.toString();
    }
}
```

## 链表模拟队列

### 思路
- 队列的`enQueue`方法对应链表中的`insert`方法
- 队列的`deQueue`方法对应链表中的`popBack`方法(需再写一个`popBack`)

#### 代码

`LinkedList`的`popBack`方法
```java
public Node popBack() {
    Node n = nil.prev;
    return n;
}
```

`QueueOnLL`
```java
class QueueOnLL {
    LinkedNodeSentinel ll;

    public QueueOnLL() {
        ll = new LinkedNodeSentinel();
    }

    public void enQueue(int x) {
        ll.insert(new Node(x));
    }

    public int deQueue() {
        if(isEmpty()) System.out.println("The queue is empty!");
        int x = ll.popBack().val;
        ll.delete(x);
        return x;
    }

    public boolean isEmpty() {
        if(ll.isEmpty()) return true;
        return false;
    }

    @Override
    public String toString() {
        return ll.toString();
    }
}
```