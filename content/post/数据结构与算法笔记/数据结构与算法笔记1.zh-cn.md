---
title: "算法笔记1——各类排序算法"
date: 2025-12-17T16:25:58+08:00
math: true
draft: false
categories : 
  - Java
  - Notes

---

## 各类排序算法

### 冒泡排序 (Bubble Sort)

#### 思路
从 i = 0 开始，每次比较下标为 i 和 i+1 的数字，若前者大则二者交换，最终位于列尾的为本轮循环中最大者

#### 代码
```java
public static void bubbleSort(int[] arr) {
   int n = arr.length;
   for(int i = 0; i < n-1; i++) {
       for(int j = 0; j < n-i-1; j++) {
           if(arr[j] > arr[j+1]) {
               int temp = arr[j];
               arr[j] = arr[j+1];
               arr[j+1] = temp;
           }
       }
   }
}
```

#### 复杂度分析
- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$

### 选择排序 (Selection Sort)
#### 思路
每一轮从未排序的部分中找到最小（或最大）的元素，放到已排序部分的末尾。具体做法是，假设当前处理第 i 个位置，就从 i 到数组末尾找出最小值的下标，然后将其与第 i 个元素交换。这样每一轮都能确定一个元素的最终位置，直到全部有序。

#### 代码
```java
public static void selectionSort(int[] arr) {
    int n = arr.length;
    for(int i = 0; i < n-1; i++) {
        int min_idx = i;
        for(int j = i + 1; j < n; j++) {
            if(arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        if(min_idx != i) {
            int temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
}
```

#### 复杂度分析
- 时间复杂度：$O(n^2)$  
- 空间复杂度：$O(1)$  

### 插入排序 (Insersion Sort)
#### 思路
从第二个元素开始（索引 1），将当前元素视为“待插入元素”，与其左侧已排序序列从右到左逐个比较，凡是比它大的元素都向右移动一位，直到找到第一个不大于它的位置，将该元素插入到该位置。重复此过程，已排序区间逐步向右扩展

#### 代码
```java
public static void insertionSort(double[] a) {
    int n = a.length;
    for(int j = 1; j < n; j++) {
        double key = a[j];
        int i = j - 1;
        while(i >= 0 && a[i] > key) {
            a[i+1] = a[i];
            i--;
        }
        a[i+1] = key;
    }
}
```

#### 复杂度分析
 - 时间复杂度：平均/最坏 $O(n^2)$，最好 $O(n)$
 - 空间复杂度：$O(1)$

### 归并排序 (Merge Sort)
#### 思路
采用分治策略：将数组递归地一分为二，分别对左右子数组排序；然后在合并阶段用两个指针线性地将两个有序子数组合并为一个有序数组

#### 流程
1. 递归处理左半边
2. 递归处理右半边
3. 合并  
    - 左右两部分先分别写入L, R两临时数组中
    - 初始化两指针i, j分别指向L, R的首位，依次比较取较大者写入原数组中，并将指针向右移动

#### 代码
```java
public static void mergeSort(double[] a, int p, int r) {
    if(p >= r) return;
    int q = (p + r ) / 2;
    mergeSort(a, p, q); // 递归处理左半边
    mergeSort(a, q + 1, r); // 递归处理右半边
    
    merge(a, p, q, r); // 合并操作
}

public static void merge(double[] a, int p, int q, int r) {
    int n1 = q - p + 1;
    int n2 = r - q;
    double[] L = new double[n1 + 1]; // 在末尾加上一项正无穷，故要加1
    double[] R = new double[n2 + 1];
    // 将左半边数据存入L数组中
    for(int i = 0; i < n1; i++) {
        L[i] = a[p + i];
    }
    L[n1] = Double.POSITIVE_INFINITY;
    // 将右半边数据存入R数组中
    for(int j = 0; j < n2; j++) {
        R[j] = a[q + 1 + j];
    }
    R[n2] = Double.POSITIVE_INFINITY;
    // i, j指针指向R, L两数组中的元素进行比较
    int i = 0, j = 0, k = p;
    while(k <= r) {
        if(L[i] <= R[j]) a[k++] = L[i++];
        else a[k++] = R[j++];
    }
}
```

#### 复杂度分析
 - 时间复杂度：$O(n\log n)$
 - 空间复杂度：$O(n)$


### 快速排序 (Quick Sort)
#### 思路
分治与原地划分：选择一个枢轴（如末尾元素），通过一次扫描将数组分成“<= 枢轴”和“> 枢轴”的两部分，枢轴就位；递归地对两侧子数组分别快速排序。

#### 流程
1. 选择枢轴（此实现选用末尾元素）
2. 线性扫描并划分：维护指针 i 记录“<= 枢轴”的区间尾部，扫描指针 j 遍历 [p, r-1]  
   **注意 i 初始为 p - 1，j 取 p**  
   - 若 a[j] <= 枢轴，则 i 前进并交换 a[i], a[j]
3. 扫描结束后将枢轴与 a[i+1] 交换，使枢轴就位，得到分割点 q = i + 1
4. 递归处理左区间 [p, q-1] 与右区间 [q+1, r]   
   **注意不包含 q 位置**

#### 代码 
```java
public static void quickSort(double[] a, int p, int r) {
    if(p < r) {
        int q = partition(a, p, r);
        quickSort(a, p, q - 1);
        quickSort(a, q + 1, r);
    }
}
public static int partition(double[] a, int p, int r) {
    double x = a[r];
    int i = p - 1; // 注意这里i取初始下标-1
    for(int j = p; j < r; j++) {
        if(a[j] <= x) {
            i += 1;
            swap(a, i, j);
        }
    }
    swap(a, r, ++i); // 这里为了简写使用前++，因此后一行返回的i为加一后的i
    return i;
}
public static void swap(double[] a, int i, int j) {
    double temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}
```
#### 复杂度分析
 - 时间复杂度：平均 $O(n\log n)$；最坏$O(n^2)$
 - 空间复杂度：$O(\log n)$


### 堆排序 (Heap Sort)

#### 前序知识
- 二叉完树：完全二叉树。除最后一层外均已填满，且最后一层节点尽量靠左。
- 堆：基于完全二叉树的数组存储结构；最大堆满足任一节点的值均不小于其子节点；最小堆反之。
- 父节点：在 0 基索引下，parent(i) = (i - 1) / 2。
- 根节点：在 0 基索引下，根的下标为 0。
- 子节点：在 0 基索引下，left(i) = 2i + 1，right(i) = 2i + 2。
- 叶子节点：没有任何子节点的节点。在 0 基索引下，i ≥ n/2 的节点均为叶子节点。

#### 思路
构建最大堆，使堆顶为当前范围内的最大值；将堆顶与末尾元素交换，缩小有效堆区间，然后对新堆顶执行heapify恢复堆性质；重复直到区间长度为 1。

#### 流程
1. 先做一次构建最大堆 buildMaxHeap(a)，将任意一个数组转为最大堆
2. 从最后一位开始，依次将首位与最后一位交换位置，并将 heapSize - 1，在堆中除去目前已经存入的最大值的那一项
3. 在首位做一次最大堆化 maxHeapify(a, 0, heapSize) **注意此时的 heapSize 已经减1了**

#### 代码 
```java
public static void heapSort(double[] a) {
    buildMaxHeap(a);
    int heapSize = a.length - 1; // 这里的heapSize为最后一项的下标，下同
    
    for(int i = heapSize; i > 0; i--) { // 注意这里不必循环至第0项
        swap(a, 0, heapSize);
        heapSize--;
        maxHeapify(a, 0, heapSize);
    }
}

private static void maxHeapify(double[] a, int i, int heapSize) {
    // 找第i位与其左右子节点中最大者
    int l = i * 2 + 1;
    int r = i * 2 + 2;
    int largest = i;
    if(l <= heapSize && a[l] > a[largest]) {
        largest = l;
    }
    if(r <= heapSize && a[r] > a[largest]) {
        largest = r;
    }
    
    if(largest != i) {
        swap(a, largest, i);
        maxHeapify(a, largest, heapSize); // 这里是对largest为下标做最大堆化，此时largest下标为替换后的i
    }
}

private static void buildMaxHeap(double[] a) {
    int heapSize = a.length - 1; 
    // 从第一个不是叶子节点的下标开始，即 (heapSize - 1) / 2
    for(int i = (heapSize - 1) / 2; i >= 0; i--) {
        maxHeapify(a, i, heapSize);
    }
}

private static void swap(double[] a, int i, int j) {
    double temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}
```

#### 复杂度分析
 - 时间复杂度：$O(n\log n)$
 - 空间复杂度：$O(1)$

### 计数排序 (Counting Sort)

#### 思路
非比较排序。利用元素的值作为数组下标来统计频次。核心是利用辅助数组 `C`，其中 `C[x]` 记录数值 `x` 出现的次数。然后对 `C` 求前缀和，确定每个数在排序后数组中的位置。适用于数值范围较小的整数排序。

#### 流程
1. 找出数组 `A` 中的最大值 `k`。
2. 创建大小为 `k + 1` 的计数数组 `C`，遍历 `A` 统计每个数出现的频次。
3. 对 `C` 进行累加（计算前缀和），`C[i]` 表示小于等于 `i` 的元素个数，即值 `i` 在输出数组中的结束位置索引（1-based）。
4. 反向遍历 `A`（保证稳定性），将 `A[j]` 放入结果数组 `B` 的正确位置 `C[A[j]] - 1`，并将 `C[A[j]]` 减 1。

#### 代码
```java
private static int[] countingSort(int[] A) {
    int k = findMax(A);

    int[] B = new int[A.length];
    int[] C = new int[k + 1];
    // 统计频率
    for(int x : A) {
        C[x]++;
    }

    // 计算累加频次（前缀和）
    // C[i] 现在表示 <= i 的元素总数
    for(int i = 1; i < k + 1; i++) {
        C[i] += C[i-1]; 
    }

    // 反向遍历构建输出数组 B
    for(int j = A.length - 1; j >= 0; j--) {
        B[C[A[j]] - 1] = A[j]; // 放入 B 中正确位置
        C[A[j]]--;             // 该位置已被占用，前移一位
    }
    
    return B;
}

private static int findMax(int[] A) {
    int max = Integer.MIN_VALUE;
    for(int x : A) {
        max = Math.max(max, x);
    }
    return max;
}
```

#### 复杂度分析
 - 时间复杂度：$O(n + k)$
 - 空间复杂度：$O(n + k)$
 - 特点：稳定排序，适用于 `k` 不大的场景。

### 基数排序 (Radix Sort)

#### 思路
非比较排序。将整数按位数切割成不同的数字，然后按每个位数分别比较。
常见的做法是按照“低位优先”（LSD, Least Significant Digit）策略，从最低位开始，依次对每一位进行稳定排序（如计数排序或桶排序）。当最高位排序完成后，数列就变成有序序列。
*注意：本代码示例中使用的是二进制位的基数排序（Binary Radix Sort），每次检查 1 个 bit（0 或 1），共循环 32 次（对应 int 的位数）。这本质上是将数字看作 32 位的 01 串进行排序。*

#### 流程（二进制位版本）
1. 循环 `i` 从 0 到 31（共 32 位，对应 Java `int` 长度）。
2. 在每一轮 `i` 中，创建两个桶（列表）`a0` 和 `a1`。
3. 遍历数组中的每个数 `x`，判断其第 `i` 位是 0 还是 1 (`x >> i & 1`)。
    - 如果是 0，放入 `a0`。
    - 如果是 1，放入 `a1`。
4. 将 `a0` 和 `a1` 中的元素依次放回原数组，完成对第 `i` 位的排序。
5. 重复上述步骤直到最高位。

#### 代码
```java
private static void radixSort(int[] arr) {
    // 对 int 的 32 个位依次进行排序
    for(int i = 0; i < 32; i++) {
        List<Integer> a0 = new ArrayList<>(); // 存放当前位为 0 的数
        List<Integer> a1 = new ArrayList<>(); // 存放当前位为 1 的数
        
        // 分桶
        for(int x : arr) {
            // 获取第 i 位的值 (0 或 1)
            int id = x >> i & 1;
            if(id == 0) a0.add(x);
            else a1.add(x);
        }
        
        // 合并回原数组
        // 先放 0 的桶
        for(int j = 0; j < a0.size(); j++) {
            arr[j] = a0.get(j);
        }
        // 再放 1 的桶
        for(int k = 0; k < a1.size(); k++) {
            arr[a0.size() + k] = a1.get(k);
        }
    }
}
```

#### 复杂度分析
 - 时间复杂度：$O(d \cdot n)$，其中 $d$ 是最大值的位数（此处为 32），$n$ 是数组长度。
 - 空间复杂度：$O(n)$，需要额外的桶空间来暂存数据。
 - 特点：稳定排序。

