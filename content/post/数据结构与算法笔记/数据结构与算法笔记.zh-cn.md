---
title: "数据结构与算法笔记"
date: 2025-09-30T18:02:58+08:00
math: 
draft: false
categories : 
  - Java
  - Notes

---

## 排序算法
### 冒泡排序 (Bubble Sort)

#### 思路
从 i = 0 开始，每次比较下标为 i 和 i+1 的数字，若前者大则二者交换，最终位于列尾的为本轮循环中最大者

#### 代码
```java
public static void bubbleSort(int[] arr) {
   int n = arr.length;
   for(int i = 0; i < n-1; i++) {
       for(int j = 0; j < n-i-1; j++) {
           if(arr[j] > arr[j+1]) {
               int temp = arr[j];
               arr[j] = arr[j+1];
               arr[j+1] = temp;
           }
       }
   }
}
```

#### 复杂度分析
- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(1)$

### 选择排序 (Selection Sort)
#### 思路
每一轮从未排序的部分中找到最小（或最大）的元素，放到已排序部分的末尾。具体做法是，假设当前处理第 i 个位置，就从 i 到数组末尾找出最小值的下标，然后将其与第 i 个元素交换。这样每一轮都能确定一个元素的最终位置，直到全部有序。

#### 代码
```java
public static void selectionSort(int[] arr) {
    int n = arr.length;
    for(int i = 0; i < n-1; i++) {
        int min_idx = i;
        for(int j = i + 1; j < n; j++) {
            if(arr[j] < arr[min_idx]) {
                min_idx = j;
            }
        }
        if(min_idx != i) {
            int temp = arr[min_idx];
            arr[min_idx] = arr[i];
            arr[i] = temp;
        }
    }
}
```

#### 复杂度分析
- 时间复杂度：$O(n^2)$  
- 空间复杂度：$O(1)$  

### 插入排序 (Insersion Sort)
#### 思路
从第二个元素开始（索引 1），将当前元素视为“待插入元素”，与其左侧已排序序列从右到左逐个比较，凡是比它大的元素都向右移动一位，直到找到第一个不大于它的位置，将该元素插入到该位置。重复此过程，已排序区间逐步向右扩展

#### 代码
```java
public static void insertionSort(double[] a) {
    int n = a.length;
    for(int j = 1; j < n; j++) {
        double key = a[j];
        int i = j - 1;
        while(i >= 0 && a[i] > key) {
            a[i+1] = a[i];
            i--;
        }
        a[i+1] = key;
    }
}
```

#### 复杂度分析
 - 时间复杂度：平均/最坏 $O(n^2)$，最好 $O(n)$
 - 空间复杂度：$O(1)$

### 归并排序 (Merge Sort)
#### 思路
采用分治策略：将数组递归地一分为二，分别对左右子数组排序；然后在合并阶段用两个指针线性地将两个有序子数组合并为一个有序数组

#### 流程
1. 递归处理左半边
2. 递归处理右半边
3. 合并  
    - 左右两部分先分别写入L, R两临时数组中
    - 初始化两指针i, j分别指向L, R的首位，依次比较取较大者写入原数组中，并将指针向右移动

#### 代码
```java
public static void mergeSort(double[] a, int p, int r) {
    if(p >= r) return;
    int q = (p + r ) / 2;
    mergeSort(a, p, q); // 递归处理左半边
    mergeSort(a, q + 1, r); // 递归处理右半边
    
    merge(a, p, q, r); // 合并操作
}

public static void merge(double[] a, int p, int q, int r) {
    int n1 = q - p + 1;
    int n2 = r - q;
    double[] L = new double[n1 + 1]; // 在末尾加上一项正无穷，固要加1
    double[] R = new double[n2 + 1];
    // 将左半边数据存入L数组中
    for(int i = 0; i < n1; i++) {
        L[i] = a[p + i];
    }
    L[n1] = Double.POSITIVE_INFINITY;
    // 将右半边数据存入R数组中
    for(int j = 0; j < n2; j++) {
        R[j] = a[q + 1 + j];
    }
    R[n2] = Double.POSITIVE_INFINITY;
    // i, j指针指向R, L两数组中的元素进行比较
    int i = 0, j = 0, k = p;
    while(k <= r) {
        if(L[i] <= R[j]) a[k++] = L[i++];
        else a[k++] = R[j++];
    }
}
```

#### 复杂度分析
 - 时间复杂度：$O(n\log n)$
 - 空间复杂度：$O(n)$


### 快速排序 (Quick Sort)
#### 思路
分治与原地划分：选择一个枢轴（代码中为末尾元素），通过一次线性扫描将数组分成“<= 枢轴”和“> 枢轴”的两部分，枢轴就位；递归地对两侧子数组分别快速排序。

#### 流程
1. 选择枢轴（此实现选用末尾元素）
2. 线性扫描并划分：维护指针 i 记录“<= 枢轴”的区间尾部，扫描指针 j 遍历 [p, r-1]  
   **注意 i 初始为 p - 1，j 取 p**  
   - 若 a[j] <= 枢轴，则 i 前进并交换 a[i], a[j]
3. 扫描结束后将枢轴与 a[i+1] 交换，使枢轴就位，得到分割点 q = i + 1
4. 递归处理左区间 [p, q-1] 与右区间 [q+1, r]   
   **注意不包含 q 位置**

#### 代码 
```java
public static void quickSort(double[] a, int p, int r) {
    if(p < r) {
        int q = partition(a, p, r);
        quickSort(a, p, q - 1);
        quickSort(a, q + 1, r);
    }
}
public static int partition(double[] a, int p, int r) {
    double x = a[r];
    int i = p - 1;
    for(int j = p; j < r; j++) {
        if(a[j] <= x) {
            i += 1;
            swap(a, i, j);
        }
    }
    swap(a, r, ++i); // 这里为了简写使用前++，因此后一行返回的i为加一后的i
    return i;
}
public static void swap(double[] a, int i, int j) {
    double temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}
```
#### 复杂度分析
 - 时间复杂度：平均 $O(n\log n)$；最坏$O(n^2)$
 - 空间复杂度：$O(\log n)$


### 堆排序 (Heap Sort)

#### 前序知识
- 二叉完树：完全二叉树。除最后一层外均已填满，且最后一层节点尽量靠左。
- 堆：基于完全二叉树的数组存储结构；大根堆满足任一节点的值均不小于其子节点；小根堆反之。
- 父节点：在 0 基索引下，parent(i) = (i - 1) / 2。
- 根节点：在 0 基索引下，根的下标为 0。
- 子节点：在 0 基索引下，left(i) = 2i + 1，right(i) = 2i + 2。
- 叶子节点：没有任何子节点的节点。在 0 基索引下，i ≥ n/2 的节点均为叶子节点。

![](https://raw.githubusercontent.com/Ferdinandhu000/my_blog_img/master/20250930163716.png)


#### 思路
构建最大堆，使堆顶为当前范围内的最大值；将堆顶与末尾元素交换，缩小有效堆区间，然后对新堆顶执行最大堆化恢复堆性质；重复直到区间长度为 1。

#### 流程
1. 先做一次构建最大堆 buildMaxHeap(a)，将任意一个数组转为最大堆
2. 从最后一位开始，依次将首位与最后一位交换位置，并将 heapSize - 1，在堆中除去目前已经存入的最大值的那一项
3. 在首位做一次最大堆化 maxHeapify(a, 0, heapSize) **注意此时的 heapSize 已经减1了**

#### 代码 
```java
public static void heapSort(double[] a) {
    buildMaxHeap(a);
    int heapSize = a.length - 1; // 这里的heapSize为最后一项的下标，下同
    
    for(int i = heapSize; i > 0; i--) { // 注意这里不必循环至第0项
        swap(a, 0, heapSize);
        heapSize--;
        maxHeapify(a, 0, heapSize);
    }
}

private static void maxHeapify(double[] a, int i, int heapSize) {
    // 找第i位与其左右子节点中最大者
    int l = i * 2 + 1;
    int r = i * 2 + 2;
    int largest = i;
    if(l < heapSize && a[l] > a[largest]) {
        largest = l;
    }
    if(r < heapSize && a[r] > a[largest]) {
        largest = r;
    }
    
    if(largest != i) {
        swap(a, largest, i);
        maxHeapify(a, largest, heapSize); // 这里是对largest为下标做最大堆化，此时largest下标为替换后的i
    }
}

private static void buildMaxHeap(double[] a) {
    int heapSize = a.length - 1; 
    // 从第一个不是叶子节点的下标开始，即 (heapSize - 1) / 2
    for(int i = (heapSize - 1) / 2; i >= 0; i--) {
        maxHeapify(a, i, heapSize);
    }
}

private static void swap(double[] a, int i, int j) {
    double temp = a[i];
    a[i] = a[j];
    a[j] = temp;
}
```

#### 复杂度分析
 - 时间复杂度：$O(n\log n)$
 - 空间复杂度：$O(1)$